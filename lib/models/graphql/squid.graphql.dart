import "dart:typed_data" show Uint8List;

class Input$AccountAggregateBoolExp {
  factory Input$AccountAggregateBoolExp(
          {Input$accountAggregateBoolExpCount? count}) =>
      Input$AccountAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$AccountAggregateBoolExp._(this._$data);

  factory Input$AccountAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$accountAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$AccountAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$accountAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$accountAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AccountAggregateBoolExp<Input$AccountAggregateBoolExp>
      get copyWith => CopyWith$Input$AccountAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$AccountAggregateBoolExp<TRes> {
  factory CopyWith$Input$AccountAggregateBoolExp(
    Input$AccountAggregateBoolExp instance,
    TRes Function(Input$AccountAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$AccountAggregateBoolExp;

  factory CopyWith$Input$AccountAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountAggregateBoolExp;

  TRes call({Input$accountAggregateBoolExpCount? count});
  CopyWith$Input$accountAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$AccountAggregateBoolExp<TRes>
    implements CopyWith$Input$AccountAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$AccountAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$AccountAggregateBoolExp _instance;

  final TRes Function(Input$AccountAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$AccountAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$accountAggregateBoolExpCount?),
      }));

  CopyWith$Input$accountAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$accountAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$accountAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$AccountAggregateBoolExp<TRes>
    implements CopyWith$Input$AccountAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$AccountAggregateBoolExp(this._res);

  TRes _res;

  call({Input$accountAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$accountAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$accountAggregateBoolExpCount.stub(_res);
}

class Input$accountAggregateBoolExpCount {
  factory Input$accountAggregateBoolExpCount({
    List<Enum$AccountSelectColumn>? arguments,
    bool? distinct,
    Input$AccountBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$accountAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$accountAggregateBoolExpCount._(this._$data);

  factory Input$accountAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AccountSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$AccountBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$accountAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$AccountSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$AccountSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$AccountBoolExp? get filter =>
      (_$data['filter'] as Input$AccountBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] =
          l$arguments?.map((e) => toJson$Enum$AccountSelectColumn(e)).toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$accountAggregateBoolExpCount<
          Input$accountAggregateBoolExpCount>
      get copyWith => CopyWith$Input$accountAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$accountAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$accountAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$accountAggregateBoolExpCount(
    Input$accountAggregateBoolExpCount instance,
    TRes Function(Input$accountAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$accountAggregateBoolExpCount;

  factory CopyWith$Input$accountAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$accountAggregateBoolExpCount;

  TRes call({
    List<Enum$AccountSelectColumn>? arguments,
    bool? distinct,
    Input$AccountBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$AccountBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$accountAggregateBoolExpCount<TRes>
    implements CopyWith$Input$accountAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$accountAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$accountAggregateBoolExpCount _instance;

  final TRes Function(Input$accountAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$accountAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$AccountSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$AccountBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$AccountBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$accountAggregateBoolExpCount<TRes>
    implements CopyWith$Input$accountAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$accountAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$AccountSelectColumn>? arguments,
    bool? distinct,
    Input$AccountBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$AccountBoolExp<TRes> get filter =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$AccountAggregateOrderBy {
  factory Input$AccountAggregateOrderBy({
    Enum$OrderBy? count,
    Input$AccountMaxOrderBy? max,
    Input$AccountMinOrderBy? min,
  }) =>
      Input$AccountAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  Input$AccountAggregateOrderBy._(this._$data);

  factory Input$AccountAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$AccountMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$AccountMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    return Input$AccountAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$AccountMaxOrderBy? get max =>
      (_$data['max'] as Input$AccountMaxOrderBy?);

  Input$AccountMinOrderBy? get min =>
      (_$data['min'] as Input$AccountMinOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AccountAggregateOrderBy<Input$AccountAggregateOrderBy>
      get copyWith => CopyWith$Input$AccountAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountAggregateOrderBy<TRes> {
  factory CopyWith$Input$AccountAggregateOrderBy(
    Input$AccountAggregateOrderBy instance,
    TRes Function(Input$AccountAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$AccountAggregateOrderBy;

  factory CopyWith$Input$AccountAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountAggregateOrderBy;

  TRes call({
    Enum$OrderBy? count,
    Input$AccountMaxOrderBy? max,
    Input$AccountMinOrderBy? min,
  });
  CopyWith$Input$AccountMaxOrderBy<TRes> get max;
  CopyWith$Input$AccountMinOrderBy<TRes> get min;
}

class _CopyWithImpl$Input$AccountAggregateOrderBy<TRes>
    implements CopyWith$Input$AccountAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$AccountAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$AccountAggregateOrderBy _instance;

  final TRes Function(Input$AccountAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(Input$AccountAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$AccountMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$AccountMinOrderBy?),
      }));

  CopyWith$Input$AccountMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$AccountMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$AccountMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$AccountMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountMinOrderBy(local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$Input$AccountAggregateOrderBy<TRes>
    implements CopyWith$Input$AccountAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$AccountAggregateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? count,
    Input$AccountMaxOrderBy? max,
    Input$AccountMinOrderBy? min,
  }) =>
      _res;

  CopyWith$Input$AccountMaxOrderBy<TRes> get max =>
      CopyWith$Input$AccountMaxOrderBy.stub(_res);

  CopyWith$Input$AccountMinOrderBy<TRes> get min =>
      CopyWith$Input$AccountMinOrderBy.stub(_res);
}

class Input$AccountBoolExp {
  factory Input$AccountBoolExp({
    List<Input$AccountBoolExp>? $_and,
    Input$AccountBoolExp? $_not,
    List<Input$AccountBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$IdentityBoolExp? linkedIdentity,
    Input$StringComparisonExp? linkedIdentityId,
    Input$TransferBoolExp? transfersIssued,
    Input$TransferAggregateBoolExp? transfersIssuedAggregate,
    Input$TransferBoolExp? transfersReceived,
    Input$TransferAggregateBoolExp? transfersReceivedAggregate,
    Input$ChangeOwnerKeyBoolExp? wasIdentity,
    Input$ChangeOwnerKeyAggregateBoolExp? wasIdentityAggregate,
  }) =>
      Input$AccountBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (linkedIdentity != null) r'linkedIdentity': linkedIdentity,
        if (linkedIdentityId != null) r'linkedIdentityId': linkedIdentityId,
        if (transfersIssued != null) r'transfersIssued': transfersIssued,
        if (transfersIssuedAggregate != null)
          r'transfersIssuedAggregate': transfersIssuedAggregate,
        if (transfersReceived != null) r'transfersReceived': transfersReceived,
        if (transfersReceivedAggregate != null)
          r'transfersReceivedAggregate': transfersReceivedAggregate,
        if (wasIdentity != null) r'wasIdentity': wasIdentity,
        if (wasIdentityAggregate != null)
          r'wasIdentityAggregate': wasIdentityAggregate,
      });

  Input$AccountBoolExp._(this._$data);

  factory Input$AccountBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map(
              (e) => Input$AccountBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$AccountBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map(
              (e) => Input$AccountBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('linkedIdentity')) {
      final l$linkedIdentity = data['linkedIdentity'];
      result$data['linkedIdentity'] = l$linkedIdentity == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$linkedIdentity as Map<String, dynamic>));
    }
    if (data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = data['linkedIdentityId'];
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$linkedIdentityId as Map<String, dynamic>));
    }
    if (data.containsKey('transfersIssued')) {
      final l$transfersIssued = data['transfersIssued'];
      result$data['transfersIssued'] = l$transfersIssued == null
          ? null
          : Input$TransferBoolExp.fromJson(
              (l$transfersIssued as Map<String, dynamic>));
    }
    if (data.containsKey('transfersIssuedAggregate')) {
      final l$transfersIssuedAggregate = data['transfersIssuedAggregate'];
      result$data['transfersIssuedAggregate'] =
          l$transfersIssuedAggregate == null
              ? null
              : Input$TransferAggregateBoolExp.fromJson(
                  (l$transfersIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('transfersReceived')) {
      final l$transfersReceived = data['transfersReceived'];
      result$data['transfersReceived'] = l$transfersReceived == null
          ? null
          : Input$TransferBoolExp.fromJson(
              (l$transfersReceived as Map<String, dynamic>));
    }
    if (data.containsKey('transfersReceivedAggregate')) {
      final l$transfersReceivedAggregate = data['transfersReceivedAggregate'];
      result$data['transfersReceivedAggregate'] =
          l$transfersReceivedAggregate == null
              ? null
              : Input$TransferAggregateBoolExp.fromJson(
                  (l$transfersReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('wasIdentity')) {
      final l$wasIdentity = data['wasIdentity'];
      result$data['wasIdentity'] = l$wasIdentity == null
          ? null
          : Input$ChangeOwnerKeyBoolExp.fromJson(
              (l$wasIdentity as Map<String, dynamic>));
    }
    if (data.containsKey('wasIdentityAggregate')) {
      final l$wasIdentityAggregate = data['wasIdentityAggregate'];
      result$data['wasIdentityAggregate'] = l$wasIdentityAggregate == null
          ? null
          : Input$ChangeOwnerKeyAggregateBoolExp.fromJson(
              (l$wasIdentityAggregate as Map<String, dynamic>));
    }
    return Input$AccountBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AccountBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$AccountBoolExp>?);

  Input$AccountBoolExp? get $_not => (_$data['_not'] as Input$AccountBoolExp?);

  List<Input$AccountBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$AccountBoolExp>?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get identity =>
      (_$data['identity'] as Input$IdentityBoolExp?);

  Input$IdentityBoolExp? get linkedIdentity =>
      (_$data['linkedIdentity'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get linkedIdentityId =>
      (_$data['linkedIdentityId'] as Input$StringComparisonExp?);

  Input$TransferBoolExp? get transfersIssued =>
      (_$data['transfersIssued'] as Input$TransferBoolExp?);

  Input$TransferAggregateBoolExp? get transfersIssuedAggregate =>
      (_$data['transfersIssuedAggregate'] as Input$TransferAggregateBoolExp?);

  Input$TransferBoolExp? get transfersReceived =>
      (_$data['transfersReceived'] as Input$TransferBoolExp?);

  Input$TransferAggregateBoolExp? get transfersReceivedAggregate =>
      (_$data['transfersReceivedAggregate'] as Input$TransferAggregateBoolExp?);

  Input$ChangeOwnerKeyBoolExp? get wasIdentity =>
      (_$data['wasIdentity'] as Input$ChangeOwnerKeyBoolExp?);

  Input$ChangeOwnerKeyAggregateBoolExp? get wasIdentityAggregate =>
      (_$data['wasIdentityAggregate'] as Input$ChangeOwnerKeyAggregateBoolExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('linkedIdentity')) {
      final l$linkedIdentity = linkedIdentity;
      result$data['linkedIdentity'] = l$linkedIdentity?.toJson();
    }
    if (_$data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = linkedIdentityId;
      result$data['linkedIdentityId'] = l$linkedIdentityId?.toJson();
    }
    if (_$data.containsKey('transfersIssued')) {
      final l$transfersIssued = transfersIssued;
      result$data['transfersIssued'] = l$transfersIssued?.toJson();
    }
    if (_$data.containsKey('transfersIssuedAggregate')) {
      final l$transfersIssuedAggregate = transfersIssuedAggregate;
      result$data['transfersIssuedAggregate'] =
          l$transfersIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('transfersReceived')) {
      final l$transfersReceived = transfersReceived;
      result$data['transfersReceived'] = l$transfersReceived?.toJson();
    }
    if (_$data.containsKey('transfersReceivedAggregate')) {
      final l$transfersReceivedAggregate = transfersReceivedAggregate;
      result$data['transfersReceivedAggregate'] =
          l$transfersReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('wasIdentity')) {
      final l$wasIdentity = wasIdentity;
      result$data['wasIdentity'] = l$wasIdentity?.toJson();
    }
    if (_$data.containsKey('wasIdentityAggregate')) {
      final l$wasIdentityAggregate = wasIdentityAggregate;
      result$data['wasIdentityAggregate'] = l$wasIdentityAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AccountBoolExp<Input$AccountBoolExp> get copyWith =>
      CopyWith$Input$AccountBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$linkedIdentity = linkedIdentity;
    final lOther$linkedIdentity = other.linkedIdentity;
    if (_$data.containsKey('linkedIdentity') !=
        other._$data.containsKey('linkedIdentity')) {
      return false;
    }
    if (l$linkedIdentity != lOther$linkedIdentity) {
      return false;
    }
    final l$linkedIdentityId = linkedIdentityId;
    final lOther$linkedIdentityId = other.linkedIdentityId;
    if (_$data.containsKey('linkedIdentityId') !=
        other._$data.containsKey('linkedIdentityId')) {
      return false;
    }
    if (l$linkedIdentityId != lOther$linkedIdentityId) {
      return false;
    }
    final l$transfersIssued = transfersIssued;
    final lOther$transfersIssued = other.transfersIssued;
    if (_$data.containsKey('transfersIssued') !=
        other._$data.containsKey('transfersIssued')) {
      return false;
    }
    if (l$transfersIssued != lOther$transfersIssued) {
      return false;
    }
    final l$transfersIssuedAggregate = transfersIssuedAggregate;
    final lOther$transfersIssuedAggregate = other.transfersIssuedAggregate;
    if (_$data.containsKey('transfersIssuedAggregate') !=
        other._$data.containsKey('transfersIssuedAggregate')) {
      return false;
    }
    if (l$transfersIssuedAggregate != lOther$transfersIssuedAggregate) {
      return false;
    }
    final l$transfersReceived = transfersReceived;
    final lOther$transfersReceived = other.transfersReceived;
    if (_$data.containsKey('transfersReceived') !=
        other._$data.containsKey('transfersReceived')) {
      return false;
    }
    if (l$transfersReceived != lOther$transfersReceived) {
      return false;
    }
    final l$transfersReceivedAggregate = transfersReceivedAggregate;
    final lOther$transfersReceivedAggregate = other.transfersReceivedAggregate;
    if (_$data.containsKey('transfersReceivedAggregate') !=
        other._$data.containsKey('transfersReceivedAggregate')) {
      return false;
    }
    if (l$transfersReceivedAggregate != lOther$transfersReceivedAggregate) {
      return false;
    }
    final l$wasIdentity = wasIdentity;
    final lOther$wasIdentity = other.wasIdentity;
    if (_$data.containsKey('wasIdentity') !=
        other._$data.containsKey('wasIdentity')) {
      return false;
    }
    if (l$wasIdentity != lOther$wasIdentity) {
      return false;
    }
    final l$wasIdentityAggregate = wasIdentityAggregate;
    final lOther$wasIdentityAggregate = other.wasIdentityAggregate;
    if (_$data.containsKey('wasIdentityAggregate') !=
        other._$data.containsKey('wasIdentityAggregate')) {
      return false;
    }
    if (l$wasIdentityAggregate != lOther$wasIdentityAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$id = id;
    final l$identity = identity;
    final l$linkedIdentity = linkedIdentity;
    final l$linkedIdentityId = linkedIdentityId;
    final l$transfersIssued = transfersIssued;
    final l$transfersIssuedAggregate = transfersIssuedAggregate;
    final l$transfersReceived = transfersReceived;
    final l$transfersReceivedAggregate = transfersReceivedAggregate;
    final l$wasIdentity = wasIdentity;
    final l$wasIdentityAggregate = wasIdentityAggregate;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('linkedIdentity') ? l$linkedIdentity : const {},
      _$data.containsKey('linkedIdentityId') ? l$linkedIdentityId : const {},
      _$data.containsKey('transfersIssued') ? l$transfersIssued : const {},
      _$data.containsKey('transfersIssuedAggregate')
          ? l$transfersIssuedAggregate
          : const {},
      _$data.containsKey('transfersReceived') ? l$transfersReceived : const {},
      _$data.containsKey('transfersReceivedAggregate')
          ? l$transfersReceivedAggregate
          : const {},
      _$data.containsKey('wasIdentity') ? l$wasIdentity : const {},
      _$data.containsKey('wasIdentityAggregate')
          ? l$wasIdentityAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountBoolExp<TRes> {
  factory CopyWith$Input$AccountBoolExp(
    Input$AccountBoolExp instance,
    TRes Function(Input$AccountBoolExp) then,
  ) = _CopyWithImpl$Input$AccountBoolExp;

  factory CopyWith$Input$AccountBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountBoolExp;

  TRes call({
    List<Input$AccountBoolExp>? $_and,
    Input$AccountBoolExp? $_not,
    List<Input$AccountBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$IdentityBoolExp? linkedIdentity,
    Input$StringComparisonExp? linkedIdentityId,
    Input$TransferBoolExp? transfersIssued,
    Input$TransferAggregateBoolExp? transfersIssuedAggregate,
    Input$TransferBoolExp? transfersReceived,
    Input$TransferAggregateBoolExp? transfersReceivedAggregate,
    Input$ChangeOwnerKeyBoolExp? wasIdentity,
    Input$ChangeOwnerKeyAggregateBoolExp? wasIdentityAggregate,
  });
  TRes $_and(
      Iterable<Input$AccountBoolExp>? Function(
              Iterable<CopyWith$Input$AccountBoolExp<Input$AccountBoolExp>>?)
          _fn);
  CopyWith$Input$AccountBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$AccountBoolExp>? Function(
              Iterable<CopyWith$Input$AccountBoolExp<Input$AccountBoolExp>>?)
          _fn);
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IdentityBoolExp<TRes> get identity;
  CopyWith$Input$IdentityBoolExp<TRes> get linkedIdentity;
  CopyWith$Input$StringComparisonExp<TRes> get linkedIdentityId;
  CopyWith$Input$TransferBoolExp<TRes> get transfersIssued;
  CopyWith$Input$TransferAggregateBoolExp<TRes> get transfersIssuedAggregate;
  CopyWith$Input$TransferBoolExp<TRes> get transfersReceived;
  CopyWith$Input$TransferAggregateBoolExp<TRes> get transfersReceivedAggregate;
  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get wasIdentity;
  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes> get wasIdentityAggregate;
}

class _CopyWithImpl$Input$AccountBoolExp<TRes>
    implements CopyWith$Input$AccountBoolExp<TRes> {
  _CopyWithImpl$Input$AccountBoolExp(
    this._instance,
    this._then,
  );

  final Input$AccountBoolExp _instance;

  final TRes Function(Input$AccountBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? linkedIdentity = _undefined,
    Object? linkedIdentityId = _undefined,
    Object? transfersIssued = _undefined,
    Object? transfersIssuedAggregate = _undefined,
    Object? transfersReceived = _undefined,
    Object? transfersReceivedAggregate = _undefined,
    Object? wasIdentity = _undefined,
    Object? wasIdentityAggregate = _undefined,
  }) =>
      _then(Input$AccountBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<Input$AccountBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$AccountBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$AccountBoolExp>?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityBoolExp?),
        if (linkedIdentity != _undefined)
          'linkedIdentity': (linkedIdentity as Input$IdentityBoolExp?),
        if (linkedIdentityId != _undefined)
          'linkedIdentityId': (linkedIdentityId as Input$StringComparisonExp?),
        if (transfersIssued != _undefined)
          'transfersIssued': (transfersIssued as Input$TransferBoolExp?),
        if (transfersIssuedAggregate != _undefined)
          'transfersIssuedAggregate':
              (transfersIssuedAggregate as Input$TransferAggregateBoolExp?),
        if (transfersReceived != _undefined)
          'transfersReceived': (transfersReceived as Input$TransferBoolExp?),
        if (transfersReceivedAggregate != _undefined)
          'transfersReceivedAggregate':
              (transfersReceivedAggregate as Input$TransferAggregateBoolExp?),
        if (wasIdentity != _undefined)
          'wasIdentity': (wasIdentity as Input$ChangeOwnerKeyBoolExp?),
        if (wasIdentityAggregate != _undefined)
          'wasIdentityAggregate':
              (wasIdentityAggregate as Input$ChangeOwnerKeyAggregateBoolExp?),
      }));

  TRes $_and(
          Iterable<Input$AccountBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$AccountBoolExp<Input$AccountBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$AccountBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AccountBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$AccountBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$AccountBoolExp<Input$AccountBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$AccountBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get linkedIdentity {
    final local$linkedIdentity = _instance.linkedIdentity;
    return local$linkedIdentity == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$linkedIdentity, (e) => call(linkedIdentity: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get linkedIdentityId {
    final local$linkedIdentityId = _instance.linkedIdentityId;
    return local$linkedIdentityId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$linkedIdentityId, (e) => call(linkedIdentityId: e));
  }

  CopyWith$Input$TransferBoolExp<TRes> get transfersIssued {
    final local$transfersIssued = _instance.transfersIssued;
    return local$transfersIssued == null
        ? CopyWith$Input$TransferBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferBoolExp(
            local$transfersIssued, (e) => call(transfersIssued: e));
  }

  CopyWith$Input$TransferAggregateBoolExp<TRes> get transfersIssuedAggregate {
    final local$transfersIssuedAggregate = _instance.transfersIssuedAggregate;
    return local$transfersIssuedAggregate == null
        ? CopyWith$Input$TransferAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferAggregateBoolExp(
            local$transfersIssuedAggregate,
            (e) => call(transfersIssuedAggregate: e));
  }

  CopyWith$Input$TransferBoolExp<TRes> get transfersReceived {
    final local$transfersReceived = _instance.transfersReceived;
    return local$transfersReceived == null
        ? CopyWith$Input$TransferBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferBoolExp(
            local$transfersReceived, (e) => call(transfersReceived: e));
  }

  CopyWith$Input$TransferAggregateBoolExp<TRes> get transfersReceivedAggregate {
    final local$transfersReceivedAggregate =
        _instance.transfersReceivedAggregate;
    return local$transfersReceivedAggregate == null
        ? CopyWith$Input$TransferAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferAggregateBoolExp(
            local$transfersReceivedAggregate,
            (e) => call(transfersReceivedAggregate: e));
  }

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get wasIdentity {
    final local$wasIdentity = _instance.wasIdentity;
    return local$wasIdentity == null
        ? CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyBoolExp(
            local$wasIdentity, (e) => call(wasIdentity: e));
  }

  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes> get wasIdentityAggregate {
    final local$wasIdentityAggregate = _instance.wasIdentityAggregate;
    return local$wasIdentityAggregate == null
        ? CopyWith$Input$ChangeOwnerKeyAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyAggregateBoolExp(
            local$wasIdentityAggregate, (e) => call(wasIdentityAggregate: e));
  }
}

class _CopyWithStubImpl$Input$AccountBoolExp<TRes>
    implements CopyWith$Input$AccountBoolExp<TRes> {
  _CopyWithStubImpl$Input$AccountBoolExp(this._res);

  TRes _res;

  call({
    List<Input$AccountBoolExp>? $_and,
    Input$AccountBoolExp? $_not,
    List<Input$AccountBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$IdentityBoolExp? linkedIdentity,
    Input$StringComparisonExp? linkedIdentityId,
    Input$TransferBoolExp? transfersIssued,
    Input$TransferAggregateBoolExp? transfersIssuedAggregate,
    Input$TransferBoolExp? transfersReceived,
    Input$TransferAggregateBoolExp? transfersReceivedAggregate,
    Input$ChangeOwnerKeyBoolExp? wasIdentity,
    Input$ChangeOwnerKeyAggregateBoolExp? wasIdentityAggregate,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$AccountBoolExp<TRes> get $_not =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get identity =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get linkedIdentity =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get linkedIdentityId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$TransferBoolExp<TRes> get transfersIssued =>
      CopyWith$Input$TransferBoolExp.stub(_res);

  CopyWith$Input$TransferAggregateBoolExp<TRes> get transfersIssuedAggregate =>
      CopyWith$Input$TransferAggregateBoolExp.stub(_res);

  CopyWith$Input$TransferBoolExp<TRes> get transfersReceived =>
      CopyWith$Input$TransferBoolExp.stub(_res);

  CopyWith$Input$TransferAggregateBoolExp<TRes>
      get transfersReceivedAggregate =>
          CopyWith$Input$TransferAggregateBoolExp.stub(_res);

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get wasIdentity =>
      CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_res);

  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
      get wasIdentityAggregate =>
          CopyWith$Input$ChangeOwnerKeyAggregateBoolExp.stub(_res);
}

class Input$AccountMaxOrderBy {
  factory Input$AccountMaxOrderBy({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  }) =>
      Input$AccountMaxOrderBy._({
        if (id != null) r'id': id,
        if (linkedIdentityId != null) r'linkedIdentityId': linkedIdentityId,
      });

  Input$AccountMaxOrderBy._(this._$data);

  factory Input$AccountMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = data['linkedIdentityId'];
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : fromJson$Enum$OrderBy((l$linkedIdentityId as String));
    }
    return Input$AccountMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get linkedIdentityId =>
      (_$data['linkedIdentityId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = linkedIdentityId;
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : toJson$Enum$OrderBy(l$linkedIdentityId);
    }
    return result$data;
  }

  CopyWith$Input$AccountMaxOrderBy<Input$AccountMaxOrderBy> get copyWith =>
      CopyWith$Input$AccountMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$linkedIdentityId = linkedIdentityId;
    final lOther$linkedIdentityId = other.linkedIdentityId;
    if (_$data.containsKey('linkedIdentityId') !=
        other._$data.containsKey('linkedIdentityId')) {
      return false;
    }
    if (l$linkedIdentityId != lOther$linkedIdentityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$linkedIdentityId = linkedIdentityId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('linkedIdentityId') ? l$linkedIdentityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountMaxOrderBy<TRes> {
  factory CopyWith$Input$AccountMaxOrderBy(
    Input$AccountMaxOrderBy instance,
    TRes Function(Input$AccountMaxOrderBy) then,
  ) = _CopyWithImpl$Input$AccountMaxOrderBy;

  factory CopyWith$Input$AccountMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountMaxOrderBy;

  TRes call({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  });
}

class _CopyWithImpl$Input$AccountMaxOrderBy<TRes>
    implements CopyWith$Input$AccountMaxOrderBy<TRes> {
  _CopyWithImpl$Input$AccountMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$AccountMaxOrderBy _instance;

  final TRes Function(Input$AccountMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? linkedIdentityId = _undefined,
  }) =>
      _then(Input$AccountMaxOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (linkedIdentityId != _undefined)
          'linkedIdentityId': (linkedIdentityId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$AccountMaxOrderBy<TRes>
    implements CopyWith$Input$AccountMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$AccountMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  }) =>
      _res;
}

class Input$AccountMinOrderBy {
  factory Input$AccountMinOrderBy({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  }) =>
      Input$AccountMinOrderBy._({
        if (id != null) r'id': id,
        if (linkedIdentityId != null) r'linkedIdentityId': linkedIdentityId,
      });

  Input$AccountMinOrderBy._(this._$data);

  factory Input$AccountMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = data['linkedIdentityId'];
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : fromJson$Enum$OrderBy((l$linkedIdentityId as String));
    }
    return Input$AccountMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get linkedIdentityId =>
      (_$data['linkedIdentityId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = linkedIdentityId;
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : toJson$Enum$OrderBy(l$linkedIdentityId);
    }
    return result$data;
  }

  CopyWith$Input$AccountMinOrderBy<Input$AccountMinOrderBy> get copyWith =>
      CopyWith$Input$AccountMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$linkedIdentityId = linkedIdentityId;
    final lOther$linkedIdentityId = other.linkedIdentityId;
    if (_$data.containsKey('linkedIdentityId') !=
        other._$data.containsKey('linkedIdentityId')) {
      return false;
    }
    if (l$linkedIdentityId != lOther$linkedIdentityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$linkedIdentityId = linkedIdentityId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('linkedIdentityId') ? l$linkedIdentityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountMinOrderBy<TRes> {
  factory CopyWith$Input$AccountMinOrderBy(
    Input$AccountMinOrderBy instance,
    TRes Function(Input$AccountMinOrderBy) then,
  ) = _CopyWithImpl$Input$AccountMinOrderBy;

  factory CopyWith$Input$AccountMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountMinOrderBy;

  TRes call({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  });
}

class _CopyWithImpl$Input$AccountMinOrderBy<TRes>
    implements CopyWith$Input$AccountMinOrderBy<TRes> {
  _CopyWithImpl$Input$AccountMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$AccountMinOrderBy _instance;

  final TRes Function(Input$AccountMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? linkedIdentityId = _undefined,
  }) =>
      _then(Input$AccountMinOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (linkedIdentityId != _undefined)
          'linkedIdentityId': (linkedIdentityId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$AccountMinOrderBy<TRes>
    implements CopyWith$Input$AccountMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$AccountMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? id,
    Enum$OrderBy? linkedIdentityId,
  }) =>
      _res;
}

class Input$AccountOrderBy {
  factory Input$AccountOrderBy({
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Input$IdentityOrderBy? linkedIdentity,
    Enum$OrderBy? linkedIdentityId,
    Input$TransferAggregateOrderBy? transfersIssuedAggregate,
    Input$TransferAggregateOrderBy? transfersReceivedAggregate,
    Input$ChangeOwnerKeyAggregateOrderBy? wasIdentityAggregate,
  }) =>
      Input$AccountOrderBy._({
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (linkedIdentity != null) r'linkedIdentity': linkedIdentity,
        if (linkedIdentityId != null) r'linkedIdentityId': linkedIdentityId,
        if (transfersIssuedAggregate != null)
          r'transfersIssuedAggregate': transfersIssuedAggregate,
        if (transfersReceivedAggregate != null)
          r'transfersReceivedAggregate': transfersReceivedAggregate,
        if (wasIdentityAggregate != null)
          r'wasIdentityAggregate': wasIdentityAggregate,
      });

  Input$AccountOrderBy._(this._$data);

  factory Input$AccountOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('linkedIdentity')) {
      final l$linkedIdentity = data['linkedIdentity'];
      result$data['linkedIdentity'] = l$linkedIdentity == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$linkedIdentity as Map<String, dynamic>));
    }
    if (data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = data['linkedIdentityId'];
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : fromJson$Enum$OrderBy((l$linkedIdentityId as String));
    }
    if (data.containsKey('transfersIssuedAggregate')) {
      final l$transfersIssuedAggregate = data['transfersIssuedAggregate'];
      result$data['transfersIssuedAggregate'] =
          l$transfersIssuedAggregate == null
              ? null
              : Input$TransferAggregateOrderBy.fromJson(
                  (l$transfersIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('transfersReceivedAggregate')) {
      final l$transfersReceivedAggregate = data['transfersReceivedAggregate'];
      result$data['transfersReceivedAggregate'] =
          l$transfersReceivedAggregate == null
              ? null
              : Input$TransferAggregateOrderBy.fromJson(
                  (l$transfersReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('wasIdentityAggregate')) {
      final l$wasIdentityAggregate = data['wasIdentityAggregate'];
      result$data['wasIdentityAggregate'] = l$wasIdentityAggregate == null
          ? null
          : Input$ChangeOwnerKeyAggregateOrderBy.fromJson(
              (l$wasIdentityAggregate as Map<String, dynamic>));
    }
    return Input$AccountOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get identity =>
      (_$data['identity'] as Input$IdentityOrderBy?);

  Input$IdentityOrderBy? get linkedIdentity =>
      (_$data['linkedIdentity'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get linkedIdentityId =>
      (_$data['linkedIdentityId'] as Enum$OrderBy?);

  Input$TransferAggregateOrderBy? get transfersIssuedAggregate =>
      (_$data['transfersIssuedAggregate'] as Input$TransferAggregateOrderBy?);

  Input$TransferAggregateOrderBy? get transfersReceivedAggregate =>
      (_$data['transfersReceivedAggregate'] as Input$TransferAggregateOrderBy?);

  Input$ChangeOwnerKeyAggregateOrderBy? get wasIdentityAggregate =>
      (_$data['wasIdentityAggregate'] as Input$ChangeOwnerKeyAggregateOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('linkedIdentity')) {
      final l$linkedIdentity = linkedIdentity;
      result$data['linkedIdentity'] = l$linkedIdentity?.toJson();
    }
    if (_$data.containsKey('linkedIdentityId')) {
      final l$linkedIdentityId = linkedIdentityId;
      result$data['linkedIdentityId'] = l$linkedIdentityId == null
          ? null
          : toJson$Enum$OrderBy(l$linkedIdentityId);
    }
    if (_$data.containsKey('transfersIssuedAggregate')) {
      final l$transfersIssuedAggregate = transfersIssuedAggregate;
      result$data['transfersIssuedAggregate'] =
          l$transfersIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('transfersReceivedAggregate')) {
      final l$transfersReceivedAggregate = transfersReceivedAggregate;
      result$data['transfersReceivedAggregate'] =
          l$transfersReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('wasIdentityAggregate')) {
      final l$wasIdentityAggregate = wasIdentityAggregate;
      result$data['wasIdentityAggregate'] = l$wasIdentityAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AccountOrderBy<Input$AccountOrderBy> get copyWith =>
      CopyWith$Input$AccountOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$linkedIdentity = linkedIdentity;
    final lOther$linkedIdentity = other.linkedIdentity;
    if (_$data.containsKey('linkedIdentity') !=
        other._$data.containsKey('linkedIdentity')) {
      return false;
    }
    if (l$linkedIdentity != lOther$linkedIdentity) {
      return false;
    }
    final l$linkedIdentityId = linkedIdentityId;
    final lOther$linkedIdentityId = other.linkedIdentityId;
    if (_$data.containsKey('linkedIdentityId') !=
        other._$data.containsKey('linkedIdentityId')) {
      return false;
    }
    if (l$linkedIdentityId != lOther$linkedIdentityId) {
      return false;
    }
    final l$transfersIssuedAggregate = transfersIssuedAggregate;
    final lOther$transfersIssuedAggregate = other.transfersIssuedAggregate;
    if (_$data.containsKey('transfersIssuedAggregate') !=
        other._$data.containsKey('transfersIssuedAggregate')) {
      return false;
    }
    if (l$transfersIssuedAggregate != lOther$transfersIssuedAggregate) {
      return false;
    }
    final l$transfersReceivedAggregate = transfersReceivedAggregate;
    final lOther$transfersReceivedAggregate = other.transfersReceivedAggregate;
    if (_$data.containsKey('transfersReceivedAggregate') !=
        other._$data.containsKey('transfersReceivedAggregate')) {
      return false;
    }
    if (l$transfersReceivedAggregate != lOther$transfersReceivedAggregate) {
      return false;
    }
    final l$wasIdentityAggregate = wasIdentityAggregate;
    final lOther$wasIdentityAggregate = other.wasIdentityAggregate;
    if (_$data.containsKey('wasIdentityAggregate') !=
        other._$data.containsKey('wasIdentityAggregate')) {
      return false;
    }
    if (l$wasIdentityAggregate != lOther$wasIdentityAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$identity = identity;
    final l$linkedIdentity = linkedIdentity;
    final l$linkedIdentityId = linkedIdentityId;
    final l$transfersIssuedAggregate = transfersIssuedAggregate;
    final l$transfersReceivedAggregate = transfersReceivedAggregate;
    final l$wasIdentityAggregate = wasIdentityAggregate;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('linkedIdentity') ? l$linkedIdentity : const {},
      _$data.containsKey('linkedIdentityId') ? l$linkedIdentityId : const {},
      _$data.containsKey('transfersIssuedAggregate')
          ? l$transfersIssuedAggregate
          : const {},
      _$data.containsKey('transfersReceivedAggregate')
          ? l$transfersReceivedAggregate
          : const {},
      _$data.containsKey('wasIdentityAggregate')
          ? l$wasIdentityAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountOrderBy<TRes> {
  factory CopyWith$Input$AccountOrderBy(
    Input$AccountOrderBy instance,
    TRes Function(Input$AccountOrderBy) then,
  ) = _CopyWithImpl$Input$AccountOrderBy;

  factory CopyWith$Input$AccountOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountOrderBy;

  TRes call({
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Input$IdentityOrderBy? linkedIdentity,
    Enum$OrderBy? linkedIdentityId,
    Input$TransferAggregateOrderBy? transfersIssuedAggregate,
    Input$TransferAggregateOrderBy? transfersReceivedAggregate,
    Input$ChangeOwnerKeyAggregateOrderBy? wasIdentityAggregate,
  });
  CopyWith$Input$IdentityOrderBy<TRes> get identity;
  CopyWith$Input$IdentityOrderBy<TRes> get linkedIdentity;
  CopyWith$Input$TransferAggregateOrderBy<TRes> get transfersIssuedAggregate;
  CopyWith$Input$TransferAggregateOrderBy<TRes> get transfersReceivedAggregate;
  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes> get wasIdentityAggregate;
}

class _CopyWithImpl$Input$AccountOrderBy<TRes>
    implements CopyWith$Input$AccountOrderBy<TRes> {
  _CopyWithImpl$Input$AccountOrderBy(
    this._instance,
    this._then,
  );

  final Input$AccountOrderBy _instance;

  final TRes Function(Input$AccountOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? linkedIdentity = _undefined,
    Object? linkedIdentityId = _undefined,
    Object? transfersIssuedAggregate = _undefined,
    Object? transfersReceivedAggregate = _undefined,
    Object? wasIdentityAggregate = _undefined,
  }) =>
      _then(Input$AccountOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityOrderBy?),
        if (linkedIdentity != _undefined)
          'linkedIdentity': (linkedIdentity as Input$IdentityOrderBy?),
        if (linkedIdentityId != _undefined)
          'linkedIdentityId': (linkedIdentityId as Enum$OrderBy?),
        if (transfersIssuedAggregate != _undefined)
          'transfersIssuedAggregate':
              (transfersIssuedAggregate as Input$TransferAggregateOrderBy?),
        if (transfersReceivedAggregate != _undefined)
          'transfersReceivedAggregate':
              (transfersReceivedAggregate as Input$TransferAggregateOrderBy?),
        if (wasIdentityAggregate != _undefined)
          'wasIdentityAggregate':
              (wasIdentityAggregate as Input$ChangeOwnerKeyAggregateOrderBy?),
      }));

  CopyWith$Input$IdentityOrderBy<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$IdentityOrderBy<TRes> get linkedIdentity {
    final local$linkedIdentity = _instance.linkedIdentity;
    return local$linkedIdentity == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$linkedIdentity, (e) => call(linkedIdentity: e));
  }

  CopyWith$Input$TransferAggregateOrderBy<TRes> get transfersIssuedAggregate {
    final local$transfersIssuedAggregate = _instance.transfersIssuedAggregate;
    return local$transfersIssuedAggregate == null
        ? CopyWith$Input$TransferAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferAggregateOrderBy(
            local$transfersIssuedAggregate,
            (e) => call(transfersIssuedAggregate: e));
  }

  CopyWith$Input$TransferAggregateOrderBy<TRes> get transfersReceivedAggregate {
    final local$transfersReceivedAggregate =
        _instance.transfersReceivedAggregate;
    return local$transfersReceivedAggregate == null
        ? CopyWith$Input$TransferAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferAggregateOrderBy(
            local$transfersReceivedAggregate,
            (e) => call(transfersReceivedAggregate: e));
  }

  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes> get wasIdentityAggregate {
    final local$wasIdentityAggregate = _instance.wasIdentityAggregate;
    return local$wasIdentityAggregate == null
        ? CopyWith$Input$ChangeOwnerKeyAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyAggregateOrderBy(
            local$wasIdentityAggregate, (e) => call(wasIdentityAggregate: e));
  }
}

class _CopyWithStubImpl$Input$AccountOrderBy<TRes>
    implements CopyWith$Input$AccountOrderBy<TRes> {
  _CopyWithStubImpl$Input$AccountOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Input$IdentityOrderBy? linkedIdentity,
    Enum$OrderBy? linkedIdentityId,
    Input$TransferAggregateOrderBy? transfersIssuedAggregate,
    Input$TransferAggregateOrderBy? transfersReceivedAggregate,
    Input$ChangeOwnerKeyAggregateOrderBy? wasIdentityAggregate,
  }) =>
      _res;

  CopyWith$Input$IdentityOrderBy<TRes> get identity =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$IdentityOrderBy<TRes> get linkedIdentity =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$TransferAggregateOrderBy<TRes> get transfersIssuedAggregate =>
      CopyWith$Input$TransferAggregateOrderBy.stub(_res);

  CopyWith$Input$TransferAggregateOrderBy<TRes>
      get transfersReceivedAggregate =>
          CopyWith$Input$TransferAggregateOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
      get wasIdentityAggregate =>
          CopyWith$Input$ChangeOwnerKeyAggregateOrderBy.stub(_res);
}

class Input$BlockBoolExp {
  factory Input$BlockBoolExp({
    List<Input$BlockBoolExp>? $_and,
    Input$BlockBoolExp? $_not,
    List<Input$BlockBoolExp>? $_or,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$IntComparisonExp? callsCount,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$IntComparisonExp? eventsCount,
    Input$ExtrinsicBoolExp? extrinsics,
    Input$ExtrinsicAggregateBoolExp? extrinsicsAggregate,
    Input$IntComparisonExp? extrinsicsCount,
    Input$ByteaComparisonExp? extrinsicsicRoot,
    Input$ByteaComparisonExp? hash,
    Input$IntComparisonExp? height,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? implName,
    Input$IntComparisonExp? implVersion,
    Input$ByteaComparisonExp? parentHash,
    Input$StringComparisonExp? specName,
    Input$IntComparisonExp? specVersion,
    Input$ByteaComparisonExp? stateRoot,
    Input$TimestamptzComparisonExp? timestamp,
    Input$ByteaComparisonExp? validator,
  }) =>
      Input$BlockBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (calls != null) r'calls': calls,
        if (callsAggregate != null) r'callsAggregate': callsAggregate,
        if (callsCount != null) r'callsCount': callsCount,
        if (events != null) r'events': events,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (eventsCount != null) r'eventsCount': eventsCount,
        if (extrinsics != null) r'extrinsics': extrinsics,
        if (extrinsicsAggregate != null)
          r'extrinsicsAggregate': extrinsicsAggregate,
        if (extrinsicsCount != null) r'extrinsicsCount': extrinsicsCount,
        if (extrinsicsicRoot != null) r'extrinsicsicRoot': extrinsicsicRoot,
        if (hash != null) r'hash': hash,
        if (height != null) r'height': height,
        if (id != null) r'id': id,
        if (implName != null) r'implName': implName,
        if (implVersion != null) r'implVersion': implVersion,
        if (parentHash != null) r'parentHash': parentHash,
        if (specName != null) r'specName': specName,
        if (specVersion != null) r'specVersion': specVersion,
        if (stateRoot != null) r'stateRoot': stateRoot,
        if (timestamp != null) r'timestamp': timestamp,
        if (validator != null) r'validator': validator,
      });

  Input$BlockBoolExp._(this._$data);

  factory Input$BlockBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$BlockBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$BlockBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$BlockBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('calls')) {
      final l$calls = data['calls'];
      result$data['calls'] = l$calls == null
          ? null
          : Input$CallBoolExp.fromJson((l$calls as Map<String, dynamic>));
    }
    if (data.containsKey('callsAggregate')) {
      final l$callsAggregate = data['callsAggregate'];
      result$data['callsAggregate'] = l$callsAggregate == null
          ? null
          : Input$CallAggregateBoolExp.fromJson(
              (l$callsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('callsCount')) {
      final l$callsCount = data['callsCount'];
      result$data['callsCount'] = l$callsCount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$callsCount as Map<String, dynamic>));
    }
    if (data.containsKey('events')) {
      final l$events = data['events'];
      result$data['events'] = l$events == null
          ? null
          : Input$EventBoolExp.fromJson((l$events as Map<String, dynamic>));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateBoolExp.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('eventsCount')) {
      final l$eventsCount = data['eventsCount'];
      result$data['eventsCount'] = l$eventsCount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$eventsCount as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsics')) {
      final l$extrinsics = data['extrinsics'];
      result$data['extrinsics'] = l$extrinsics == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson(
              (l$extrinsics as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicsAggregate')) {
      final l$extrinsicsAggregate = data['extrinsicsAggregate'];
      result$data['extrinsicsAggregate'] = l$extrinsicsAggregate == null
          ? null
          : Input$ExtrinsicAggregateBoolExp.fromJson(
              (l$extrinsicsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicsCount')) {
      final l$extrinsicsCount = data['extrinsicsCount'];
      result$data['extrinsicsCount'] = l$extrinsicsCount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$extrinsicsCount as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicsicRoot')) {
      final l$extrinsicsicRoot = data['extrinsicsicRoot'];
      result$data['extrinsicsicRoot'] = l$extrinsicsicRoot == null
          ? null
          : Input$ByteaComparisonExp.fromJson(
              (l$extrinsicsicRoot as Map<String, dynamic>));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = l$hash == null
          ? null
          : Input$ByteaComparisonExp.fromJson((l$hash as Map<String, dynamic>));
    }
    if (data.containsKey('height')) {
      final l$height = data['height'];
      result$data['height'] = l$height == null
          ? null
          : Input$IntComparisonExp.fromJson((l$height as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('implName')) {
      final l$implName = data['implName'];
      result$data['implName'] = l$implName == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$implName as Map<String, dynamic>));
    }
    if (data.containsKey('implVersion')) {
      final l$implVersion = data['implVersion'];
      result$data['implVersion'] = l$implVersion == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$implVersion as Map<String, dynamic>));
    }
    if (data.containsKey('parentHash')) {
      final l$parentHash = data['parentHash'];
      result$data['parentHash'] = l$parentHash == null
          ? null
          : Input$ByteaComparisonExp.fromJson(
              (l$parentHash as Map<String, dynamic>));
    }
    if (data.containsKey('specName')) {
      final l$specName = data['specName'];
      result$data['specName'] = l$specName == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$specName as Map<String, dynamic>));
    }
    if (data.containsKey('specVersion')) {
      final l$specVersion = data['specVersion'];
      result$data['specVersion'] = l$specVersion == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$specVersion as Map<String, dynamic>));
    }
    if (data.containsKey('stateRoot')) {
      final l$stateRoot = data['stateRoot'];
      result$data['stateRoot'] = l$stateRoot == null
          ? null
          : Input$ByteaComparisonExp.fromJson(
              (l$stateRoot as Map<String, dynamic>));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : Input$TimestamptzComparisonExp.fromJson(
              (l$timestamp as Map<String, dynamic>));
    }
    if (data.containsKey('validator')) {
      final l$validator = data['validator'];
      result$data['validator'] = l$validator == null
          ? null
          : Input$ByteaComparisonExp.fromJson(
              (l$validator as Map<String, dynamic>));
    }
    return Input$BlockBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BlockBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$BlockBoolExp>?);

  Input$BlockBoolExp? get $_not => (_$data['_not'] as Input$BlockBoolExp?);

  List<Input$BlockBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$BlockBoolExp>?);

  Input$CallBoolExp? get calls => (_$data['calls'] as Input$CallBoolExp?);

  Input$CallAggregateBoolExp? get callsAggregate =>
      (_$data['callsAggregate'] as Input$CallAggregateBoolExp?);

  Input$IntComparisonExp? get callsCount =>
      (_$data['callsCount'] as Input$IntComparisonExp?);

  Input$EventBoolExp? get events => (_$data['events'] as Input$EventBoolExp?);

  Input$EventAggregateBoolExp? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateBoolExp?);

  Input$IntComparisonExp? get eventsCount =>
      (_$data['eventsCount'] as Input$IntComparisonExp?);

  Input$ExtrinsicBoolExp? get extrinsics =>
      (_$data['extrinsics'] as Input$ExtrinsicBoolExp?);

  Input$ExtrinsicAggregateBoolExp? get extrinsicsAggregate =>
      (_$data['extrinsicsAggregate'] as Input$ExtrinsicAggregateBoolExp?);

  Input$IntComparisonExp? get extrinsicsCount =>
      (_$data['extrinsicsCount'] as Input$IntComparisonExp?);

  Input$ByteaComparisonExp? get extrinsicsicRoot =>
      (_$data['extrinsicsicRoot'] as Input$ByteaComparisonExp?);

  Input$ByteaComparisonExp? get hash =>
      (_$data['hash'] as Input$ByteaComparisonExp?);

  Input$IntComparisonExp? get height =>
      (_$data['height'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get implName =>
      (_$data['implName'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get implVersion =>
      (_$data['implVersion'] as Input$IntComparisonExp?);

  Input$ByteaComparisonExp? get parentHash =>
      (_$data['parentHash'] as Input$ByteaComparisonExp?);

  Input$StringComparisonExp? get specName =>
      (_$data['specName'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get specVersion =>
      (_$data['specVersion'] as Input$IntComparisonExp?);

  Input$ByteaComparisonExp? get stateRoot =>
      (_$data['stateRoot'] as Input$ByteaComparisonExp?);

  Input$TimestamptzComparisonExp? get timestamp =>
      (_$data['timestamp'] as Input$TimestamptzComparisonExp?);

  Input$ByteaComparisonExp? get validator =>
      (_$data['validator'] as Input$ByteaComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('calls')) {
      final l$calls = calls;
      result$data['calls'] = l$calls?.toJson();
    }
    if (_$data.containsKey('callsAggregate')) {
      final l$callsAggregate = callsAggregate;
      result$data['callsAggregate'] = l$callsAggregate?.toJson();
    }
    if (_$data.containsKey('callsCount')) {
      final l$callsCount = callsCount;
      result$data['callsCount'] = l$callsCount?.toJson();
    }
    if (_$data.containsKey('events')) {
      final l$events = events;
      result$data['events'] = l$events?.toJson();
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('eventsCount')) {
      final l$eventsCount = eventsCount;
      result$data['eventsCount'] = l$eventsCount?.toJson();
    }
    if (_$data.containsKey('extrinsics')) {
      final l$extrinsics = extrinsics;
      result$data['extrinsics'] = l$extrinsics?.toJson();
    }
    if (_$data.containsKey('extrinsicsAggregate')) {
      final l$extrinsicsAggregate = extrinsicsAggregate;
      result$data['extrinsicsAggregate'] = l$extrinsicsAggregate?.toJson();
    }
    if (_$data.containsKey('extrinsicsCount')) {
      final l$extrinsicsCount = extrinsicsCount;
      result$data['extrinsicsCount'] = l$extrinsicsCount?.toJson();
    }
    if (_$data.containsKey('extrinsicsicRoot')) {
      final l$extrinsicsicRoot = extrinsicsicRoot;
      result$data['extrinsicsicRoot'] = l$extrinsicsicRoot?.toJson();
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash?.toJson();
    }
    if (_$data.containsKey('height')) {
      final l$height = height;
      result$data['height'] = l$height?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('implName')) {
      final l$implName = implName;
      result$data['implName'] = l$implName?.toJson();
    }
    if (_$data.containsKey('implVersion')) {
      final l$implVersion = implVersion;
      result$data['implVersion'] = l$implVersion?.toJson();
    }
    if (_$data.containsKey('parentHash')) {
      final l$parentHash = parentHash;
      result$data['parentHash'] = l$parentHash?.toJson();
    }
    if (_$data.containsKey('specName')) {
      final l$specName = specName;
      result$data['specName'] = l$specName?.toJson();
    }
    if (_$data.containsKey('specVersion')) {
      final l$specVersion = specVersion;
      result$data['specVersion'] = l$specVersion?.toJson();
    }
    if (_$data.containsKey('stateRoot')) {
      final l$stateRoot = stateRoot;
      result$data['stateRoot'] = l$stateRoot?.toJson();
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] = l$timestamp?.toJson();
    }
    if (_$data.containsKey('validator')) {
      final l$validator = validator;
      result$data['validator'] = l$validator?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BlockBoolExp<Input$BlockBoolExp> get copyWith =>
      CopyWith$Input$BlockBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$calls = calls;
    final lOther$calls = other.calls;
    if (_$data.containsKey('calls') != other._$data.containsKey('calls')) {
      return false;
    }
    if (l$calls != lOther$calls) {
      return false;
    }
    final l$callsAggregate = callsAggregate;
    final lOther$callsAggregate = other.callsAggregate;
    if (_$data.containsKey('callsAggregate') !=
        other._$data.containsKey('callsAggregate')) {
      return false;
    }
    if (l$callsAggregate != lOther$callsAggregate) {
      return false;
    }
    final l$callsCount = callsCount;
    final lOther$callsCount = other.callsCount;
    if (_$data.containsKey('callsCount') !=
        other._$data.containsKey('callsCount')) {
      return false;
    }
    if (l$callsCount != lOther$callsCount) {
      return false;
    }
    final l$events = events;
    final lOther$events = other.events;
    if (_$data.containsKey('events') != other._$data.containsKey('events')) {
      return false;
    }
    if (l$events != lOther$events) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$eventsCount = eventsCount;
    final lOther$eventsCount = other.eventsCount;
    if (_$data.containsKey('eventsCount') !=
        other._$data.containsKey('eventsCount')) {
      return false;
    }
    if (l$eventsCount != lOther$eventsCount) {
      return false;
    }
    final l$extrinsics = extrinsics;
    final lOther$extrinsics = other.extrinsics;
    if (_$data.containsKey('extrinsics') !=
        other._$data.containsKey('extrinsics')) {
      return false;
    }
    if (l$extrinsics != lOther$extrinsics) {
      return false;
    }
    final l$extrinsicsAggregate = extrinsicsAggregate;
    final lOther$extrinsicsAggregate = other.extrinsicsAggregate;
    if (_$data.containsKey('extrinsicsAggregate') !=
        other._$data.containsKey('extrinsicsAggregate')) {
      return false;
    }
    if (l$extrinsicsAggregate != lOther$extrinsicsAggregate) {
      return false;
    }
    final l$extrinsicsCount = extrinsicsCount;
    final lOther$extrinsicsCount = other.extrinsicsCount;
    if (_$data.containsKey('extrinsicsCount') !=
        other._$data.containsKey('extrinsicsCount')) {
      return false;
    }
    if (l$extrinsicsCount != lOther$extrinsicsCount) {
      return false;
    }
    final l$extrinsicsicRoot = extrinsicsicRoot;
    final lOther$extrinsicsicRoot = other.extrinsicsicRoot;
    if (_$data.containsKey('extrinsicsicRoot') !=
        other._$data.containsKey('extrinsicsicRoot')) {
      return false;
    }
    if (l$extrinsicsicRoot != lOther$extrinsicsicRoot) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$height = height;
    final lOther$height = other.height;
    if (_$data.containsKey('height') != other._$data.containsKey('height')) {
      return false;
    }
    if (l$height != lOther$height) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$implName = implName;
    final lOther$implName = other.implName;
    if (_$data.containsKey('implName') !=
        other._$data.containsKey('implName')) {
      return false;
    }
    if (l$implName != lOther$implName) {
      return false;
    }
    final l$implVersion = implVersion;
    final lOther$implVersion = other.implVersion;
    if (_$data.containsKey('implVersion') !=
        other._$data.containsKey('implVersion')) {
      return false;
    }
    if (l$implVersion != lOther$implVersion) {
      return false;
    }
    final l$parentHash = parentHash;
    final lOther$parentHash = other.parentHash;
    if (_$data.containsKey('parentHash') !=
        other._$data.containsKey('parentHash')) {
      return false;
    }
    if (l$parentHash != lOther$parentHash) {
      return false;
    }
    final l$specName = specName;
    final lOther$specName = other.specName;
    if (_$data.containsKey('specName') !=
        other._$data.containsKey('specName')) {
      return false;
    }
    if (l$specName != lOther$specName) {
      return false;
    }
    final l$specVersion = specVersion;
    final lOther$specVersion = other.specVersion;
    if (_$data.containsKey('specVersion') !=
        other._$data.containsKey('specVersion')) {
      return false;
    }
    if (l$specVersion != lOther$specVersion) {
      return false;
    }
    final l$stateRoot = stateRoot;
    final lOther$stateRoot = other.stateRoot;
    if (_$data.containsKey('stateRoot') !=
        other._$data.containsKey('stateRoot')) {
      return false;
    }
    if (l$stateRoot != lOther$stateRoot) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$validator = validator;
    final lOther$validator = other.validator;
    if (_$data.containsKey('validator') !=
        other._$data.containsKey('validator')) {
      return false;
    }
    if (l$validator != lOther$validator) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$calls = calls;
    final l$callsAggregate = callsAggregate;
    final l$callsCount = callsCount;
    final l$events = events;
    final l$eventsAggregate = eventsAggregate;
    final l$eventsCount = eventsCount;
    final l$extrinsics = extrinsics;
    final l$extrinsicsAggregate = extrinsicsAggregate;
    final l$extrinsicsCount = extrinsicsCount;
    final l$extrinsicsicRoot = extrinsicsicRoot;
    final l$hash = hash;
    final l$height = height;
    final l$id = id;
    final l$implName = implName;
    final l$implVersion = implVersion;
    final l$parentHash = parentHash;
    final l$specName = specName;
    final l$specVersion = specVersion;
    final l$stateRoot = stateRoot;
    final l$timestamp = timestamp;
    final l$validator = validator;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('calls') ? l$calls : const {},
      _$data.containsKey('callsAggregate') ? l$callsAggregate : const {},
      _$data.containsKey('callsCount') ? l$callsCount : const {},
      _$data.containsKey('events') ? l$events : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('eventsCount') ? l$eventsCount : const {},
      _$data.containsKey('extrinsics') ? l$extrinsics : const {},
      _$data.containsKey('extrinsicsAggregate')
          ? l$extrinsicsAggregate
          : const {},
      _$data.containsKey('extrinsicsCount') ? l$extrinsicsCount : const {},
      _$data.containsKey('extrinsicsicRoot') ? l$extrinsicsicRoot : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('height') ? l$height : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('implName') ? l$implName : const {},
      _$data.containsKey('implVersion') ? l$implVersion : const {},
      _$data.containsKey('parentHash') ? l$parentHash : const {},
      _$data.containsKey('specName') ? l$specName : const {},
      _$data.containsKey('specVersion') ? l$specVersion : const {},
      _$data.containsKey('stateRoot') ? l$stateRoot : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('validator') ? l$validator : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockBoolExp<TRes> {
  factory CopyWith$Input$BlockBoolExp(
    Input$BlockBoolExp instance,
    TRes Function(Input$BlockBoolExp) then,
  ) = _CopyWithImpl$Input$BlockBoolExp;

  factory CopyWith$Input$BlockBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockBoolExp;

  TRes call({
    List<Input$BlockBoolExp>? $_and,
    Input$BlockBoolExp? $_not,
    List<Input$BlockBoolExp>? $_or,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$IntComparisonExp? callsCount,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$IntComparisonExp? eventsCount,
    Input$ExtrinsicBoolExp? extrinsics,
    Input$ExtrinsicAggregateBoolExp? extrinsicsAggregate,
    Input$IntComparisonExp? extrinsicsCount,
    Input$ByteaComparisonExp? extrinsicsicRoot,
    Input$ByteaComparisonExp? hash,
    Input$IntComparisonExp? height,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? implName,
    Input$IntComparisonExp? implVersion,
    Input$ByteaComparisonExp? parentHash,
    Input$StringComparisonExp? specName,
    Input$IntComparisonExp? specVersion,
    Input$ByteaComparisonExp? stateRoot,
    Input$TimestamptzComparisonExp? timestamp,
    Input$ByteaComparisonExp? validator,
  });
  TRes $_and(
      Iterable<Input$BlockBoolExp>? Function(
              Iterable<CopyWith$Input$BlockBoolExp<Input$BlockBoolExp>>?)
          _fn);
  CopyWith$Input$BlockBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$BlockBoolExp>? Function(
              Iterable<CopyWith$Input$BlockBoolExp<Input$BlockBoolExp>>?)
          _fn);
  CopyWith$Input$CallBoolExp<TRes> get calls;
  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate;
  CopyWith$Input$IntComparisonExp<TRes> get callsCount;
  CopyWith$Input$EventBoolExp<TRes> get events;
  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate;
  CopyWith$Input$IntComparisonExp<TRes> get eventsCount;
  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsics;
  CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> get extrinsicsAggregate;
  CopyWith$Input$IntComparisonExp<TRes> get extrinsicsCount;
  CopyWith$Input$ByteaComparisonExp<TRes> get extrinsicsicRoot;
  CopyWith$Input$ByteaComparisonExp<TRes> get hash;
  CopyWith$Input$IntComparisonExp<TRes> get height;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$StringComparisonExp<TRes> get implName;
  CopyWith$Input$IntComparisonExp<TRes> get implVersion;
  CopyWith$Input$ByteaComparisonExp<TRes> get parentHash;
  CopyWith$Input$StringComparisonExp<TRes> get specName;
  CopyWith$Input$IntComparisonExp<TRes> get specVersion;
  CopyWith$Input$ByteaComparisonExp<TRes> get stateRoot;
  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp;
  CopyWith$Input$ByteaComparisonExp<TRes> get validator;
}

class _CopyWithImpl$Input$BlockBoolExp<TRes>
    implements CopyWith$Input$BlockBoolExp<TRes> {
  _CopyWithImpl$Input$BlockBoolExp(
    this._instance,
    this._then,
  );

  final Input$BlockBoolExp _instance;

  final TRes Function(Input$BlockBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? calls = _undefined,
    Object? callsAggregate = _undefined,
    Object? callsCount = _undefined,
    Object? events = _undefined,
    Object? eventsAggregate = _undefined,
    Object? eventsCount = _undefined,
    Object? extrinsics = _undefined,
    Object? extrinsicsAggregate = _undefined,
    Object? extrinsicsCount = _undefined,
    Object? extrinsicsicRoot = _undefined,
    Object? hash = _undefined,
    Object? height = _undefined,
    Object? id = _undefined,
    Object? implName = _undefined,
    Object? implVersion = _undefined,
    Object? parentHash = _undefined,
    Object? specName = _undefined,
    Object? specVersion = _undefined,
    Object? stateRoot = _undefined,
    Object? timestamp = _undefined,
    Object? validator = _undefined,
  }) =>
      _then(Input$BlockBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<Input$BlockBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$BlockBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$BlockBoolExp>?),
        if (calls != _undefined) 'calls': (calls as Input$CallBoolExp?),
        if (callsAggregate != _undefined)
          'callsAggregate': (callsAggregate as Input$CallAggregateBoolExp?),
        if (callsCount != _undefined)
          'callsCount': (callsCount as Input$IntComparisonExp?),
        if (events != _undefined) 'events': (events as Input$EventBoolExp?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateBoolExp?),
        if (eventsCount != _undefined)
          'eventsCount': (eventsCount as Input$IntComparisonExp?),
        if (extrinsics != _undefined)
          'extrinsics': (extrinsics as Input$ExtrinsicBoolExp?),
        if (extrinsicsAggregate != _undefined)
          'extrinsicsAggregate':
              (extrinsicsAggregate as Input$ExtrinsicAggregateBoolExp?),
        if (extrinsicsCount != _undefined)
          'extrinsicsCount': (extrinsicsCount as Input$IntComparisonExp?),
        if (extrinsicsicRoot != _undefined)
          'extrinsicsicRoot': (extrinsicsicRoot as Input$ByteaComparisonExp?),
        if (hash != _undefined) 'hash': (hash as Input$ByteaComparisonExp?),
        if (height != _undefined) 'height': (height as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (implName != _undefined)
          'implName': (implName as Input$StringComparisonExp?),
        if (implVersion != _undefined)
          'implVersion': (implVersion as Input$IntComparisonExp?),
        if (parentHash != _undefined)
          'parentHash': (parentHash as Input$ByteaComparisonExp?),
        if (specName != _undefined)
          'specName': (specName as Input$StringComparisonExp?),
        if (specVersion != _undefined)
          'specVersion': (specVersion as Input$IntComparisonExp?),
        if (stateRoot != _undefined)
          'stateRoot': (stateRoot as Input$ByteaComparisonExp?),
        if (timestamp != _undefined)
          'timestamp': (timestamp as Input$TimestamptzComparisonExp?),
        if (validator != _undefined)
          'validator': (validator as Input$ByteaComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$BlockBoolExp>? Function(
                  Iterable<CopyWith$Input$BlockBoolExp<Input$BlockBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$BlockBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$BlockBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$BlockBoolExp.stub(_then(_instance))
        : CopyWith$Input$BlockBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$BlockBoolExp>? Function(
                  Iterable<CopyWith$Input$BlockBoolExp<Input$BlockBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$BlockBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$CallBoolExp<TRes> get calls {
    final local$calls = _instance.calls;
    return local$calls == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$calls, (e) => call(calls: e));
  }

  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate {
    final local$callsAggregate = _instance.callsAggregate;
    return local$callsAggregate == null
        ? CopyWith$Input$CallAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallAggregateBoolExp(
            local$callsAggregate, (e) => call(callsAggregate: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get callsCount {
    final local$callsCount = _instance.callsCount;
    return local$callsCount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$callsCount, (e) => call(callsCount: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get events {
    final local$events = _instance.events;
    return local$events == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$events, (e) => call(events: e));
  }

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventAggregateBoolExp(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get eventsCount {
    final local$eventsCount = _instance.eventsCount;
    return local$eventsCount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$eventsCount, (e) => call(eventsCount: e));
  }

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsics {
    final local$extrinsics = _instance.extrinsics;
    return local$extrinsics == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(
            local$extrinsics, (e) => call(extrinsics: e));
  }

  CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> get extrinsicsAggregate {
    final local$extrinsicsAggregate = _instance.extrinsicsAggregate;
    return local$extrinsicsAggregate == null
        ? CopyWith$Input$ExtrinsicAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicAggregateBoolExp(
            local$extrinsicsAggregate, (e) => call(extrinsicsAggregate: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get extrinsicsCount {
    final local$extrinsicsCount = _instance.extrinsicsCount;
    return local$extrinsicsCount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$extrinsicsCount, (e) => call(extrinsicsCount: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get extrinsicsicRoot {
    final local$extrinsicsicRoot = _instance.extrinsicsicRoot;
    return local$extrinsicsicRoot == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(
            local$extrinsicsicRoot, (e) => call(extrinsicsicRoot: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get hash {
    final local$hash = _instance.hash;
    return local$hash == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(local$hash, (e) => call(hash: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get height {
    final local$height = _instance.height;
    return local$height == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$height, (e) => call(height: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get implName {
    final local$implName = _instance.implName;
    return local$implName == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$implName, (e) => call(implName: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get implVersion {
    final local$implVersion = _instance.implVersion;
    return local$implVersion == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$implVersion, (e) => call(implVersion: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get parentHash {
    final local$parentHash = _instance.parentHash;
    return local$parentHash == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(
            local$parentHash, (e) => call(parentHash: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get specName {
    final local$specName = _instance.specName;
    return local$specName == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$specName, (e) => call(specName: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get specVersion {
    final local$specVersion = _instance.specVersion;
    return local$specVersion == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$specVersion, (e) => call(specVersion: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get stateRoot {
    final local$stateRoot = _instance.stateRoot;
    return local$stateRoot == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(
            local$stateRoot, (e) => call(stateRoot: e));
  }

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp {
    final local$timestamp = _instance.timestamp;
    return local$timestamp == null
        ? CopyWith$Input$TimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$Input$TimestamptzComparisonExp(
            local$timestamp, (e) => call(timestamp: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get validator {
    final local$validator = _instance.validator;
    return local$validator == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(
            local$validator, (e) => call(validator: e));
  }
}

class _CopyWithStubImpl$Input$BlockBoolExp<TRes>
    implements CopyWith$Input$BlockBoolExp<TRes> {
  _CopyWithStubImpl$Input$BlockBoolExp(this._res);

  TRes _res;

  call({
    List<Input$BlockBoolExp>? $_and,
    Input$BlockBoolExp? $_not,
    List<Input$BlockBoolExp>? $_or,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$IntComparisonExp? callsCount,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$IntComparisonExp? eventsCount,
    Input$ExtrinsicBoolExp? extrinsics,
    Input$ExtrinsicAggregateBoolExp? extrinsicsAggregate,
    Input$IntComparisonExp? extrinsicsCount,
    Input$ByteaComparisonExp? extrinsicsicRoot,
    Input$ByteaComparisonExp? hash,
    Input$IntComparisonExp? height,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? implName,
    Input$IntComparisonExp? implVersion,
    Input$ByteaComparisonExp? parentHash,
    Input$StringComparisonExp? specName,
    Input$IntComparisonExp? specVersion,
    Input$ByteaComparisonExp? stateRoot,
    Input$TimestamptzComparisonExp? timestamp,
    Input$ByteaComparisonExp? validator,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$BlockBoolExp<TRes> get $_not =>
      CopyWith$Input$BlockBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$CallBoolExp<TRes> get calls =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate =>
      CopyWith$Input$CallAggregateBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get callsCount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get events =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get eventsCount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsics =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> get extrinsicsAggregate =>
      CopyWith$Input$ExtrinsicAggregateBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get extrinsicsCount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get extrinsicsicRoot =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get hash =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get height =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get implName =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get implVersion =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get parentHash =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get specName =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get specVersion =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get stateRoot =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp =>
      CopyWith$Input$TimestamptzComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get validator =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);
}

class Input$BlockOrderBy {
  factory Input$BlockOrderBy({
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? callsCount,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? eventsCount,
    Input$ExtrinsicAggregateOrderBy? extrinsicsAggregate,
    Enum$OrderBy? extrinsicsCount,
    Enum$OrderBy? extrinsicsicRoot,
    Enum$OrderBy? hash,
    Enum$OrderBy? height,
    Enum$OrderBy? id,
    Enum$OrderBy? implName,
    Enum$OrderBy? implVersion,
    Enum$OrderBy? parentHash,
    Enum$OrderBy? specName,
    Enum$OrderBy? specVersion,
    Enum$OrderBy? stateRoot,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? validator,
  }) =>
      Input$BlockOrderBy._({
        if (callsAggregate != null) r'callsAggregate': callsAggregate,
        if (callsCount != null) r'callsCount': callsCount,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (eventsCount != null) r'eventsCount': eventsCount,
        if (extrinsicsAggregate != null)
          r'extrinsicsAggregate': extrinsicsAggregate,
        if (extrinsicsCount != null) r'extrinsicsCount': extrinsicsCount,
        if (extrinsicsicRoot != null) r'extrinsicsicRoot': extrinsicsicRoot,
        if (hash != null) r'hash': hash,
        if (height != null) r'height': height,
        if (id != null) r'id': id,
        if (implName != null) r'implName': implName,
        if (implVersion != null) r'implVersion': implVersion,
        if (parentHash != null) r'parentHash': parentHash,
        if (specName != null) r'specName': specName,
        if (specVersion != null) r'specVersion': specVersion,
        if (stateRoot != null) r'stateRoot': stateRoot,
        if (timestamp != null) r'timestamp': timestamp,
        if (validator != null) r'validator': validator,
      });

  Input$BlockOrderBy._(this._$data);

  factory Input$BlockOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('callsAggregate')) {
      final l$callsAggregate = data['callsAggregate'];
      result$data['callsAggregate'] = l$callsAggregate == null
          ? null
          : Input$CallAggregateOrderBy.fromJson(
              (l$callsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('callsCount')) {
      final l$callsCount = data['callsCount'];
      result$data['callsCount'] = l$callsCount == null
          ? null
          : fromJson$Enum$OrderBy((l$callsCount as String));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateOrderBy.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('eventsCount')) {
      final l$eventsCount = data['eventsCount'];
      result$data['eventsCount'] = l$eventsCount == null
          ? null
          : fromJson$Enum$OrderBy((l$eventsCount as String));
    }
    if (data.containsKey('extrinsicsAggregate')) {
      final l$extrinsicsAggregate = data['extrinsicsAggregate'];
      result$data['extrinsicsAggregate'] = l$extrinsicsAggregate == null
          ? null
          : Input$ExtrinsicAggregateOrderBy.fromJson(
              (l$extrinsicsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicsCount')) {
      final l$extrinsicsCount = data['extrinsicsCount'];
      result$data['extrinsicsCount'] = l$extrinsicsCount == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicsCount as String));
    }
    if (data.containsKey('extrinsicsicRoot')) {
      final l$extrinsicsicRoot = data['extrinsicsicRoot'];
      result$data['extrinsicsicRoot'] = l$extrinsicsicRoot == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicsicRoot as String));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] =
          l$hash == null ? null : fromJson$Enum$OrderBy((l$hash as String));
    }
    if (data.containsKey('height')) {
      final l$height = data['height'];
      result$data['height'] =
          l$height == null ? null : fromJson$Enum$OrderBy((l$height as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('implName')) {
      final l$implName = data['implName'];
      result$data['implName'] = l$implName == null
          ? null
          : fromJson$Enum$OrderBy((l$implName as String));
    }
    if (data.containsKey('implVersion')) {
      final l$implVersion = data['implVersion'];
      result$data['implVersion'] = l$implVersion == null
          ? null
          : fromJson$Enum$OrderBy((l$implVersion as String));
    }
    if (data.containsKey('parentHash')) {
      final l$parentHash = data['parentHash'];
      result$data['parentHash'] = l$parentHash == null
          ? null
          : fromJson$Enum$OrderBy((l$parentHash as String));
    }
    if (data.containsKey('specName')) {
      final l$specName = data['specName'];
      result$data['specName'] = l$specName == null
          ? null
          : fromJson$Enum$OrderBy((l$specName as String));
    }
    if (data.containsKey('specVersion')) {
      final l$specVersion = data['specVersion'];
      result$data['specVersion'] = l$specVersion == null
          ? null
          : fromJson$Enum$OrderBy((l$specVersion as String));
    }
    if (data.containsKey('stateRoot')) {
      final l$stateRoot = data['stateRoot'];
      result$data['stateRoot'] = l$stateRoot == null
          ? null
          : fromJson$Enum$OrderBy((l$stateRoot as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    if (data.containsKey('validator')) {
      final l$validator = data['validator'];
      result$data['validator'] = l$validator == null
          ? null
          : fromJson$Enum$OrderBy((l$validator as String));
    }
    return Input$BlockOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CallAggregateOrderBy? get callsAggregate =>
      (_$data['callsAggregate'] as Input$CallAggregateOrderBy?);

  Enum$OrderBy? get callsCount => (_$data['callsCount'] as Enum$OrderBy?);

  Input$EventAggregateOrderBy? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateOrderBy?);

  Enum$OrderBy? get eventsCount => (_$data['eventsCount'] as Enum$OrderBy?);

  Input$ExtrinsicAggregateOrderBy? get extrinsicsAggregate =>
      (_$data['extrinsicsAggregate'] as Input$ExtrinsicAggregateOrderBy?);

  Enum$OrderBy? get extrinsicsCount =>
      (_$data['extrinsicsCount'] as Enum$OrderBy?);

  Enum$OrderBy? get extrinsicsicRoot =>
      (_$data['extrinsicsicRoot'] as Enum$OrderBy?);

  Enum$OrderBy? get hash => (_$data['hash'] as Enum$OrderBy?);

  Enum$OrderBy? get height => (_$data['height'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get implName => (_$data['implName'] as Enum$OrderBy?);

  Enum$OrderBy? get implVersion => (_$data['implVersion'] as Enum$OrderBy?);

  Enum$OrderBy? get parentHash => (_$data['parentHash'] as Enum$OrderBy?);

  Enum$OrderBy? get specName => (_$data['specName'] as Enum$OrderBy?);

  Enum$OrderBy? get specVersion => (_$data['specVersion'] as Enum$OrderBy?);

  Enum$OrderBy? get stateRoot => (_$data['stateRoot'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Enum$OrderBy? get validator => (_$data['validator'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('callsAggregate')) {
      final l$callsAggregate = callsAggregate;
      result$data['callsAggregate'] = l$callsAggregate?.toJson();
    }
    if (_$data.containsKey('callsCount')) {
      final l$callsCount = callsCount;
      result$data['callsCount'] =
          l$callsCount == null ? null : toJson$Enum$OrderBy(l$callsCount);
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('eventsCount')) {
      final l$eventsCount = eventsCount;
      result$data['eventsCount'] =
          l$eventsCount == null ? null : toJson$Enum$OrderBy(l$eventsCount);
    }
    if (_$data.containsKey('extrinsicsAggregate')) {
      final l$extrinsicsAggregate = extrinsicsAggregate;
      result$data['extrinsicsAggregate'] = l$extrinsicsAggregate?.toJson();
    }
    if (_$data.containsKey('extrinsicsCount')) {
      final l$extrinsicsCount = extrinsicsCount;
      result$data['extrinsicsCount'] = l$extrinsicsCount == null
          ? null
          : toJson$Enum$OrderBy(l$extrinsicsCount);
    }
    if (_$data.containsKey('extrinsicsicRoot')) {
      final l$extrinsicsicRoot = extrinsicsicRoot;
      result$data['extrinsicsicRoot'] = l$extrinsicsicRoot == null
          ? null
          : toJson$Enum$OrderBy(l$extrinsicsicRoot);
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash == null ? null : toJson$Enum$OrderBy(l$hash);
    }
    if (_$data.containsKey('height')) {
      final l$height = height;
      result$data['height'] =
          l$height == null ? null : toJson$Enum$OrderBy(l$height);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('implName')) {
      final l$implName = implName;
      result$data['implName'] =
          l$implName == null ? null : toJson$Enum$OrderBy(l$implName);
    }
    if (_$data.containsKey('implVersion')) {
      final l$implVersion = implVersion;
      result$data['implVersion'] =
          l$implVersion == null ? null : toJson$Enum$OrderBy(l$implVersion);
    }
    if (_$data.containsKey('parentHash')) {
      final l$parentHash = parentHash;
      result$data['parentHash'] =
          l$parentHash == null ? null : toJson$Enum$OrderBy(l$parentHash);
    }
    if (_$data.containsKey('specName')) {
      final l$specName = specName;
      result$data['specName'] =
          l$specName == null ? null : toJson$Enum$OrderBy(l$specName);
    }
    if (_$data.containsKey('specVersion')) {
      final l$specVersion = specVersion;
      result$data['specVersion'] =
          l$specVersion == null ? null : toJson$Enum$OrderBy(l$specVersion);
    }
    if (_$data.containsKey('stateRoot')) {
      final l$stateRoot = stateRoot;
      result$data['stateRoot'] =
          l$stateRoot == null ? null : toJson$Enum$OrderBy(l$stateRoot);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    if (_$data.containsKey('validator')) {
      final l$validator = validator;
      result$data['validator'] =
          l$validator == null ? null : toJson$Enum$OrderBy(l$validator);
    }
    return result$data;
  }

  CopyWith$Input$BlockOrderBy<Input$BlockOrderBy> get copyWith =>
      CopyWith$Input$BlockOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$callsAggregate = callsAggregate;
    final lOther$callsAggregate = other.callsAggregate;
    if (_$data.containsKey('callsAggregate') !=
        other._$data.containsKey('callsAggregate')) {
      return false;
    }
    if (l$callsAggregate != lOther$callsAggregate) {
      return false;
    }
    final l$callsCount = callsCount;
    final lOther$callsCount = other.callsCount;
    if (_$data.containsKey('callsCount') !=
        other._$data.containsKey('callsCount')) {
      return false;
    }
    if (l$callsCount != lOther$callsCount) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$eventsCount = eventsCount;
    final lOther$eventsCount = other.eventsCount;
    if (_$data.containsKey('eventsCount') !=
        other._$data.containsKey('eventsCount')) {
      return false;
    }
    if (l$eventsCount != lOther$eventsCount) {
      return false;
    }
    final l$extrinsicsAggregate = extrinsicsAggregate;
    final lOther$extrinsicsAggregate = other.extrinsicsAggregate;
    if (_$data.containsKey('extrinsicsAggregate') !=
        other._$data.containsKey('extrinsicsAggregate')) {
      return false;
    }
    if (l$extrinsicsAggregate != lOther$extrinsicsAggregate) {
      return false;
    }
    final l$extrinsicsCount = extrinsicsCount;
    final lOther$extrinsicsCount = other.extrinsicsCount;
    if (_$data.containsKey('extrinsicsCount') !=
        other._$data.containsKey('extrinsicsCount')) {
      return false;
    }
    if (l$extrinsicsCount != lOther$extrinsicsCount) {
      return false;
    }
    final l$extrinsicsicRoot = extrinsicsicRoot;
    final lOther$extrinsicsicRoot = other.extrinsicsicRoot;
    if (_$data.containsKey('extrinsicsicRoot') !=
        other._$data.containsKey('extrinsicsicRoot')) {
      return false;
    }
    if (l$extrinsicsicRoot != lOther$extrinsicsicRoot) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$height = height;
    final lOther$height = other.height;
    if (_$data.containsKey('height') != other._$data.containsKey('height')) {
      return false;
    }
    if (l$height != lOther$height) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$implName = implName;
    final lOther$implName = other.implName;
    if (_$data.containsKey('implName') !=
        other._$data.containsKey('implName')) {
      return false;
    }
    if (l$implName != lOther$implName) {
      return false;
    }
    final l$implVersion = implVersion;
    final lOther$implVersion = other.implVersion;
    if (_$data.containsKey('implVersion') !=
        other._$data.containsKey('implVersion')) {
      return false;
    }
    if (l$implVersion != lOther$implVersion) {
      return false;
    }
    final l$parentHash = parentHash;
    final lOther$parentHash = other.parentHash;
    if (_$data.containsKey('parentHash') !=
        other._$data.containsKey('parentHash')) {
      return false;
    }
    if (l$parentHash != lOther$parentHash) {
      return false;
    }
    final l$specName = specName;
    final lOther$specName = other.specName;
    if (_$data.containsKey('specName') !=
        other._$data.containsKey('specName')) {
      return false;
    }
    if (l$specName != lOther$specName) {
      return false;
    }
    final l$specVersion = specVersion;
    final lOther$specVersion = other.specVersion;
    if (_$data.containsKey('specVersion') !=
        other._$data.containsKey('specVersion')) {
      return false;
    }
    if (l$specVersion != lOther$specVersion) {
      return false;
    }
    final l$stateRoot = stateRoot;
    final lOther$stateRoot = other.stateRoot;
    if (_$data.containsKey('stateRoot') !=
        other._$data.containsKey('stateRoot')) {
      return false;
    }
    if (l$stateRoot != lOther$stateRoot) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$validator = validator;
    final lOther$validator = other.validator;
    if (_$data.containsKey('validator') !=
        other._$data.containsKey('validator')) {
      return false;
    }
    if (l$validator != lOther$validator) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$callsAggregate = callsAggregate;
    final l$callsCount = callsCount;
    final l$eventsAggregate = eventsAggregate;
    final l$eventsCount = eventsCount;
    final l$extrinsicsAggregate = extrinsicsAggregate;
    final l$extrinsicsCount = extrinsicsCount;
    final l$extrinsicsicRoot = extrinsicsicRoot;
    final l$hash = hash;
    final l$height = height;
    final l$id = id;
    final l$implName = implName;
    final l$implVersion = implVersion;
    final l$parentHash = parentHash;
    final l$specName = specName;
    final l$specVersion = specVersion;
    final l$stateRoot = stateRoot;
    final l$timestamp = timestamp;
    final l$validator = validator;
    return Object.hashAll([
      _$data.containsKey('callsAggregate') ? l$callsAggregate : const {},
      _$data.containsKey('callsCount') ? l$callsCount : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('eventsCount') ? l$eventsCount : const {},
      _$data.containsKey('extrinsicsAggregate')
          ? l$extrinsicsAggregate
          : const {},
      _$data.containsKey('extrinsicsCount') ? l$extrinsicsCount : const {},
      _$data.containsKey('extrinsicsicRoot') ? l$extrinsicsicRoot : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('height') ? l$height : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('implName') ? l$implName : const {},
      _$data.containsKey('implVersion') ? l$implVersion : const {},
      _$data.containsKey('parentHash') ? l$parentHash : const {},
      _$data.containsKey('specName') ? l$specName : const {},
      _$data.containsKey('specVersion') ? l$specVersion : const {},
      _$data.containsKey('stateRoot') ? l$stateRoot : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('validator') ? l$validator : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockOrderBy<TRes> {
  factory CopyWith$Input$BlockOrderBy(
    Input$BlockOrderBy instance,
    TRes Function(Input$BlockOrderBy) then,
  ) = _CopyWithImpl$Input$BlockOrderBy;

  factory CopyWith$Input$BlockOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockOrderBy;

  TRes call({
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? callsCount,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? eventsCount,
    Input$ExtrinsicAggregateOrderBy? extrinsicsAggregate,
    Enum$OrderBy? extrinsicsCount,
    Enum$OrderBy? extrinsicsicRoot,
    Enum$OrderBy? hash,
    Enum$OrderBy? height,
    Enum$OrderBy? id,
    Enum$OrderBy? implName,
    Enum$OrderBy? implVersion,
    Enum$OrderBy? parentHash,
    Enum$OrderBy? specName,
    Enum$OrderBy? specVersion,
    Enum$OrderBy? stateRoot,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? validator,
  });
  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate;
  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate;
  CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> get extrinsicsAggregate;
}

class _CopyWithImpl$Input$BlockOrderBy<TRes>
    implements CopyWith$Input$BlockOrderBy<TRes> {
  _CopyWithImpl$Input$BlockOrderBy(
    this._instance,
    this._then,
  );

  final Input$BlockOrderBy _instance;

  final TRes Function(Input$BlockOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? callsAggregate = _undefined,
    Object? callsCount = _undefined,
    Object? eventsAggregate = _undefined,
    Object? eventsCount = _undefined,
    Object? extrinsicsAggregate = _undefined,
    Object? extrinsicsCount = _undefined,
    Object? extrinsicsicRoot = _undefined,
    Object? hash = _undefined,
    Object? height = _undefined,
    Object? id = _undefined,
    Object? implName = _undefined,
    Object? implVersion = _undefined,
    Object? parentHash = _undefined,
    Object? specName = _undefined,
    Object? specVersion = _undefined,
    Object? stateRoot = _undefined,
    Object? timestamp = _undefined,
    Object? validator = _undefined,
  }) =>
      _then(Input$BlockOrderBy._({
        ..._instance._$data,
        if (callsAggregate != _undefined)
          'callsAggregate': (callsAggregate as Input$CallAggregateOrderBy?),
        if (callsCount != _undefined)
          'callsCount': (callsCount as Enum$OrderBy?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateOrderBy?),
        if (eventsCount != _undefined)
          'eventsCount': (eventsCount as Enum$OrderBy?),
        if (extrinsicsAggregate != _undefined)
          'extrinsicsAggregate':
              (extrinsicsAggregate as Input$ExtrinsicAggregateOrderBy?),
        if (extrinsicsCount != _undefined)
          'extrinsicsCount': (extrinsicsCount as Enum$OrderBy?),
        if (extrinsicsicRoot != _undefined)
          'extrinsicsicRoot': (extrinsicsicRoot as Enum$OrderBy?),
        if (hash != _undefined) 'hash': (hash as Enum$OrderBy?),
        if (height != _undefined) 'height': (height as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (implName != _undefined) 'implName': (implName as Enum$OrderBy?),
        if (implVersion != _undefined)
          'implVersion': (implVersion as Enum$OrderBy?),
        if (parentHash != _undefined)
          'parentHash': (parentHash as Enum$OrderBy?),
        if (specName != _undefined) 'specName': (specName as Enum$OrderBy?),
        if (specVersion != _undefined)
          'specVersion': (specVersion as Enum$OrderBy?),
        if (stateRoot != _undefined) 'stateRoot': (stateRoot as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
        if (validator != _undefined) 'validator': (validator as Enum$OrderBy?),
      }));

  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate {
    final local$callsAggregate = _instance.callsAggregate;
    return local$callsAggregate == null
        ? CopyWith$Input$CallAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallAggregateOrderBy(
            local$callsAggregate, (e) => call(callsAggregate: e));
  }

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventAggregateOrderBy(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }

  CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> get extrinsicsAggregate {
    final local$extrinsicsAggregate = _instance.extrinsicsAggregate;
    return local$extrinsicsAggregate == null
        ? CopyWith$Input$ExtrinsicAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicAggregateOrderBy(
            local$extrinsicsAggregate, (e) => call(extrinsicsAggregate: e));
  }
}

class _CopyWithStubImpl$Input$BlockOrderBy<TRes>
    implements CopyWith$Input$BlockOrderBy<TRes> {
  _CopyWithStubImpl$Input$BlockOrderBy(this._res);

  TRes _res;

  call({
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? callsCount,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? eventsCount,
    Input$ExtrinsicAggregateOrderBy? extrinsicsAggregate,
    Enum$OrderBy? extrinsicsCount,
    Enum$OrderBy? extrinsicsicRoot,
    Enum$OrderBy? hash,
    Enum$OrderBy? height,
    Enum$OrderBy? id,
    Enum$OrderBy? implName,
    Enum$OrderBy? implVersion,
    Enum$OrderBy? parentHash,
    Enum$OrderBy? specName,
    Enum$OrderBy? specVersion,
    Enum$OrderBy? stateRoot,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? validator,
  }) =>
      _res;

  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate =>
      CopyWith$Input$CallAggregateOrderBy.stub(_res);

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> get extrinsicsAggregate =>
      CopyWith$Input$ExtrinsicAggregateOrderBy.stub(_res);
}

class Input$BooleanComparisonExp {
  factory Input$BooleanComparisonExp({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  }) =>
      Input$BooleanComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$BooleanComparisonExp._(this._$data);

  factory Input$BooleanComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as bool?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as bool?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as bool?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as bool)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as bool?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as bool?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as bool)).toList();
    }
    return Input$BooleanComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get $_eq => (_$data['_eq'] as bool?);

  bool? get $_gt => (_$data['_gt'] as bool?);

  bool? get $_gte => (_$data['_gte'] as bool?);

  List<bool>? get $_in => (_$data['_in'] as List<bool>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  bool? get $_lt => (_$data['_lt'] as bool?);

  bool? get $_lte => (_$data['_lte'] as bool?);

  bool? get $_neq => (_$data['_neq'] as bool?);

  List<bool>? get $_nin => (_$data['_nin'] as List<bool>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$BooleanComparisonExp<Input$BooleanComparisonExp>
      get copyWith => CopyWith$Input$BooleanComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BooleanComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$BooleanComparisonExp<TRes> {
  factory CopyWith$Input$BooleanComparisonExp(
    Input$BooleanComparisonExp instance,
    TRes Function(Input$BooleanComparisonExp) then,
  ) = _CopyWithImpl$Input$BooleanComparisonExp;

  factory CopyWith$Input$BooleanComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$BooleanComparisonExp;

  TRes call({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  });
}

class _CopyWithImpl$Input$BooleanComparisonExp<TRes>
    implements CopyWith$Input$BooleanComparisonExp<TRes> {
  _CopyWithImpl$Input$BooleanComparisonExp(
    this._instance,
    this._then,
  );

  final Input$BooleanComparisonExp _instance;

  final TRes Function(Input$BooleanComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$BooleanComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as bool?),
        if ($_gt != _undefined) '_gt': ($_gt as bool?),
        if ($_gte != _undefined) '_gte': ($_gte as bool?),
        if ($_in != _undefined) '_in': ($_in as List<bool>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as bool?),
        if ($_lte != _undefined) '_lte': ($_lte as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as bool?),
        if ($_nin != _undefined) '_nin': ($_nin as List<bool>?),
      }));
}

class _CopyWithStubImpl$Input$BooleanComparisonExp<TRes>
    implements CopyWith$Input$BooleanComparisonExp<TRes> {
  _CopyWithStubImpl$Input$BooleanComparisonExp(this._res);

  TRes _res;

  call({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  }) =>
      _res;
}

class Input$ByteaComparisonExp {
  factory Input$ByteaComparisonExp({
    Uint8List? $_eq,
    Uint8List? $_gt,
    Uint8List? $_gte,
    List<Uint8List>? $_in,
    bool? $_isNull,
    Uint8List? $_lt,
    Uint8List? $_lte,
    Uint8List? $_neq,
    List<Uint8List>? $_nin,
  }) =>
      Input$ByteaComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$ByteaComparisonExp._(this._$data);

  factory Input$ByteaComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as Uint8List?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as Uint8List?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as Uint8List?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as Uint8List)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as Uint8List?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as Uint8List?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as Uint8List?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as Uint8List)).toList();
    }
    return Input$ByteaComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Uint8List? get $_eq => (_$data['_eq'] as Uint8List?);

  Uint8List? get $_gt => (_$data['_gt'] as Uint8List?);

  Uint8List? get $_gte => (_$data['_gte'] as Uint8List?);

  List<Uint8List>? get $_in => (_$data['_in'] as List<Uint8List>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Uint8List? get $_lt => (_$data['_lt'] as Uint8List?);

  Uint8List? get $_lte => (_$data['_lte'] as Uint8List?);

  Uint8List? get $_neq => (_$data['_neq'] as Uint8List?);

  List<Uint8List>? get $_nin => (_$data['_nin'] as List<Uint8List>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$ByteaComparisonExp<Input$ByteaComparisonExp> get copyWith =>
      CopyWith$Input$ByteaComparisonExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ByteaComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ByteaComparisonExp<TRes> {
  factory CopyWith$Input$ByteaComparisonExp(
    Input$ByteaComparisonExp instance,
    TRes Function(Input$ByteaComparisonExp) then,
  ) = _CopyWithImpl$Input$ByteaComparisonExp;

  factory CopyWith$Input$ByteaComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ByteaComparisonExp;

  TRes call({
    Uint8List? $_eq,
    Uint8List? $_gt,
    Uint8List? $_gte,
    List<Uint8List>? $_in,
    bool? $_isNull,
    Uint8List? $_lt,
    Uint8List? $_lte,
    Uint8List? $_neq,
    List<Uint8List>? $_nin,
  });
}

class _CopyWithImpl$Input$ByteaComparisonExp<TRes>
    implements CopyWith$Input$ByteaComparisonExp<TRes> {
  _CopyWithImpl$Input$ByteaComparisonExp(
    this._instance,
    this._then,
  );

  final Input$ByteaComparisonExp _instance;

  final TRes Function(Input$ByteaComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$ByteaComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Uint8List?),
        if ($_gt != _undefined) '_gt': ($_gt as Uint8List?),
        if ($_gte != _undefined) '_gte': ($_gte as Uint8List?),
        if ($_in != _undefined) '_in': ($_in as List<Uint8List>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as Uint8List?),
        if ($_lte != _undefined) '_lte': ($_lte as Uint8List?),
        if ($_neq != _undefined) '_neq': ($_neq as Uint8List?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Uint8List>?),
      }));
}

class _CopyWithStubImpl$Input$ByteaComparisonExp<TRes>
    implements CopyWith$Input$ByteaComparisonExp<TRes> {
  _CopyWithStubImpl$Input$ByteaComparisonExp(this._res);

  TRes _res;

  call({
    Uint8List? $_eq,
    Uint8List? $_gt,
    Uint8List? $_gte,
    List<Uint8List>? $_in,
    bool? $_isNull,
    Uint8List? $_lt,
    Uint8List? $_lte,
    Uint8List? $_neq,
    List<Uint8List>? $_nin,
  }) =>
      _res;
}

class Input$CallAggregateBoolExp {
  factory Input$CallAggregateBoolExp({
    Input$callAggregateBoolExpBool_and? bool_and,
    Input$callAggregateBoolExpBool_or? bool_or,
    Input$callAggregateBoolExpCount? count,
  }) =>
      Input$CallAggregateBoolExp._({
        if (bool_and != null) r'bool_and': bool_and,
        if (bool_or != null) r'bool_or': bool_or,
        if (count != null) r'count': count,
      });

  Input$CallAggregateBoolExp._(this._$data);

  factory Input$CallAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bool_and')) {
      final l$bool_and = data['bool_and'];
      result$data['bool_and'] = l$bool_and == null
          ? null
          : Input$callAggregateBoolExpBool_and.fromJson(
              (l$bool_and as Map<String, dynamic>));
    }
    if (data.containsKey('bool_or')) {
      final l$bool_or = data['bool_or'];
      result$data['bool_or'] = l$bool_or == null
          ? null
          : Input$callAggregateBoolExpBool_or.fromJson(
              (l$bool_or as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$callAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$CallAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$callAggregateBoolExpBool_and? get bool_and =>
      (_$data['bool_and'] as Input$callAggregateBoolExpBool_and?);

  Input$callAggregateBoolExpBool_or? get bool_or =>
      (_$data['bool_or'] as Input$callAggregateBoolExpBool_or?);

  Input$callAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$callAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bool_and')) {
      final l$bool_and = bool_and;
      result$data['bool_and'] = l$bool_and?.toJson();
    }
    if (_$data.containsKey('bool_or')) {
      final l$bool_or = bool_or;
      result$data['bool_or'] = l$bool_or?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CallAggregateBoolExp<Input$CallAggregateBoolExp>
      get copyWith => CopyWith$Input$CallAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bool_and = bool_and;
    final lOther$bool_and = other.bool_and;
    if (_$data.containsKey('bool_and') !=
        other._$data.containsKey('bool_and')) {
      return false;
    }
    if (l$bool_and != lOther$bool_and) {
      return false;
    }
    final l$bool_or = bool_or;
    final lOther$bool_or = other.bool_or;
    if (_$data.containsKey('bool_or') != other._$data.containsKey('bool_or')) {
      return false;
    }
    if (l$bool_or != lOther$bool_or) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bool_and = bool_and;
    final l$bool_or = bool_or;
    final l$count = count;
    return Object.hashAll([
      _$data.containsKey('bool_and') ? l$bool_and : const {},
      _$data.containsKey('bool_or') ? l$bool_or : const {},
      _$data.containsKey('count') ? l$count : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallAggregateBoolExp<TRes> {
  factory CopyWith$Input$CallAggregateBoolExp(
    Input$CallAggregateBoolExp instance,
    TRes Function(Input$CallAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$CallAggregateBoolExp;

  factory CopyWith$Input$CallAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CallAggregateBoolExp;

  TRes call({
    Input$callAggregateBoolExpBool_and? bool_and,
    Input$callAggregateBoolExpBool_or? bool_or,
    Input$callAggregateBoolExpCount? count,
  });
  CopyWith$Input$callAggregateBoolExpBool_and<TRes> get bool_and;
  CopyWith$Input$callAggregateBoolExpBool_or<TRes> get bool_or;
  CopyWith$Input$callAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$CallAggregateBoolExp<TRes>
    implements CopyWith$Input$CallAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$CallAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$CallAggregateBoolExp _instance;

  final TRes Function(Input$CallAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bool_and = _undefined,
    Object? bool_or = _undefined,
    Object? count = _undefined,
  }) =>
      _then(Input$CallAggregateBoolExp._({
        ..._instance._$data,
        if (bool_and != _undefined)
          'bool_and': (bool_and as Input$callAggregateBoolExpBool_and?),
        if (bool_or != _undefined)
          'bool_or': (bool_or as Input$callAggregateBoolExpBool_or?),
        if (count != _undefined)
          'count': (count as Input$callAggregateBoolExpCount?),
      }));

  CopyWith$Input$callAggregateBoolExpBool_and<TRes> get bool_and {
    final local$bool_and = _instance.bool_and;
    return local$bool_and == null
        ? CopyWith$Input$callAggregateBoolExpBool_and.stub(_then(_instance))
        : CopyWith$Input$callAggregateBoolExpBool_and(
            local$bool_and, (e) => call(bool_and: e));
  }

  CopyWith$Input$callAggregateBoolExpBool_or<TRes> get bool_or {
    final local$bool_or = _instance.bool_or;
    return local$bool_or == null
        ? CopyWith$Input$callAggregateBoolExpBool_or.stub(_then(_instance))
        : CopyWith$Input$callAggregateBoolExpBool_or(
            local$bool_or, (e) => call(bool_or: e));
  }

  CopyWith$Input$callAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$callAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$callAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$CallAggregateBoolExp<TRes>
    implements CopyWith$Input$CallAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$CallAggregateBoolExp(this._res);

  TRes _res;

  call({
    Input$callAggregateBoolExpBool_and? bool_and,
    Input$callAggregateBoolExpBool_or? bool_or,
    Input$callAggregateBoolExpCount? count,
  }) =>
      _res;

  CopyWith$Input$callAggregateBoolExpBool_and<TRes> get bool_and =>
      CopyWith$Input$callAggregateBoolExpBool_and.stub(_res);

  CopyWith$Input$callAggregateBoolExpBool_or<TRes> get bool_or =>
      CopyWith$Input$callAggregateBoolExpBool_or.stub(_res);

  CopyWith$Input$callAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$callAggregateBoolExpCount.stub(_res);
}

class Input$callAggregateBoolExpBool_and {
  factory Input$callAggregateBoolExpBool_and({
    required Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
        arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$callAggregateBoolExpBool_and._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$callAggregateBoolExpBool_and._(this._$data);

  factory Input$callAggregateBoolExpBool_and.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CallBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$callAggregateBoolExpBool_and._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CallBoolExp? get filter => (_$data['filter'] as Input$CallBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$callAggregateBoolExpBool_and<
          Input$callAggregateBoolExpBool_and>
      get copyWith => CopyWith$Input$callAggregateBoolExpBool_and(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$callAggregateBoolExpBool_and) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$callAggregateBoolExpBool_and<TRes> {
  factory CopyWith$Input$callAggregateBoolExpBool_and(
    Input$callAggregateBoolExpBool_and instance,
    TRes Function(Input$callAggregateBoolExpBool_and) then,
  ) = _CopyWithImpl$Input$callAggregateBoolExpBool_and;

  factory CopyWith$Input$callAggregateBoolExpBool_and.stub(TRes res) =
      _CopyWithStubImpl$Input$callAggregateBoolExpBool_and;

  TRes call({
    Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$CallBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$callAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$callAggregateBoolExpBool_and<TRes> {
  _CopyWithImpl$Input$callAggregateBoolExpBool_and(
    this._instance,
    this._then,
  );

  final Input$callAggregateBoolExpBool_and _instance;

  final TRes Function(Input$callAggregateBoolExpBool_and) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$callAggregateBoolExpBool_and._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CallBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$CallBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$callAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$callAggregateBoolExpBool_and<TRes> {
  _CopyWithStubImpl$Input$callAggregateBoolExpBool_and(this._res);

  TRes _res;

  call({
    Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CallBoolExp<TRes> get filter =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$callAggregateBoolExpBool_or {
  factory Input$callAggregateBoolExpBool_or({
    required Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
        arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$callAggregateBoolExpBool_or._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$callAggregateBoolExpBool_or._(this._$data);

  factory Input$callAggregateBoolExpBool_or.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CallBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$callAggregateBoolExpBool_or._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CallBoolExp? get filter => (_$data['filter'] as Input$CallBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$callAggregateBoolExpBool_or<Input$callAggregateBoolExpBool_or>
      get copyWith => CopyWith$Input$callAggregateBoolExpBool_or(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$callAggregateBoolExpBool_or) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$callAggregateBoolExpBool_or<TRes> {
  factory CopyWith$Input$callAggregateBoolExpBool_or(
    Input$callAggregateBoolExpBool_or instance,
    TRes Function(Input$callAggregateBoolExpBool_or) then,
  ) = _CopyWithImpl$Input$callAggregateBoolExpBool_or;

  factory CopyWith$Input$callAggregateBoolExpBool_or.stub(TRes res) =
      _CopyWithStubImpl$Input$callAggregateBoolExpBool_or;

  TRes call({
    Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns? arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$CallBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$callAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$callAggregateBoolExpBool_or<TRes> {
  _CopyWithImpl$Input$callAggregateBoolExpBool_or(
    this._instance,
    this._then,
  );

  final Input$callAggregateBoolExpBool_or _instance;

  final TRes Function(Input$callAggregateBoolExpBool_or) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$callAggregateBoolExpBool_or._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CallBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$CallBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$callAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$callAggregateBoolExpBool_or<TRes> {
  _CopyWithStubImpl$Input$callAggregateBoolExpBool_or(this._res);

  TRes _res;

  call({
    Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns? arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CallBoolExp<TRes> get filter =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$callAggregateBoolExpCount {
  factory Input$callAggregateBoolExpCount({
    List<Enum$CallSelectColumn>? arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$callAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$callAggregateBoolExpCount._(this._$data);

  factory Input$callAggregateBoolExpCount.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CallSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CallBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$callAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$CallSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$CallSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CallBoolExp? get filter => (_$data['filter'] as Input$CallBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] =
          l$arguments?.map((e) => toJson$Enum$CallSelectColumn(e)).toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$callAggregateBoolExpCount<Input$callAggregateBoolExpCount>
      get copyWith => CopyWith$Input$callAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$callAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$callAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$callAggregateBoolExpCount(
    Input$callAggregateBoolExpCount instance,
    TRes Function(Input$callAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$callAggregateBoolExpCount;

  factory CopyWith$Input$callAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$callAggregateBoolExpCount;

  TRes call({
    List<Enum$CallSelectColumn>? arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$CallBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$callAggregateBoolExpCount<TRes>
    implements CopyWith$Input$callAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$callAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$callAggregateBoolExpCount _instance;

  final TRes Function(Input$callAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$callAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$CallSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CallBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$CallBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$callAggregateBoolExpCount<TRes>
    implements CopyWith$Input$callAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$callAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$CallSelectColumn>? arguments,
    bool? distinct,
    Input$CallBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CallBoolExp<TRes> get filter =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$CallAggregateOrderBy {
  factory Input$CallAggregateOrderBy({
    Enum$OrderBy? count,
    Input$CallMaxOrderBy? max,
    Input$CallMinOrderBy? min,
  }) =>
      Input$CallAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  Input$CallAggregateOrderBy._(this._$data);

  factory Input$CallAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$CallMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$CallMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    return Input$CallAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$CallMaxOrderBy? get max => (_$data['max'] as Input$CallMaxOrderBy?);

  Input$CallMinOrderBy? get min => (_$data['min'] as Input$CallMinOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CallAggregateOrderBy<Input$CallAggregateOrderBy>
      get copyWith => CopyWith$Input$CallAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallAggregateOrderBy<TRes> {
  factory CopyWith$Input$CallAggregateOrderBy(
    Input$CallAggregateOrderBy instance,
    TRes Function(Input$CallAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$CallAggregateOrderBy;

  factory CopyWith$Input$CallAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CallAggregateOrderBy;

  TRes call({
    Enum$OrderBy? count,
    Input$CallMaxOrderBy? max,
    Input$CallMinOrderBy? min,
  });
  CopyWith$Input$CallMaxOrderBy<TRes> get max;
  CopyWith$Input$CallMinOrderBy<TRes> get min;
}

class _CopyWithImpl$Input$CallAggregateOrderBy<TRes>
    implements CopyWith$Input$CallAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$CallAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$CallAggregateOrderBy _instance;

  final TRes Function(Input$CallAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(Input$CallAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$CallMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$CallMinOrderBy?),
      }));

  CopyWith$Input$CallMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$CallMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$CallMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$CallMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallMinOrderBy(local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$Input$CallAggregateOrderBy<TRes>
    implements CopyWith$Input$CallAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$CallAggregateOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? count,
    Input$CallMaxOrderBy? max,
    Input$CallMinOrderBy? min,
  }) =>
      _res;

  CopyWith$Input$CallMaxOrderBy<TRes> get max =>
      CopyWith$Input$CallMaxOrderBy.stub(_res);

  CopyWith$Input$CallMinOrderBy<TRes> get min =>
      CopyWith$Input$CallMinOrderBy.stub(_res);
}

class Input$CallBoolExp {
  factory Input$CallBoolExp({
    List<Input$CallBoolExp>? $_and,
    Input$CallBoolExp? $_not,
    List<Input$CallBoolExp>? $_or,
    Input$IntArrayComparisonExp? address,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$CallBoolExp? parent,
    Input$StringComparisonExp? parentId,
    Input$CallBoolExp? subcalls,
    Input$CallAggregateBoolExp? subcallsAggregate,
    Input$BooleanComparisonExp? success,
  }) =>
      Input$CallBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (address != null) r'address': address,
        if (args != null) r'args': args,
        if (argsStr != null) r'argsStr': argsStr,
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if (error != null) r'error': error,
        if (events != null) r'events': events,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (extrinsic != null) r'extrinsic': extrinsic,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (parent != null) r'parent': parent,
        if (parentId != null) r'parentId': parentId,
        if (subcalls != null) r'subcalls': subcalls,
        if (subcallsAggregate != null) r'subcallsAggregate': subcallsAggregate,
        if (success != null) r'success': success,
      });

  Input$CallBoolExp._(this._$data);

  factory Input$CallBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$CallBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$CallBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$CallBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$IntArrayComparisonExp.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('args')) {
      final l$args = data['args'];
      result$data['args'] = l$args == null
          ? null
          : Input$JsonbComparisonExp.fromJson((l$args as Map<String, dynamic>));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : Input$StringArrayComparisonExp.fromJson(
              (l$argsStr as Map<String, dynamic>));
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockBoolExp.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$blockId as Map<String, dynamic>));
    }
    if (data.containsKey('error')) {
      final l$error = data['error'];
      result$data['error'] = l$error == null
          ? null
          : Input$JsonbComparisonExp.fromJson(
              (l$error as Map<String, dynamic>));
    }
    if (data.containsKey('events')) {
      final l$events = data['events'];
      result$data['events'] = l$events == null
          ? null
          : Input$EventBoolExp.fromJson((l$events as Map<String, dynamic>));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateBoolExp.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsic')) {
      final l$extrinsic = data['extrinsic'];
      result$data['extrinsic'] = l$extrinsic == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson(
              (l$extrinsic as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$extrinsicId as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] = l$pallet == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$pallet as Map<String, dynamic>));
    }
    if (data.containsKey('parent')) {
      final l$parent = data['parent'];
      result$data['parent'] = l$parent == null
          ? null
          : Input$CallBoolExp.fromJson((l$parent as Map<String, dynamic>));
    }
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = l$parentId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$parentId as Map<String, dynamic>));
    }
    if (data.containsKey('subcalls')) {
      final l$subcalls = data['subcalls'];
      result$data['subcalls'] = l$subcalls == null
          ? null
          : Input$CallBoolExp.fromJson((l$subcalls as Map<String, dynamic>));
    }
    if (data.containsKey('subcallsAggregate')) {
      final l$subcallsAggregate = data['subcallsAggregate'];
      result$data['subcallsAggregate'] = l$subcallsAggregate == null
          ? null
          : Input$CallAggregateBoolExp.fromJson(
              (l$subcallsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('success')) {
      final l$success = data['success'];
      result$data['success'] = l$success == null
          ? null
          : Input$BooleanComparisonExp.fromJson(
              (l$success as Map<String, dynamic>));
    }
    return Input$CallBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CallBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$CallBoolExp>?);

  Input$CallBoolExp? get $_not => (_$data['_not'] as Input$CallBoolExp?);

  List<Input$CallBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$CallBoolExp>?);

  Input$IntArrayComparisonExp? get address =>
      (_$data['address'] as Input$IntArrayComparisonExp?);

  Input$JsonbComparisonExp? get args =>
      (_$data['args'] as Input$JsonbComparisonExp?);

  Input$StringArrayComparisonExp? get argsStr =>
      (_$data['argsStr'] as Input$StringArrayComparisonExp?);

  Input$BlockBoolExp? get block => (_$data['block'] as Input$BlockBoolExp?);

  Input$StringComparisonExp? get blockId =>
      (_$data['blockId'] as Input$StringComparisonExp?);

  Input$JsonbComparisonExp? get error =>
      (_$data['error'] as Input$JsonbComparisonExp?);

  Input$EventBoolExp? get events => (_$data['events'] as Input$EventBoolExp?);

  Input$EventAggregateBoolExp? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateBoolExp?);

  Input$ExtrinsicBoolExp? get extrinsic =>
      (_$data['extrinsic'] as Input$ExtrinsicBoolExp?);

  Input$StringComparisonExp? get extrinsicId =>
      (_$data['extrinsicId'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get name =>
      (_$data['name'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get pallet =>
      (_$data['pallet'] as Input$StringComparisonExp?);

  Input$CallBoolExp? get parent => (_$data['parent'] as Input$CallBoolExp?);

  Input$StringComparisonExp? get parentId =>
      (_$data['parentId'] as Input$StringComparisonExp?);

  Input$CallBoolExp? get subcalls => (_$data['subcalls'] as Input$CallBoolExp?);

  Input$CallAggregateBoolExp? get subcallsAggregate =>
      (_$data['subcallsAggregate'] as Input$CallAggregateBoolExp?);

  Input$BooleanComparisonExp? get success =>
      (_$data['success'] as Input$BooleanComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('args')) {
      final l$args = args;
      result$data['args'] = l$args?.toJson();
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] = l$argsStr?.toJson();
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] = l$blockId?.toJson();
    }
    if (_$data.containsKey('error')) {
      final l$error = error;
      result$data['error'] = l$error?.toJson();
    }
    if (_$data.containsKey('events')) {
      final l$events = events;
      result$data['events'] = l$events?.toJson();
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('extrinsic')) {
      final l$extrinsic = extrinsic;
      result$data['extrinsic'] = l$extrinsic?.toJson();
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] = l$extrinsicId?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] = l$pallet?.toJson();
    }
    if (_$data.containsKey('parent')) {
      final l$parent = parent;
      result$data['parent'] = l$parent?.toJson();
    }
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] = l$parentId?.toJson();
    }
    if (_$data.containsKey('subcalls')) {
      final l$subcalls = subcalls;
      result$data['subcalls'] = l$subcalls?.toJson();
    }
    if (_$data.containsKey('subcallsAggregate')) {
      final l$subcallsAggregate = subcallsAggregate;
      result$data['subcallsAggregate'] = l$subcallsAggregate?.toJson();
    }
    if (_$data.containsKey('success')) {
      final l$success = success;
      result$data['success'] = l$success?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CallBoolExp<Input$CallBoolExp> get copyWith =>
      CopyWith$Input$CallBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$args = args;
    final lOther$args = other.args;
    if (_$data.containsKey('args') != other._$data.containsKey('args')) {
      return false;
    }
    if (l$args != lOther$args) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$error = error;
    final lOther$error = other.error;
    if (_$data.containsKey('error') != other._$data.containsKey('error')) {
      return false;
    }
    if (l$error != lOther$error) {
      return false;
    }
    final l$events = events;
    final lOther$events = other.events;
    if (_$data.containsKey('events') != other._$data.containsKey('events')) {
      return false;
    }
    if (l$events != lOther$events) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$extrinsic = extrinsic;
    final lOther$extrinsic = other.extrinsic;
    if (_$data.containsKey('extrinsic') !=
        other._$data.containsKey('extrinsic')) {
      return false;
    }
    if (l$extrinsic != lOther$extrinsic) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$parent = parent;
    final lOther$parent = other.parent;
    if (_$data.containsKey('parent') != other._$data.containsKey('parent')) {
      return false;
    }
    if (l$parent != lOther$parent) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    final l$subcalls = subcalls;
    final lOther$subcalls = other.subcalls;
    if (_$data.containsKey('subcalls') !=
        other._$data.containsKey('subcalls')) {
      return false;
    }
    if (l$subcalls != lOther$subcalls) {
      return false;
    }
    final l$subcallsAggregate = subcallsAggregate;
    final lOther$subcallsAggregate = other.subcallsAggregate;
    if (_$data.containsKey('subcallsAggregate') !=
        other._$data.containsKey('subcallsAggregate')) {
      return false;
    }
    if (l$subcallsAggregate != lOther$subcallsAggregate) {
      return false;
    }
    final l$success = success;
    final lOther$success = other.success;
    if (_$data.containsKey('success') != other._$data.containsKey('success')) {
      return false;
    }
    if (l$success != lOther$success) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$address = address;
    final l$args = args;
    final l$argsStr = argsStr;
    final l$block = block;
    final l$blockId = blockId;
    final l$error = error;
    final l$events = events;
    final l$eventsAggregate = eventsAggregate;
    final l$extrinsic = extrinsic;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$name = name;
    final l$pallet = pallet;
    final l$parent = parent;
    final l$parentId = parentId;
    final l$subcalls = subcalls;
    final l$subcallsAggregate = subcallsAggregate;
    final l$success = success;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('args') ? l$args : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('error') ? l$error : const {},
      _$data.containsKey('events') ? l$events : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('extrinsic') ? l$extrinsic : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('parent') ? l$parent : const {},
      _$data.containsKey('parentId') ? l$parentId : const {},
      _$data.containsKey('subcalls') ? l$subcalls : const {},
      _$data.containsKey('subcallsAggregate') ? l$subcallsAggregate : const {},
      _$data.containsKey('success') ? l$success : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallBoolExp<TRes> {
  factory CopyWith$Input$CallBoolExp(
    Input$CallBoolExp instance,
    TRes Function(Input$CallBoolExp) then,
  ) = _CopyWithImpl$Input$CallBoolExp;

  factory CopyWith$Input$CallBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CallBoolExp;

  TRes call({
    List<Input$CallBoolExp>? $_and,
    Input$CallBoolExp? $_not,
    List<Input$CallBoolExp>? $_or,
    Input$IntArrayComparisonExp? address,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$CallBoolExp? parent,
    Input$StringComparisonExp? parentId,
    Input$CallBoolExp? subcalls,
    Input$CallAggregateBoolExp? subcallsAggregate,
    Input$BooleanComparisonExp? success,
  });
  TRes $_and(
      Iterable<Input$CallBoolExp>? Function(
              Iterable<CopyWith$Input$CallBoolExp<Input$CallBoolExp>>?)
          _fn);
  CopyWith$Input$CallBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$CallBoolExp>? Function(
              Iterable<CopyWith$Input$CallBoolExp<Input$CallBoolExp>>?)
          _fn);
  CopyWith$Input$IntArrayComparisonExp<TRes> get address;
  CopyWith$Input$JsonbComparisonExp<TRes> get args;
  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr;
  CopyWith$Input$BlockBoolExp<TRes> get block;
  CopyWith$Input$StringComparisonExp<TRes> get blockId;
  CopyWith$Input$JsonbComparisonExp<TRes> get error;
  CopyWith$Input$EventBoolExp<TRes> get events;
  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate;
  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic;
  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$StringComparisonExp<TRes> get name;
  CopyWith$Input$StringComparisonExp<TRes> get pallet;
  CopyWith$Input$CallBoolExp<TRes> get parent;
  CopyWith$Input$StringComparisonExp<TRes> get parentId;
  CopyWith$Input$CallBoolExp<TRes> get subcalls;
  CopyWith$Input$CallAggregateBoolExp<TRes> get subcallsAggregate;
  CopyWith$Input$BooleanComparisonExp<TRes> get success;
}

class _CopyWithImpl$Input$CallBoolExp<TRes>
    implements CopyWith$Input$CallBoolExp<TRes> {
  _CopyWithImpl$Input$CallBoolExp(
    this._instance,
    this._then,
  );

  final Input$CallBoolExp _instance;

  final TRes Function(Input$CallBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? address = _undefined,
    Object? args = _undefined,
    Object? argsStr = _undefined,
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? error = _undefined,
    Object? events = _undefined,
    Object? eventsAggregate = _undefined,
    Object? extrinsic = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? parent = _undefined,
    Object? parentId = _undefined,
    Object? subcalls = _undefined,
    Object? subcallsAggregate = _undefined,
    Object? success = _undefined,
  }) =>
      _then(Input$CallBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<Input$CallBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$CallBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$CallBoolExp>?),
        if (address != _undefined)
          'address': (address as Input$IntArrayComparisonExp?),
        if (args != _undefined) 'args': (args as Input$JsonbComparisonExp?),
        if (argsStr != _undefined)
          'argsStr': (argsStr as Input$StringArrayComparisonExp?),
        if (block != _undefined) 'block': (block as Input$BlockBoolExp?),
        if (blockId != _undefined)
          'blockId': (blockId as Input$StringComparisonExp?),
        if (error != _undefined) 'error': (error as Input$JsonbComparisonExp?),
        if (events != _undefined) 'events': (events as Input$EventBoolExp?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateBoolExp?),
        if (extrinsic != _undefined)
          'extrinsic': (extrinsic as Input$ExtrinsicBoolExp?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Input$StringComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (name != _undefined) 'name': (name as Input$StringComparisonExp?),
        if (pallet != _undefined)
          'pallet': (pallet as Input$StringComparisonExp?),
        if (parent != _undefined) 'parent': (parent as Input$CallBoolExp?),
        if (parentId != _undefined)
          'parentId': (parentId as Input$StringComparisonExp?),
        if (subcalls != _undefined)
          'subcalls': (subcalls as Input$CallBoolExp?),
        if (subcallsAggregate != _undefined)
          'subcallsAggregate':
              (subcallsAggregate as Input$CallAggregateBoolExp?),
        if (success != _undefined)
          'success': (success as Input$BooleanComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$CallBoolExp>? Function(
                  Iterable<CopyWith$Input$CallBoolExp<Input$CallBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$CallBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$CallBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$CallBoolExp>? Function(
                  Iterable<CopyWith$Input$CallBoolExp<Input$CallBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$CallBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IntArrayComparisonExp<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$IntArrayComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntArrayComparisonExp(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$JsonbComparisonExp<TRes> get args {
    final local$args = _instance.args;
    return local$args == null
        ? CopyWith$Input$JsonbComparisonExp.stub(_then(_instance))
        : CopyWith$Input$JsonbComparisonExp(local$args, (e) => call(args: e));
  }

  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr {
    final local$argsStr = _instance.argsStr;
    return local$argsStr == null
        ? CopyWith$Input$StringArrayComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringArrayComparisonExp(
            local$argsStr, (e) => call(argsStr: e));
  }

  CopyWith$Input$BlockBoolExp<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockBoolExp.stub(_then(_instance))
        : CopyWith$Input$BlockBoolExp(local$block, (e) => call(block: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get blockId {
    final local$blockId = _instance.blockId;
    return local$blockId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$blockId, (e) => call(blockId: e));
  }

  CopyWith$Input$JsonbComparisonExp<TRes> get error {
    final local$error = _instance.error;
    return local$error == null
        ? CopyWith$Input$JsonbComparisonExp.stub(_then(_instance))
        : CopyWith$Input$JsonbComparisonExp(local$error, (e) => call(error: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get events {
    final local$events = _instance.events;
    return local$events == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$events, (e) => call(events: e));
  }

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventAggregateBoolExp(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic {
    final local$extrinsic = _instance.extrinsic;
    return local$extrinsic == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(
            local$extrinsic, (e) => call(extrinsic: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId {
    final local$extrinsicId = _instance.extrinsicId;
    return local$extrinsicId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$extrinsicId, (e) => call(extrinsicId: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get pallet {
    final local$pallet = _instance.pallet;
    return local$pallet == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$pallet, (e) => call(pallet: e));
  }

  CopyWith$Input$CallBoolExp<TRes> get parent {
    final local$parent = _instance.parent;
    return local$parent == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$parent, (e) => call(parent: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get parentId {
    final local$parentId = _instance.parentId;
    return local$parentId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$parentId, (e) => call(parentId: e));
  }

  CopyWith$Input$CallBoolExp<TRes> get subcalls {
    final local$subcalls = _instance.subcalls;
    return local$subcalls == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$subcalls, (e) => call(subcalls: e));
  }

  CopyWith$Input$CallAggregateBoolExp<TRes> get subcallsAggregate {
    final local$subcallsAggregate = _instance.subcallsAggregate;
    return local$subcallsAggregate == null
        ? CopyWith$Input$CallAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallAggregateBoolExp(
            local$subcallsAggregate, (e) => call(subcallsAggregate: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get success {
    final local$success = _instance.success;
    return local$success == null
        ? CopyWith$Input$BooleanComparisonExp.stub(_then(_instance))
        : CopyWith$Input$BooleanComparisonExp(
            local$success, (e) => call(success: e));
  }
}

class _CopyWithStubImpl$Input$CallBoolExp<TRes>
    implements CopyWith$Input$CallBoolExp<TRes> {
  _CopyWithStubImpl$Input$CallBoolExp(this._res);

  TRes _res;

  call({
    List<Input$CallBoolExp>? $_and,
    Input$CallBoolExp? $_not,
    List<Input$CallBoolExp>? $_or,
    Input$IntArrayComparisonExp? address,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$CallBoolExp? parent,
    Input$StringComparisonExp? parentId,
    Input$CallBoolExp? subcalls,
    Input$CallAggregateBoolExp? subcallsAggregate,
    Input$BooleanComparisonExp? success,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$CallBoolExp<TRes> get $_not =>
      CopyWith$Input$CallBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntArrayComparisonExp<TRes> get address =>
      CopyWith$Input$IntArrayComparisonExp.stub(_res);

  CopyWith$Input$JsonbComparisonExp<TRes> get args =>
      CopyWith$Input$JsonbComparisonExp.stub(_res);

  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr =>
      CopyWith$Input$StringArrayComparisonExp.stub(_res);

  CopyWith$Input$BlockBoolExp<TRes> get block =>
      CopyWith$Input$BlockBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get blockId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$JsonbComparisonExp<TRes> get error =>
      CopyWith$Input$JsonbComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get events =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateBoolExp.stub(_res);

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get name =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get pallet =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CallBoolExp<TRes> get parent =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get parentId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CallBoolExp<TRes> get subcalls =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$CallAggregateBoolExp<TRes> get subcallsAggregate =>
      CopyWith$Input$CallAggregateBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get success =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$CallMaxOrderBy {
  factory Input$CallMaxOrderBy({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  }) =>
      Input$CallMaxOrderBy._({
        if (address != null) r'address': address,
        if (argsStr != null) r'argsStr': argsStr,
        if (blockId != null) r'blockId': blockId,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (parentId != null) r'parentId': parentId,
      });

  Input$CallMaxOrderBy._(this._$data);

  factory Input$CallMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$OrderBy((l$address as String));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = l$parentId == null
          ? null
          : fromJson$Enum$OrderBy((l$parentId as String));
    }
    return Input$CallMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get address => (_$data['address'] as Enum$OrderBy?);

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Enum$OrderBy? get parentId => (_$data['parentId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$OrderBy(l$address);
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] =
          l$parentId == null ? null : toJson$Enum$OrderBy(l$parentId);
    }
    return result$data;
  }

  CopyWith$Input$CallMaxOrderBy<Input$CallMaxOrderBy> get copyWith =>
      CopyWith$Input$CallMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallMaxOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$address = address;
    final l$argsStr = argsStr;
    final l$blockId = blockId;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$name = name;
    final l$pallet = pallet;
    final l$parentId = parentId;
    return Object.hashAll([
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('parentId') ? l$parentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallMaxOrderBy<TRes> {
  factory CopyWith$Input$CallMaxOrderBy(
    Input$CallMaxOrderBy instance,
    TRes Function(Input$CallMaxOrderBy) then,
  ) = _CopyWithImpl$Input$CallMaxOrderBy;

  factory CopyWith$Input$CallMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CallMaxOrderBy;

  TRes call({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  });
}

class _CopyWithImpl$Input$CallMaxOrderBy<TRes>
    implements CopyWith$Input$CallMaxOrderBy<TRes> {
  _CopyWithImpl$Input$CallMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$CallMaxOrderBy _instance;

  final TRes Function(Input$CallMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? address = _undefined,
    Object? argsStr = _undefined,
    Object? blockId = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? parentId = _undefined,
  }) =>
      _then(Input$CallMaxOrderBy._({
        ..._instance._$data,
        if (address != _undefined) 'address': (address as Enum$OrderBy?),
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (parentId != _undefined) 'parentId': (parentId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CallMaxOrderBy<TRes>
    implements CopyWith$Input$CallMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$CallMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  }) =>
      _res;
}

class Input$CallMinOrderBy {
  factory Input$CallMinOrderBy({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  }) =>
      Input$CallMinOrderBy._({
        if (address != null) r'address': address,
        if (argsStr != null) r'argsStr': argsStr,
        if (blockId != null) r'blockId': blockId,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (parentId != null) r'parentId': parentId,
      });

  Input$CallMinOrderBy._(this._$data);

  factory Input$CallMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$OrderBy((l$address as String));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = l$parentId == null
          ? null
          : fromJson$Enum$OrderBy((l$parentId as String));
    }
    return Input$CallMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get address => (_$data['address'] as Enum$OrderBy?);

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Enum$OrderBy? get parentId => (_$data['parentId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$OrderBy(l$address);
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] =
          l$parentId == null ? null : toJson$Enum$OrderBy(l$parentId);
    }
    return result$data;
  }

  CopyWith$Input$CallMinOrderBy<Input$CallMinOrderBy> get copyWith =>
      CopyWith$Input$CallMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallMinOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$address = address;
    final l$argsStr = argsStr;
    final l$blockId = blockId;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$name = name;
    final l$pallet = pallet;
    final l$parentId = parentId;
    return Object.hashAll([
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('parentId') ? l$parentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallMinOrderBy<TRes> {
  factory CopyWith$Input$CallMinOrderBy(
    Input$CallMinOrderBy instance,
    TRes Function(Input$CallMinOrderBy) then,
  ) = _CopyWithImpl$Input$CallMinOrderBy;

  factory CopyWith$Input$CallMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CallMinOrderBy;

  TRes call({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  });
}

class _CopyWithImpl$Input$CallMinOrderBy<TRes>
    implements CopyWith$Input$CallMinOrderBy<TRes> {
  _CopyWithImpl$Input$CallMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$CallMinOrderBy _instance;

  final TRes Function(Input$CallMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? address = _undefined,
    Object? argsStr = _undefined,
    Object? blockId = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? parentId = _undefined,
  }) =>
      _then(Input$CallMinOrderBy._({
        ..._instance._$data,
        if (address != _undefined) 'address': (address as Enum$OrderBy?),
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (parentId != _undefined) 'parentId': (parentId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CallMinOrderBy<TRes>
    implements CopyWith$Input$CallMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$CallMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? address,
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? parentId,
  }) =>
      _res;
}

class Input$CallOrderBy {
  factory Input$CallOrderBy({
    Enum$OrderBy? address,
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Input$CallOrderBy? parent,
    Enum$OrderBy? parentId,
    Input$CallAggregateOrderBy? subcallsAggregate,
    Enum$OrderBy? success,
  }) =>
      Input$CallOrderBy._({
        if (address != null) r'address': address,
        if (args != null) r'args': args,
        if (argsStr != null) r'argsStr': argsStr,
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if (error != null) r'error': error,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (extrinsic != null) r'extrinsic': extrinsic,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (parent != null) r'parent': parent,
        if (parentId != null) r'parentId': parentId,
        if (subcallsAggregate != null) r'subcallsAggregate': subcallsAggregate,
        if (success != null) r'success': success,
      });

  Input$CallOrderBy._(this._$data);

  factory Input$CallOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$OrderBy((l$address as String));
    }
    if (data.containsKey('args')) {
      final l$args = data['args'];
      result$data['args'] =
          l$args == null ? null : fromJson$Enum$OrderBy((l$args as String));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockOrderBy.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('error')) {
      final l$error = data['error'];
      result$data['error'] =
          l$error == null ? null : fromJson$Enum$OrderBy((l$error as String));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateOrderBy.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsic')) {
      final l$extrinsic = data['extrinsic'];
      result$data['extrinsic'] = l$extrinsic == null
          ? null
          : Input$ExtrinsicOrderBy.fromJson(
              (l$extrinsic as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('parent')) {
      final l$parent = data['parent'];
      result$data['parent'] = l$parent == null
          ? null
          : Input$CallOrderBy.fromJson((l$parent as Map<String, dynamic>));
    }
    if (data.containsKey('parentId')) {
      final l$parentId = data['parentId'];
      result$data['parentId'] = l$parentId == null
          ? null
          : fromJson$Enum$OrderBy((l$parentId as String));
    }
    if (data.containsKey('subcallsAggregate')) {
      final l$subcallsAggregate = data['subcallsAggregate'];
      result$data['subcallsAggregate'] = l$subcallsAggregate == null
          ? null
          : Input$CallAggregateOrderBy.fromJson(
              (l$subcallsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('success')) {
      final l$success = data['success'];
      result$data['success'] = l$success == null
          ? null
          : fromJson$Enum$OrderBy((l$success as String));
    }
    return Input$CallOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get address => (_$data['address'] as Enum$OrderBy?);

  Enum$OrderBy? get args => (_$data['args'] as Enum$OrderBy?);

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Input$BlockOrderBy? get block => (_$data['block'] as Input$BlockOrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get error => (_$data['error'] as Enum$OrderBy?);

  Input$EventAggregateOrderBy? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateOrderBy?);

  Input$ExtrinsicOrderBy? get extrinsic =>
      (_$data['extrinsic'] as Input$ExtrinsicOrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Input$CallOrderBy? get parent => (_$data['parent'] as Input$CallOrderBy?);

  Enum$OrderBy? get parentId => (_$data['parentId'] as Enum$OrderBy?);

  Input$CallAggregateOrderBy? get subcallsAggregate =>
      (_$data['subcallsAggregate'] as Input$CallAggregateOrderBy?);

  Enum$OrderBy? get success => (_$data['success'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$OrderBy(l$address);
    }
    if (_$data.containsKey('args')) {
      final l$args = args;
      result$data['args'] = l$args == null ? null : toJson$Enum$OrderBy(l$args);
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('error')) {
      final l$error = error;
      result$data['error'] =
          l$error == null ? null : toJson$Enum$OrderBy(l$error);
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('extrinsic')) {
      final l$extrinsic = extrinsic;
      result$data['extrinsic'] = l$extrinsic?.toJson();
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('parent')) {
      final l$parent = parent;
      result$data['parent'] = l$parent?.toJson();
    }
    if (_$data.containsKey('parentId')) {
      final l$parentId = parentId;
      result$data['parentId'] =
          l$parentId == null ? null : toJson$Enum$OrderBy(l$parentId);
    }
    if (_$data.containsKey('subcallsAggregate')) {
      final l$subcallsAggregate = subcallsAggregate;
      result$data['subcallsAggregate'] = l$subcallsAggregate?.toJson();
    }
    if (_$data.containsKey('success')) {
      final l$success = success;
      result$data['success'] =
          l$success == null ? null : toJson$Enum$OrderBy(l$success);
    }
    return result$data;
  }

  CopyWith$Input$CallOrderBy<Input$CallOrderBy> get copyWith =>
      CopyWith$Input$CallOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CallOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$args = args;
    final lOther$args = other.args;
    if (_$data.containsKey('args') != other._$data.containsKey('args')) {
      return false;
    }
    if (l$args != lOther$args) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$error = error;
    final lOther$error = other.error;
    if (_$data.containsKey('error') != other._$data.containsKey('error')) {
      return false;
    }
    if (l$error != lOther$error) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$extrinsic = extrinsic;
    final lOther$extrinsic = other.extrinsic;
    if (_$data.containsKey('extrinsic') !=
        other._$data.containsKey('extrinsic')) {
      return false;
    }
    if (l$extrinsic != lOther$extrinsic) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$parent = parent;
    final lOther$parent = other.parent;
    if (_$data.containsKey('parent') != other._$data.containsKey('parent')) {
      return false;
    }
    if (l$parent != lOther$parent) {
      return false;
    }
    final l$parentId = parentId;
    final lOther$parentId = other.parentId;
    if (_$data.containsKey('parentId') !=
        other._$data.containsKey('parentId')) {
      return false;
    }
    if (l$parentId != lOther$parentId) {
      return false;
    }
    final l$subcallsAggregate = subcallsAggregate;
    final lOther$subcallsAggregate = other.subcallsAggregate;
    if (_$data.containsKey('subcallsAggregate') !=
        other._$data.containsKey('subcallsAggregate')) {
      return false;
    }
    if (l$subcallsAggregate != lOther$subcallsAggregate) {
      return false;
    }
    final l$success = success;
    final lOther$success = other.success;
    if (_$data.containsKey('success') != other._$data.containsKey('success')) {
      return false;
    }
    if (l$success != lOther$success) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$address = address;
    final l$args = args;
    final l$argsStr = argsStr;
    final l$block = block;
    final l$blockId = blockId;
    final l$error = error;
    final l$eventsAggregate = eventsAggregate;
    final l$extrinsic = extrinsic;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$name = name;
    final l$pallet = pallet;
    final l$parent = parent;
    final l$parentId = parentId;
    final l$subcallsAggregate = subcallsAggregate;
    final l$success = success;
    return Object.hashAll([
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('args') ? l$args : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('error') ? l$error : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('extrinsic') ? l$extrinsic : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('parent') ? l$parent : const {},
      _$data.containsKey('parentId') ? l$parentId : const {},
      _$data.containsKey('subcallsAggregate') ? l$subcallsAggregate : const {},
      _$data.containsKey('success') ? l$success : const {},
    ]);
  }
}

abstract class CopyWith$Input$CallOrderBy<TRes> {
  factory CopyWith$Input$CallOrderBy(
    Input$CallOrderBy instance,
    TRes Function(Input$CallOrderBy) then,
  ) = _CopyWithImpl$Input$CallOrderBy;

  factory CopyWith$Input$CallOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CallOrderBy;

  TRes call({
    Enum$OrderBy? address,
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Input$CallOrderBy? parent,
    Enum$OrderBy? parentId,
    Input$CallAggregateOrderBy? subcallsAggregate,
    Enum$OrderBy? success,
  });
  CopyWith$Input$BlockOrderBy<TRes> get block;
  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate;
  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic;
  CopyWith$Input$CallOrderBy<TRes> get parent;
  CopyWith$Input$CallAggregateOrderBy<TRes> get subcallsAggregate;
}

class _CopyWithImpl$Input$CallOrderBy<TRes>
    implements CopyWith$Input$CallOrderBy<TRes> {
  _CopyWithImpl$Input$CallOrderBy(
    this._instance,
    this._then,
  );

  final Input$CallOrderBy _instance;

  final TRes Function(Input$CallOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? address = _undefined,
    Object? args = _undefined,
    Object? argsStr = _undefined,
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? error = _undefined,
    Object? eventsAggregate = _undefined,
    Object? extrinsic = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? parent = _undefined,
    Object? parentId = _undefined,
    Object? subcallsAggregate = _undefined,
    Object? success = _undefined,
  }) =>
      _then(Input$CallOrderBy._({
        ..._instance._$data,
        if (address != _undefined) 'address': (address as Enum$OrderBy?),
        if (args != _undefined) 'args': (args as Enum$OrderBy?),
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (block != _undefined) 'block': (block as Input$BlockOrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (error != _undefined) 'error': (error as Enum$OrderBy?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateOrderBy?),
        if (extrinsic != _undefined)
          'extrinsic': (extrinsic as Input$ExtrinsicOrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (parent != _undefined) 'parent': (parent as Input$CallOrderBy?),
        if (parentId != _undefined) 'parentId': (parentId as Enum$OrderBy?),
        if (subcallsAggregate != _undefined)
          'subcallsAggregate':
              (subcallsAggregate as Input$CallAggregateOrderBy?),
        if (success != _undefined) 'success': (success as Enum$OrderBy?),
      }));

  CopyWith$Input$BlockOrderBy<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockOrderBy.stub(_then(_instance))
        : CopyWith$Input$BlockOrderBy(local$block, (e) => call(block: e));
  }

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventAggregateOrderBy(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }

  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic {
    final local$extrinsic = _instance.extrinsic;
    return local$extrinsic == null
        ? CopyWith$Input$ExtrinsicOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicOrderBy(
            local$extrinsic, (e) => call(extrinsic: e));
  }

  CopyWith$Input$CallOrderBy<TRes> get parent {
    final local$parent = _instance.parent;
    return local$parent == null
        ? CopyWith$Input$CallOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallOrderBy(local$parent, (e) => call(parent: e));
  }

  CopyWith$Input$CallAggregateOrderBy<TRes> get subcallsAggregate {
    final local$subcallsAggregate = _instance.subcallsAggregate;
    return local$subcallsAggregate == null
        ? CopyWith$Input$CallAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallAggregateOrderBy(
            local$subcallsAggregate, (e) => call(subcallsAggregate: e));
  }
}

class _CopyWithStubImpl$Input$CallOrderBy<TRes>
    implements CopyWith$Input$CallOrderBy<TRes> {
  _CopyWithStubImpl$Input$CallOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? address,
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Input$CallOrderBy? parent,
    Enum$OrderBy? parentId,
    Input$CallAggregateOrderBy? subcallsAggregate,
    Enum$OrderBy? success,
  }) =>
      _res;

  CopyWith$Input$BlockOrderBy<TRes> get block =>
      CopyWith$Input$BlockOrderBy.stub(_res);

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic =>
      CopyWith$Input$ExtrinsicOrderBy.stub(_res);

  CopyWith$Input$CallOrderBy<TRes> get parent =>
      CopyWith$Input$CallOrderBy.stub(_res);

  CopyWith$Input$CallAggregateOrderBy<TRes> get subcallsAggregate =>
      CopyWith$Input$CallAggregateOrderBy.stub(_res);
}

class Input$CertAggregateBoolExp {
  factory Input$CertAggregateBoolExp({
    Input$certAggregateBoolExpBool_and? bool_and,
    Input$certAggregateBoolExpBool_or? bool_or,
    Input$certAggregateBoolExpCount? count,
  }) =>
      Input$CertAggregateBoolExp._({
        if (bool_and != null) r'bool_and': bool_and,
        if (bool_or != null) r'bool_or': bool_or,
        if (count != null) r'count': count,
      });

  Input$CertAggregateBoolExp._(this._$data);

  factory Input$CertAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bool_and')) {
      final l$bool_and = data['bool_and'];
      result$data['bool_and'] = l$bool_and == null
          ? null
          : Input$certAggregateBoolExpBool_and.fromJson(
              (l$bool_and as Map<String, dynamic>));
    }
    if (data.containsKey('bool_or')) {
      final l$bool_or = data['bool_or'];
      result$data['bool_or'] = l$bool_or == null
          ? null
          : Input$certAggregateBoolExpBool_or.fromJson(
              (l$bool_or as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$certAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$CertAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$certAggregateBoolExpBool_and? get bool_and =>
      (_$data['bool_and'] as Input$certAggregateBoolExpBool_and?);

  Input$certAggregateBoolExpBool_or? get bool_or =>
      (_$data['bool_or'] as Input$certAggregateBoolExpBool_or?);

  Input$certAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$certAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bool_and')) {
      final l$bool_and = bool_and;
      result$data['bool_and'] = l$bool_and?.toJson();
    }
    if (_$data.containsKey('bool_or')) {
      final l$bool_or = bool_or;
      result$data['bool_or'] = l$bool_or?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertAggregateBoolExp<Input$CertAggregateBoolExp>
      get copyWith => CopyWith$Input$CertAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bool_and = bool_and;
    final lOther$bool_and = other.bool_and;
    if (_$data.containsKey('bool_and') !=
        other._$data.containsKey('bool_and')) {
      return false;
    }
    if (l$bool_and != lOther$bool_and) {
      return false;
    }
    final l$bool_or = bool_or;
    final lOther$bool_or = other.bool_or;
    if (_$data.containsKey('bool_or') != other._$data.containsKey('bool_or')) {
      return false;
    }
    if (l$bool_or != lOther$bool_or) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bool_and = bool_and;
    final l$bool_or = bool_or;
    final l$count = count;
    return Object.hashAll([
      _$data.containsKey('bool_and') ? l$bool_and : const {},
      _$data.containsKey('bool_or') ? l$bool_or : const {},
      _$data.containsKey('count') ? l$count : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertAggregateBoolExp<TRes> {
  factory CopyWith$Input$CertAggregateBoolExp(
    Input$CertAggregateBoolExp instance,
    TRes Function(Input$CertAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$CertAggregateBoolExp;

  factory CopyWith$Input$CertAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CertAggregateBoolExp;

  TRes call({
    Input$certAggregateBoolExpBool_and? bool_and,
    Input$certAggregateBoolExpBool_or? bool_or,
    Input$certAggregateBoolExpCount? count,
  });
  CopyWith$Input$certAggregateBoolExpBool_and<TRes> get bool_and;
  CopyWith$Input$certAggregateBoolExpBool_or<TRes> get bool_or;
  CopyWith$Input$certAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$CertAggregateBoolExp<TRes>
    implements CopyWith$Input$CertAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$CertAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$CertAggregateBoolExp _instance;

  final TRes Function(Input$CertAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bool_and = _undefined,
    Object? bool_or = _undefined,
    Object? count = _undefined,
  }) =>
      _then(Input$CertAggregateBoolExp._({
        ..._instance._$data,
        if (bool_and != _undefined)
          'bool_and': (bool_and as Input$certAggregateBoolExpBool_and?),
        if (bool_or != _undefined)
          'bool_or': (bool_or as Input$certAggregateBoolExpBool_or?),
        if (count != _undefined)
          'count': (count as Input$certAggregateBoolExpCount?),
      }));

  CopyWith$Input$certAggregateBoolExpBool_and<TRes> get bool_and {
    final local$bool_and = _instance.bool_and;
    return local$bool_and == null
        ? CopyWith$Input$certAggregateBoolExpBool_and.stub(_then(_instance))
        : CopyWith$Input$certAggregateBoolExpBool_and(
            local$bool_and, (e) => call(bool_and: e));
  }

  CopyWith$Input$certAggregateBoolExpBool_or<TRes> get bool_or {
    final local$bool_or = _instance.bool_or;
    return local$bool_or == null
        ? CopyWith$Input$certAggregateBoolExpBool_or.stub(_then(_instance))
        : CopyWith$Input$certAggregateBoolExpBool_or(
            local$bool_or, (e) => call(bool_or: e));
  }

  CopyWith$Input$certAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$certAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$certAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$CertAggregateBoolExp<TRes>
    implements CopyWith$Input$CertAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$CertAggregateBoolExp(this._res);

  TRes _res;

  call({
    Input$certAggregateBoolExpBool_and? bool_and,
    Input$certAggregateBoolExpBool_or? bool_or,
    Input$certAggregateBoolExpCount? count,
  }) =>
      _res;

  CopyWith$Input$certAggregateBoolExpBool_and<TRes> get bool_and =>
      CopyWith$Input$certAggregateBoolExpBool_and.stub(_res);

  CopyWith$Input$certAggregateBoolExpBool_or<TRes> get bool_or =>
      CopyWith$Input$certAggregateBoolExpBool_or.stub(_res);

  CopyWith$Input$certAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$certAggregateBoolExpCount.stub(_res);
}

class Input$certAggregateBoolExpBool_and {
  factory Input$certAggregateBoolExpBool_and({
    required Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
        arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$certAggregateBoolExpBool_and._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$certAggregateBoolExpBool_and._(this._$data);

  factory Input$certAggregateBoolExpBool_and.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CertBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$certAggregateBoolExpBool_and._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CertBoolExp? get filter => (_$data['filter'] as Input$CertBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$certAggregateBoolExpBool_and<
          Input$certAggregateBoolExpBool_and>
      get copyWith => CopyWith$Input$certAggregateBoolExpBool_and(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$certAggregateBoolExpBool_and) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$certAggregateBoolExpBool_and<TRes> {
  factory CopyWith$Input$certAggregateBoolExpBool_and(
    Input$certAggregateBoolExpBool_and instance,
    TRes Function(Input$certAggregateBoolExpBool_and) then,
  ) = _CopyWithImpl$Input$certAggregateBoolExpBool_and;

  factory CopyWith$Input$certAggregateBoolExpBool_and.stub(TRes res) =
      _CopyWithStubImpl$Input$certAggregateBoolExpBool_and;

  TRes call({
    Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$CertBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$certAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$certAggregateBoolExpBool_and<TRes> {
  _CopyWithImpl$Input$certAggregateBoolExpBool_and(
    this._instance,
    this._then,
  );

  final Input$certAggregateBoolExpBool_and _instance;

  final TRes Function(Input$certAggregateBoolExpBool_and) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$certAggregateBoolExpBool_and._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CertBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$CertBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$certAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$certAggregateBoolExpBool_and<TRes> {
  _CopyWithStubImpl$Input$certAggregateBoolExpBool_and(this._res);

  TRes _res;

  call({
    Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CertBoolExp<TRes> get filter =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$certAggregateBoolExpBool_or {
  factory Input$certAggregateBoolExpBool_or({
    required Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
        arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$certAggregateBoolExpBool_or._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$certAggregateBoolExpBool_or._(this._$data);

  factory Input$certAggregateBoolExpBool_or.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CertBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$certAggregateBoolExpBool_or._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CertBoolExp? get filter => (_$data['filter'] as Input$CertBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$certAggregateBoolExpBool_or<Input$certAggregateBoolExpBool_or>
      get copyWith => CopyWith$Input$certAggregateBoolExpBool_or(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$certAggregateBoolExpBool_or) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$certAggregateBoolExpBool_or<TRes> {
  factory CopyWith$Input$certAggregateBoolExpBool_or(
    Input$certAggregateBoolExpBool_or instance,
    TRes Function(Input$certAggregateBoolExpBool_or) then,
  ) = _CopyWithImpl$Input$certAggregateBoolExpBool_or;

  factory CopyWith$Input$certAggregateBoolExpBool_or.stub(TRes res) =
      _CopyWithStubImpl$Input$certAggregateBoolExpBool_or;

  TRes call({
    Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns? arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$CertBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$certAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$certAggregateBoolExpBool_or<TRes> {
  _CopyWithImpl$Input$certAggregateBoolExpBool_or(
    this._instance,
    this._then,
  );

  final Input$certAggregateBoolExpBool_or _instance;

  final TRes Function(Input$certAggregateBoolExpBool_or) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$certAggregateBoolExpBool_or._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CertBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$CertBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$certAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$certAggregateBoolExpBool_or<TRes> {
  _CopyWithStubImpl$Input$certAggregateBoolExpBool_or(this._res);

  TRes _res;

  call({
    Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns? arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CertBoolExp<TRes> get filter =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$certAggregateBoolExpCount {
  factory Input$certAggregateBoolExpCount({
    List<Enum$CertSelectColumn>? arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$certAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$certAggregateBoolExpCount._(this._$data);

  factory Input$certAggregateBoolExpCount.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CertSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CertBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$certAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$CertSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$CertSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CertBoolExp? get filter => (_$data['filter'] as Input$CertBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] =
          l$arguments?.map((e) => toJson$Enum$CertSelectColumn(e)).toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$certAggregateBoolExpCount<Input$certAggregateBoolExpCount>
      get copyWith => CopyWith$Input$certAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$certAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$certAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$certAggregateBoolExpCount(
    Input$certAggregateBoolExpCount instance,
    TRes Function(Input$certAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$certAggregateBoolExpCount;

  factory CopyWith$Input$certAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$certAggregateBoolExpCount;

  TRes call({
    List<Enum$CertSelectColumn>? arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$CertBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$certAggregateBoolExpCount<TRes>
    implements CopyWith$Input$certAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$certAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$certAggregateBoolExpCount _instance;

  final TRes Function(Input$certAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$certAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$CertSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CertBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$CertBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$certAggregateBoolExpCount<TRes>
    implements CopyWith$Input$certAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$certAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$CertSelectColumn>? arguments,
    bool? distinct,
    Input$CertBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CertBoolExp<TRes> get filter =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$CertAggregateOrderBy {
  factory Input$CertAggregateOrderBy({
    Input$CertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertMaxOrderBy? max,
    Input$CertMinOrderBy? min,
    Input$CertStddevOrderBy? stddev,
    Input$CertStddevPopOrderBy? stddevPop,
    Input$CertStddevSampOrderBy? stddevSamp,
    Input$CertSumOrderBy? sum,
    Input$CertVarPopOrderBy? varPop,
    Input$CertVarSampOrderBy? varSamp,
    Input$CertVarianceOrderBy? variance,
  }) =>
      Input$CertAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$CertAggregateOrderBy._(this._$data);

  factory Input$CertAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$CertAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$CertMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$CertMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$CertStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$CertStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$CertStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$CertSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$CertVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$CertVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$CertVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$CertAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CertAvgOrderBy? get avg => (_$data['avg'] as Input$CertAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$CertMaxOrderBy? get max => (_$data['max'] as Input$CertMaxOrderBy?);

  Input$CertMinOrderBy? get min => (_$data['min'] as Input$CertMinOrderBy?);

  Input$CertStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$CertStddevOrderBy?);

  Input$CertStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$CertStddevPopOrderBy?);

  Input$CertStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$CertStddevSampOrderBy?);

  Input$CertSumOrderBy? get sum => (_$data['sum'] as Input$CertSumOrderBy?);

  Input$CertVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$CertVarPopOrderBy?);

  Input$CertVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$CertVarSampOrderBy?);

  Input$CertVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$CertVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertAggregateOrderBy<Input$CertAggregateOrderBy>
      get copyWith => CopyWith$Input$CertAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertAggregateOrderBy<TRes> {
  factory CopyWith$Input$CertAggregateOrderBy(
    Input$CertAggregateOrderBy instance,
    TRes Function(Input$CertAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$CertAggregateOrderBy;

  factory CopyWith$Input$CertAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertAggregateOrderBy;

  TRes call({
    Input$CertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertMaxOrderBy? max,
    Input$CertMinOrderBy? min,
    Input$CertStddevOrderBy? stddev,
    Input$CertStddevPopOrderBy? stddevPop,
    Input$CertStddevSampOrderBy? stddevSamp,
    Input$CertSumOrderBy? sum,
    Input$CertVarPopOrderBy? varPop,
    Input$CertVarSampOrderBy? varSamp,
    Input$CertVarianceOrderBy? variance,
  });
  CopyWith$Input$CertAvgOrderBy<TRes> get avg;
  CopyWith$Input$CertMaxOrderBy<TRes> get max;
  CopyWith$Input$CertMinOrderBy<TRes> get min;
  CopyWith$Input$CertStddevOrderBy<TRes> get stddev;
  CopyWith$Input$CertStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$CertStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$CertSumOrderBy<TRes> get sum;
  CopyWith$Input$CertVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$CertVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$CertVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$CertAggregateOrderBy<TRes>
    implements CopyWith$Input$CertAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$CertAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertAggregateOrderBy _instance;

  final TRes Function(Input$CertAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$CertAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$CertAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$CertMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$CertMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$CertStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$CertStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$CertStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$CertSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$CertVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$CertVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$CertVarianceOrderBy?),
      }));

  CopyWith$Input$CertAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$CertAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$CertMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$CertMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$CertMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$CertMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$CertStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$CertStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$CertStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$CertStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$CertStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$CertStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$CertSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$CertSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$CertVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$CertVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$CertVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$CertVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$CertVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$CertVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$CertAggregateOrderBy<TRes>
    implements CopyWith$Input$CertAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$CertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertMaxOrderBy? max,
    Input$CertMinOrderBy? min,
    Input$CertStddevOrderBy? stddev,
    Input$CertStddevPopOrderBy? stddevPop,
    Input$CertStddevSampOrderBy? stddevSamp,
    Input$CertSumOrderBy? sum,
    Input$CertVarPopOrderBy? varPop,
    Input$CertVarSampOrderBy? varSamp,
    Input$CertVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$CertAvgOrderBy<TRes> get avg =>
      CopyWith$Input$CertAvgOrderBy.stub(_res);

  CopyWith$Input$CertMaxOrderBy<TRes> get max =>
      CopyWith$Input$CertMaxOrderBy.stub(_res);

  CopyWith$Input$CertMinOrderBy<TRes> get min =>
      CopyWith$Input$CertMinOrderBy.stub(_res);

  CopyWith$Input$CertStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$CertStddevOrderBy.stub(_res);

  CopyWith$Input$CertStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$CertStddevPopOrderBy.stub(_res);

  CopyWith$Input$CertStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$CertStddevSampOrderBy.stub(_res);

  CopyWith$Input$CertSumOrderBy<TRes> get sum =>
      CopyWith$Input$CertSumOrderBy.stub(_res);

  CopyWith$Input$CertVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$CertVarPopOrderBy.stub(_res);

  CopyWith$Input$CertVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$CertVarSampOrderBy.stub(_res);

  CopyWith$Input$CertVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$CertVarianceOrderBy.stub(_res);
}

class Input$CertAvgOrderBy {
  factory Input$CertAvgOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertAvgOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertAvgOrderBy._(this._$data);

  factory Input$CertAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertAvgOrderBy<Input$CertAvgOrderBy> get copyWith =>
      CopyWith$Input$CertAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertAvgOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertAvgOrderBy<TRes> {
  factory CopyWith$Input$CertAvgOrderBy(
    Input$CertAvgOrderBy instance,
    TRes Function(Input$CertAvgOrderBy) then,
  ) = _CopyWithImpl$Input$CertAvgOrderBy;

  factory CopyWith$Input$CertAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertAvgOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertAvgOrderBy<TRes>
    implements CopyWith$Input$CertAvgOrderBy<TRes> {
  _CopyWithImpl$Input$CertAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertAvgOrderBy _instance;

  final TRes Function(Input$CertAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertAvgOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertAvgOrderBy<TRes>
    implements CopyWith$Input$CertAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertAvgOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertBoolExp {
  factory Input$CertBoolExp({
    List<Input$CertBoolExp>? $_and,
    Input$CertBoolExp? $_not,
    List<Input$CertBoolExp>? $_or,
    Input$CertEventBoolExp? certHistory,
    Input$CertEventAggregateBoolExp? certHistoryAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$BooleanComparisonExp? isActive,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
    Input$EventBoolExp? updatedIn,
    Input$StringComparisonExp? updatedInId,
    Input$IntComparisonExp? updatedOn,
  }) =>
      Input$CertBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (certHistory != null) r'certHistory': certHistory,
        if (certHistoryAggregate != null)
          r'certHistoryAggregate': certHistoryAggregate,
        if (createdIn != null) r'createdIn': createdIn,
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (isActive != null) r'isActive': isActive,
        if (issuer != null) r'issuer': issuer,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiver != null) r'receiver': receiver,
        if (receiverId != null) r'receiverId': receiverId,
        if (updatedIn != null) r'updatedIn': updatedIn,
        if (updatedInId != null) r'updatedInId': updatedInId,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertBoolExp._(this._$data);

  factory Input$CertBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$CertBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$CertBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$CertBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('certHistory')) {
      final l$certHistory = data['certHistory'];
      result$data['certHistory'] = l$certHistory == null
          ? null
          : Input$CertEventBoolExp.fromJson(
              (l$certHistory as Map<String, dynamic>));
    }
    if (data.containsKey('certHistoryAggregate')) {
      final l$certHistoryAggregate = data['certHistoryAggregate'];
      result$data['certHistoryAggregate'] = l$certHistoryAggregate == null
          ? null
          : Input$CertEventAggregateBoolExp.fromJson(
              (l$certHistoryAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('createdIn')) {
      final l$createdIn = data['createdIn'];
      result$data['createdIn'] = l$createdIn == null
          ? null
          : Input$EventBoolExp.fromJson((l$createdIn as Map<String, dynamic>));
    }
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$createdInId as Map<String, dynamic>));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$createdOn as Map<String, dynamic>));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$expireOn as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : Input$BooleanComparisonExp.fromJson(
              (l$isActive as Map<String, dynamic>));
    }
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = l$issuer == null
          ? null
          : Input$IdentityBoolExp.fromJson((l$issuer as Map<String, dynamic>));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$issuerId as Map<String, dynamic>));
    }
    if (data.containsKey('receiver')) {
      final l$receiver = data['receiver'];
      result$data['receiver'] = l$receiver == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$receiver as Map<String, dynamic>));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$receiverId as Map<String, dynamic>));
    }
    if (data.containsKey('updatedIn')) {
      final l$updatedIn = data['updatedIn'];
      result$data['updatedIn'] = l$updatedIn == null
          ? null
          : Input$EventBoolExp.fromJson((l$updatedIn as Map<String, dynamic>));
    }
    if (data.containsKey('updatedInId')) {
      final l$updatedInId = data['updatedInId'];
      result$data['updatedInId'] = l$updatedInId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$updatedInId as Map<String, dynamic>));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$updatedOn as Map<String, dynamic>));
    }
    return Input$CertBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CertBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$CertBoolExp>?);

  Input$CertBoolExp? get $_not => (_$data['_not'] as Input$CertBoolExp?);

  List<Input$CertBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$CertBoolExp>?);

  Input$CertEventBoolExp? get certHistory =>
      (_$data['certHistory'] as Input$CertEventBoolExp?);

  Input$CertEventAggregateBoolExp? get certHistoryAggregate =>
      (_$data['certHistoryAggregate'] as Input$CertEventAggregateBoolExp?);

  Input$EventBoolExp? get createdIn =>
      (_$data['createdIn'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get createdInId =>
      (_$data['createdInId'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get createdOn =>
      (_$data['createdOn'] as Input$IntComparisonExp?);

  Input$IntComparisonExp? get expireOn =>
      (_$data['expireOn'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$BooleanComparisonExp? get isActive =>
      (_$data['isActive'] as Input$BooleanComparisonExp?);

  Input$IdentityBoolExp? get issuer =>
      (_$data['issuer'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get issuerId =>
      (_$data['issuerId'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get receiver =>
      (_$data['receiver'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get receiverId =>
      (_$data['receiverId'] as Input$StringComparisonExp?);

  Input$EventBoolExp? get updatedIn =>
      (_$data['updatedIn'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get updatedInId =>
      (_$data['updatedInId'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get updatedOn =>
      (_$data['updatedOn'] as Input$IntComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('certHistory')) {
      final l$certHistory = certHistory;
      result$data['certHistory'] = l$certHistory?.toJson();
    }
    if (_$data.containsKey('certHistoryAggregate')) {
      final l$certHistoryAggregate = certHistoryAggregate;
      result$data['certHistoryAggregate'] = l$certHistoryAggregate?.toJson();
    }
    if (_$data.containsKey('createdIn')) {
      final l$createdIn = createdIn;
      result$data['createdIn'] = l$createdIn?.toJson();
    }
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] = l$createdInId?.toJson();
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] = l$createdOn?.toJson();
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] = l$expireOn?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive?.toJson();
    }
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer?.toJson();
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] = l$issuerId?.toJson();
    }
    if (_$data.containsKey('receiver')) {
      final l$receiver = receiver;
      result$data['receiver'] = l$receiver?.toJson();
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] = l$receiverId?.toJson();
    }
    if (_$data.containsKey('updatedIn')) {
      final l$updatedIn = updatedIn;
      result$data['updatedIn'] = l$updatedIn?.toJson();
    }
    if (_$data.containsKey('updatedInId')) {
      final l$updatedInId = updatedInId;
      result$data['updatedInId'] = l$updatedInId?.toJson();
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] = l$updatedOn?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertBoolExp<Input$CertBoolExp> get copyWith =>
      CopyWith$Input$CertBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$certHistory = certHistory;
    final lOther$certHistory = other.certHistory;
    if (_$data.containsKey('certHistory') !=
        other._$data.containsKey('certHistory')) {
      return false;
    }
    if (l$certHistory != lOther$certHistory) {
      return false;
    }
    final l$certHistoryAggregate = certHistoryAggregate;
    final lOther$certHistoryAggregate = other.certHistoryAggregate;
    if (_$data.containsKey('certHistoryAggregate') !=
        other._$data.containsKey('certHistoryAggregate')) {
      return false;
    }
    if (l$certHistoryAggregate != lOther$certHistoryAggregate) {
      return false;
    }
    final l$createdIn = createdIn;
    final lOther$createdIn = other.createdIn;
    if (_$data.containsKey('createdIn') !=
        other._$data.containsKey('createdIn')) {
      return false;
    }
    if (l$createdIn != lOther$createdIn) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiver = receiver;
    final lOther$receiver = other.receiver;
    if (_$data.containsKey('receiver') !=
        other._$data.containsKey('receiver')) {
      return false;
    }
    if (l$receiver != lOther$receiver) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$updatedIn = updatedIn;
    final lOther$updatedIn = other.updatedIn;
    if (_$data.containsKey('updatedIn') !=
        other._$data.containsKey('updatedIn')) {
      return false;
    }
    if (l$updatedIn != lOther$updatedIn) {
      return false;
    }
    final l$updatedInId = updatedInId;
    final lOther$updatedInId = other.updatedInId;
    if (_$data.containsKey('updatedInId') !=
        other._$data.containsKey('updatedInId')) {
      return false;
    }
    if (l$updatedInId != lOther$updatedInId) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$certHistory = certHistory;
    final l$certHistoryAggregate = certHistoryAggregate;
    final l$createdIn = createdIn;
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$isActive = isActive;
    final l$issuer = issuer;
    final l$issuerId = issuerId;
    final l$receiver = receiver;
    final l$receiverId = receiverId;
    final l$updatedIn = updatedIn;
    final l$updatedInId = updatedInId;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('certHistory') ? l$certHistory : const {},
      _$data.containsKey('certHistoryAggregate')
          ? l$certHistoryAggregate
          : const {},
      _$data.containsKey('createdIn') ? l$createdIn : const {},
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('issuer') ? l$issuer : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiver') ? l$receiver : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('updatedIn') ? l$updatedIn : const {},
      _$data.containsKey('updatedInId') ? l$updatedInId : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertBoolExp<TRes> {
  factory CopyWith$Input$CertBoolExp(
    Input$CertBoolExp instance,
    TRes Function(Input$CertBoolExp) then,
  ) = _CopyWithImpl$Input$CertBoolExp;

  factory CopyWith$Input$CertBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CertBoolExp;

  TRes call({
    List<Input$CertBoolExp>? $_and,
    Input$CertBoolExp? $_not,
    List<Input$CertBoolExp>? $_or,
    Input$CertEventBoolExp? certHistory,
    Input$CertEventAggregateBoolExp? certHistoryAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$BooleanComparisonExp? isActive,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
    Input$EventBoolExp? updatedIn,
    Input$StringComparisonExp? updatedInId,
    Input$IntComparisonExp? updatedOn,
  });
  TRes $_and(
      Iterable<Input$CertBoolExp>? Function(
              Iterable<CopyWith$Input$CertBoolExp<Input$CertBoolExp>>?)
          _fn);
  CopyWith$Input$CertBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$CertBoolExp>? Function(
              Iterable<CopyWith$Input$CertBoolExp<Input$CertBoolExp>>?)
          _fn);
  CopyWith$Input$CertEventBoolExp<TRes> get certHistory;
  CopyWith$Input$CertEventAggregateBoolExp<TRes> get certHistoryAggregate;
  CopyWith$Input$EventBoolExp<TRes> get createdIn;
  CopyWith$Input$StringComparisonExp<TRes> get createdInId;
  CopyWith$Input$IntComparisonExp<TRes> get createdOn;
  CopyWith$Input$IntComparisonExp<TRes> get expireOn;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$BooleanComparisonExp<TRes> get isActive;
  CopyWith$Input$IdentityBoolExp<TRes> get issuer;
  CopyWith$Input$StringComparisonExp<TRes> get issuerId;
  CopyWith$Input$IdentityBoolExp<TRes> get receiver;
  CopyWith$Input$StringComparisonExp<TRes> get receiverId;
  CopyWith$Input$EventBoolExp<TRes> get updatedIn;
  CopyWith$Input$StringComparisonExp<TRes> get updatedInId;
  CopyWith$Input$IntComparisonExp<TRes> get updatedOn;
}

class _CopyWithImpl$Input$CertBoolExp<TRes>
    implements CopyWith$Input$CertBoolExp<TRes> {
  _CopyWithImpl$Input$CertBoolExp(
    this._instance,
    this._then,
  );

  final Input$CertBoolExp _instance;

  final TRes Function(Input$CertBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? certHistory = _undefined,
    Object? certHistoryAggregate = _undefined,
    Object? createdIn = _undefined,
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? isActive = _undefined,
    Object? issuer = _undefined,
    Object? issuerId = _undefined,
    Object? receiver = _undefined,
    Object? receiverId = _undefined,
    Object? updatedIn = _undefined,
    Object? updatedInId = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<Input$CertBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$CertBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$CertBoolExp>?),
        if (certHistory != _undefined)
          'certHistory': (certHistory as Input$CertEventBoolExp?),
        if (certHistoryAggregate != _undefined)
          'certHistoryAggregate':
              (certHistoryAggregate as Input$CertEventAggregateBoolExp?),
        if (createdIn != _undefined)
          'createdIn': (createdIn as Input$EventBoolExp?),
        if (createdInId != _undefined)
          'createdInId': (createdInId as Input$StringComparisonExp?),
        if (createdOn != _undefined)
          'createdOn': (createdOn as Input$IntComparisonExp?),
        if (expireOn != _undefined)
          'expireOn': (expireOn as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (isActive != _undefined)
          'isActive': (isActive as Input$BooleanComparisonExp?),
        if (issuer != _undefined) 'issuer': (issuer as Input$IdentityBoolExp?),
        if (issuerId != _undefined)
          'issuerId': (issuerId as Input$StringComparisonExp?),
        if (receiver != _undefined)
          'receiver': (receiver as Input$IdentityBoolExp?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Input$StringComparisonExp?),
        if (updatedIn != _undefined)
          'updatedIn': (updatedIn as Input$EventBoolExp?),
        if (updatedInId != _undefined)
          'updatedInId': (updatedInId as Input$StringComparisonExp?),
        if (updatedOn != _undefined)
          'updatedOn': (updatedOn as Input$IntComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$CertBoolExp>? Function(
                  Iterable<CopyWith$Input$CertBoolExp<Input$CertBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$CertBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$CertBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$CertBoolExp>? Function(
                  Iterable<CopyWith$Input$CertBoolExp<Input$CertBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$CertBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$CertEventBoolExp<TRes> get certHistory {
    final local$certHistory = _instance.certHistory;
    return local$certHistory == null
        ? CopyWith$Input$CertEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertEventBoolExp(
            local$certHistory, (e) => call(certHistory: e));
  }

  CopyWith$Input$CertEventAggregateBoolExp<TRes> get certHistoryAggregate {
    final local$certHistoryAggregate = _instance.certHistoryAggregate;
    return local$certHistoryAggregate == null
        ? CopyWith$Input$CertEventAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertEventAggregateBoolExp(
            local$certHistoryAggregate, (e) => call(certHistoryAggregate: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get createdIn {
    final local$createdIn = _instance.createdIn;
    return local$createdIn == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(
            local$createdIn, (e) => call(createdIn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get createdInId {
    final local$createdInId = _instance.createdInId;
    return local$createdInId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$createdInId, (e) => call(createdInId: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get createdOn {
    final local$createdOn = _instance.createdOn;
    return local$createdOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$createdOn, (e) => call(createdOn: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get expireOn {
    final local$expireOn = _instance.expireOn;
    return local$expireOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$expireOn, (e) => call(expireOn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get isActive {
    final local$isActive = _instance.isActive;
    return local$isActive == null
        ? CopyWith$Input$BooleanComparisonExp.stub(_then(_instance))
        : CopyWith$Input$BooleanComparisonExp(
            local$isActive, (e) => call(isActive: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get issuer {
    final local$issuer = _instance.issuer;
    return local$issuer == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(local$issuer, (e) => call(issuer: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get issuerId {
    final local$issuerId = _instance.issuerId;
    return local$issuerId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$issuerId, (e) => call(issuerId: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get receiver {
    final local$receiver = _instance.receiver;
    return local$receiver == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$receiver, (e) => call(receiver: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get receiverId {
    final local$receiverId = _instance.receiverId;
    return local$receiverId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$receiverId, (e) => call(receiverId: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get updatedIn {
    final local$updatedIn = _instance.updatedIn;
    return local$updatedIn == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(
            local$updatedIn, (e) => call(updatedIn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get updatedInId {
    final local$updatedInId = _instance.updatedInId;
    return local$updatedInId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$updatedInId, (e) => call(updatedInId: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get updatedOn {
    final local$updatedOn = _instance.updatedOn;
    return local$updatedOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$updatedOn, (e) => call(updatedOn: e));
  }
}

class _CopyWithStubImpl$Input$CertBoolExp<TRes>
    implements CopyWith$Input$CertBoolExp<TRes> {
  _CopyWithStubImpl$Input$CertBoolExp(this._res);

  TRes _res;

  call({
    List<Input$CertBoolExp>? $_and,
    Input$CertBoolExp? $_not,
    List<Input$CertBoolExp>? $_or,
    Input$CertEventBoolExp? certHistory,
    Input$CertEventAggregateBoolExp? certHistoryAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$BooleanComparisonExp? isActive,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
    Input$EventBoolExp? updatedIn,
    Input$StringComparisonExp? updatedInId,
    Input$IntComparisonExp? updatedOn,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$CertBoolExp<TRes> get $_not =>
      CopyWith$Input$CertBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$CertEventBoolExp<TRes> get certHistory =>
      CopyWith$Input$CertEventBoolExp.stub(_res);

  CopyWith$Input$CertEventAggregateBoolExp<TRes> get certHistoryAggregate =>
      CopyWith$Input$CertEventAggregateBoolExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get createdIn =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get createdInId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get createdOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get expireOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get isActive =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get issuer =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get issuerId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get receiver =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get receiverId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get updatedIn =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get updatedInId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get updatedOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$CertEventAggregateBoolExp {
  factory Input$CertEventAggregateBoolExp(
          {Input$certEventAggregateBoolExpCount? count}) =>
      Input$CertEventAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$CertEventAggregateBoolExp._(this._$data);

  factory Input$CertEventAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$certEventAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$CertEventAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$certEventAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$certEventAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertEventAggregateBoolExp<Input$CertEventAggregateBoolExp>
      get copyWith => CopyWith$Input$CertEventAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$CertEventAggregateBoolExp<TRes> {
  factory CopyWith$Input$CertEventAggregateBoolExp(
    Input$CertEventAggregateBoolExp instance,
    TRes Function(Input$CertEventAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$CertEventAggregateBoolExp;

  factory CopyWith$Input$CertEventAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventAggregateBoolExp;

  TRes call({Input$certEventAggregateBoolExpCount? count});
  CopyWith$Input$certEventAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$CertEventAggregateBoolExp<TRes>
    implements CopyWith$Input$CertEventAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$CertEventAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$CertEventAggregateBoolExp _instance;

  final TRes Function(Input$CertEventAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$CertEventAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$certEventAggregateBoolExpCount?),
      }));

  CopyWith$Input$certEventAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$certEventAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$certEventAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$CertEventAggregateBoolExp<TRes>
    implements CopyWith$Input$CertEventAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$CertEventAggregateBoolExp(this._res);

  TRes _res;

  call({Input$certEventAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$certEventAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$certEventAggregateBoolExpCount.stub(_res);
}

class Input$certEventAggregateBoolExpCount {
  factory Input$certEventAggregateBoolExpCount({
    List<Enum$CertEventSelectColumn>? arguments,
    bool? distinct,
    Input$CertEventBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$certEventAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$certEventAggregateBoolExpCount._(this._$data);

  factory Input$certEventAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CertEventSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$CertEventBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$certEventAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$CertEventSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$CertEventSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$CertEventBoolExp? get filter =>
      (_$data['filter'] as Input$CertEventBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] = l$arguments
          ?.map((e) => toJson$Enum$CertEventSelectColumn(e))
          .toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$certEventAggregateBoolExpCount<
          Input$certEventAggregateBoolExpCount>
      get copyWith => CopyWith$Input$certEventAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$certEventAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$certEventAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$certEventAggregateBoolExpCount(
    Input$certEventAggregateBoolExpCount instance,
    TRes Function(Input$certEventAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$certEventAggregateBoolExpCount;

  factory CopyWith$Input$certEventAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$certEventAggregateBoolExpCount;

  TRes call({
    List<Enum$CertEventSelectColumn>? arguments,
    bool? distinct,
    Input$CertEventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$CertEventBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$certEventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$certEventAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$certEventAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$certEventAggregateBoolExpCount _instance;

  final TRes Function(Input$certEventAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$certEventAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$CertEventSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$CertEventBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$CertEventBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$CertEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertEventBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$certEventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$certEventAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$certEventAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$CertEventSelectColumn>? arguments,
    bool? distinct,
    Input$CertEventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$CertEventBoolExp<TRes> get filter =>
      CopyWith$Input$CertEventBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$CertEventAggregateOrderBy {
  factory Input$CertEventAggregateOrderBy({
    Input$CertEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertEventMaxOrderBy? max,
    Input$CertEventMinOrderBy? min,
    Input$CertEventStddevOrderBy? stddev,
    Input$CertEventStddevPopOrderBy? stddevPop,
    Input$CertEventStddevSampOrderBy? stddevSamp,
    Input$CertEventSumOrderBy? sum,
    Input$CertEventVarPopOrderBy? varPop,
    Input$CertEventVarSampOrderBy? varSamp,
    Input$CertEventVarianceOrderBy? variance,
  }) =>
      Input$CertEventAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$CertEventAggregateOrderBy._(this._$data);

  factory Input$CertEventAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$CertEventAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$CertEventMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$CertEventMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$CertEventStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$CertEventStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$CertEventStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$CertEventSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$CertEventVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$CertEventVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$CertEventVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$CertEventAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CertEventAvgOrderBy? get avg =>
      (_$data['avg'] as Input$CertEventAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$CertEventMaxOrderBy? get max =>
      (_$data['max'] as Input$CertEventMaxOrderBy?);

  Input$CertEventMinOrderBy? get min =>
      (_$data['min'] as Input$CertEventMinOrderBy?);

  Input$CertEventStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$CertEventStddevOrderBy?);

  Input$CertEventStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$CertEventStddevPopOrderBy?);

  Input$CertEventStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$CertEventStddevSampOrderBy?);

  Input$CertEventSumOrderBy? get sum =>
      (_$data['sum'] as Input$CertEventSumOrderBy?);

  Input$CertEventVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$CertEventVarPopOrderBy?);

  Input$CertEventVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$CertEventVarSampOrderBy?);

  Input$CertEventVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$CertEventVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertEventAggregateOrderBy<Input$CertEventAggregateOrderBy>
      get copyWith => CopyWith$Input$CertEventAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertEventAggregateOrderBy<TRes> {
  factory CopyWith$Input$CertEventAggregateOrderBy(
    Input$CertEventAggregateOrderBy instance,
    TRes Function(Input$CertEventAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventAggregateOrderBy;

  factory CopyWith$Input$CertEventAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventAggregateOrderBy;

  TRes call({
    Input$CertEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertEventMaxOrderBy? max,
    Input$CertEventMinOrderBy? min,
    Input$CertEventStddevOrderBy? stddev,
    Input$CertEventStddevPopOrderBy? stddevPop,
    Input$CertEventStddevSampOrderBy? stddevSamp,
    Input$CertEventSumOrderBy? sum,
    Input$CertEventVarPopOrderBy? varPop,
    Input$CertEventVarSampOrderBy? varSamp,
    Input$CertEventVarianceOrderBy? variance,
  });
  CopyWith$Input$CertEventAvgOrderBy<TRes> get avg;
  CopyWith$Input$CertEventMaxOrderBy<TRes> get max;
  CopyWith$Input$CertEventMinOrderBy<TRes> get min;
  CopyWith$Input$CertEventStddevOrderBy<TRes> get stddev;
  CopyWith$Input$CertEventStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$CertEventStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$CertEventSumOrderBy<TRes> get sum;
  CopyWith$Input$CertEventVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$CertEventVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$CertEventVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$CertEventAggregateOrderBy<TRes>
    implements CopyWith$Input$CertEventAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventAggregateOrderBy _instance;

  final TRes Function(Input$CertEventAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$CertEventAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$CertEventAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$CertEventMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$CertEventMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$CertEventStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$CertEventStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$CertEventStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$CertEventSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$CertEventVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$CertEventVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$CertEventVarianceOrderBy?),
      }));

  CopyWith$Input$CertEventAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$CertEventAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$CertEventMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$CertEventMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$CertEventMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$CertEventMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$CertEventStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$CertEventStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$CertEventStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$CertEventStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$CertEventStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$CertEventStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$CertEventSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$CertEventSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$CertEventVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$CertEventVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$CertEventVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$CertEventVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$CertEventVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$CertEventVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$CertEventAggregateOrderBy<TRes>
    implements CopyWith$Input$CertEventAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$CertEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$CertEventMaxOrderBy? max,
    Input$CertEventMinOrderBy? min,
    Input$CertEventStddevOrderBy? stddev,
    Input$CertEventStddevPopOrderBy? stddevPop,
    Input$CertEventStddevSampOrderBy? stddevSamp,
    Input$CertEventSumOrderBy? sum,
    Input$CertEventVarPopOrderBy? varPop,
    Input$CertEventVarSampOrderBy? varSamp,
    Input$CertEventVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$CertEventAvgOrderBy<TRes> get avg =>
      CopyWith$Input$CertEventAvgOrderBy.stub(_res);

  CopyWith$Input$CertEventMaxOrderBy<TRes> get max =>
      CopyWith$Input$CertEventMaxOrderBy.stub(_res);

  CopyWith$Input$CertEventMinOrderBy<TRes> get min =>
      CopyWith$Input$CertEventMinOrderBy.stub(_res);

  CopyWith$Input$CertEventStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$CertEventStddevOrderBy.stub(_res);

  CopyWith$Input$CertEventStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$CertEventStddevPopOrderBy.stub(_res);

  CopyWith$Input$CertEventStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$CertEventStddevSampOrderBy.stub(_res);

  CopyWith$Input$CertEventSumOrderBy<TRes> get sum =>
      CopyWith$Input$CertEventSumOrderBy.stub(_res);

  CopyWith$Input$CertEventVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$CertEventVarPopOrderBy.stub(_res);

  CopyWith$Input$CertEventVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$CertEventVarSampOrderBy.stub(_res);

  CopyWith$Input$CertEventVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$CertEventVarianceOrderBy.stub(_res);
}

class Input$CertEventAvgOrderBy {
  factory Input$CertEventAvgOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventAvgOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventAvgOrderBy._(this._$data);

  factory Input$CertEventAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventAvgOrderBy<Input$CertEventAvgOrderBy> get copyWith =>
      CopyWith$Input$CertEventAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventAvgOrderBy<TRes> {
  factory CopyWith$Input$CertEventAvgOrderBy(
    Input$CertEventAvgOrderBy instance,
    TRes Function(Input$CertEventAvgOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventAvgOrderBy;

  factory CopyWith$Input$CertEventAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventAvgOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventAvgOrderBy<TRes>
    implements CopyWith$Input$CertEventAvgOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventAvgOrderBy _instance;

  final TRes Function(Input$CertEventAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventAvgOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventAvgOrderBy<TRes>
    implements CopyWith$Input$CertEventAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventAvgOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventBoolExp {
  factory Input$CertEventBoolExp({
    List<Input$CertEventBoolExp>? $_and,
    Input$CertEventBoolExp? $_not,
    List<Input$CertEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$CertBoolExp? cert,
    Input$StringComparisonExp? certId,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
  }) =>
      Input$CertEventBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (cert != null) r'cert': cert,
        if (certId != null) r'certId': certId,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (eventType != null) r'eventType': eventType,
        if (id != null) r'id': id,
      });

  Input$CertEventBoolExp._(this._$data);

  factory Input$CertEventBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$CertEventBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$CertEventBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$CertEventBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('cert')) {
      final l$cert = data['cert'];
      result$data['cert'] = l$cert == null
          ? null
          : Input$CertBoolExp.fromJson((l$cert as Map<String, dynamic>));
    }
    if (data.containsKey('certId')) {
      final l$certId = data['certId'];
      result$data['certId'] = l$certId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$certId as Map<String, dynamic>));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventBoolExp.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$eventId as Map<String, dynamic>));
    }
    if (data.containsKey('eventType')) {
      final l$eventType = data['eventType'];
      result$data['eventType'] = l$eventType == null
          ? null
          : Input$EventTypeEnumComparisonExp.fromJson(
              (l$eventType as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    return Input$CertEventBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CertEventBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$CertEventBoolExp>?);

  Input$CertEventBoolExp? get $_not =>
      (_$data['_not'] as Input$CertEventBoolExp?);

  List<Input$CertEventBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$CertEventBoolExp>?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$CertBoolExp? get cert => (_$data['cert'] as Input$CertBoolExp?);

  Input$StringComparisonExp? get certId =>
      (_$data['certId'] as Input$StringComparisonExp?);

  Input$EventBoolExp? get event => (_$data['event'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get eventId =>
      (_$data['eventId'] as Input$StringComparisonExp?);

  Input$EventTypeEnumComparisonExp? get eventType =>
      (_$data['eventType'] as Input$EventTypeEnumComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('cert')) {
      final l$cert = cert;
      result$data['cert'] = l$cert?.toJson();
    }
    if (_$data.containsKey('certId')) {
      final l$certId = certId;
      result$data['certId'] = l$certId?.toJson();
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] = l$eventId?.toJson();
    }
    if (_$data.containsKey('eventType')) {
      final l$eventType = eventType;
      result$data['eventType'] = l$eventType?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CertEventBoolExp<Input$CertEventBoolExp> get copyWith =>
      CopyWith$Input$CertEventBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$cert = cert;
    final lOther$cert = other.cert;
    if (_$data.containsKey('cert') != other._$data.containsKey('cert')) {
      return false;
    }
    if (l$cert != lOther$cert) {
      return false;
    }
    final l$certId = certId;
    final lOther$certId = other.certId;
    if (_$data.containsKey('certId') != other._$data.containsKey('certId')) {
      return false;
    }
    if (l$certId != lOther$certId) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$eventType = eventType;
    final lOther$eventType = other.eventType;
    if (_$data.containsKey('eventType') !=
        other._$data.containsKey('eventType')) {
      return false;
    }
    if (l$eventType != lOther$eventType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$blockNumber = blockNumber;
    final l$cert = cert;
    final l$certId = certId;
    final l$event = event;
    final l$eventId = eventId;
    final l$eventType = eventType;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('cert') ? l$cert : const {},
      _$data.containsKey('certId') ? l$certId : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('eventType') ? l$eventType : const {},
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertEventBoolExp<TRes> {
  factory CopyWith$Input$CertEventBoolExp(
    Input$CertEventBoolExp instance,
    TRes Function(Input$CertEventBoolExp) then,
  ) = _CopyWithImpl$Input$CertEventBoolExp;

  factory CopyWith$Input$CertEventBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventBoolExp;

  TRes call({
    List<Input$CertEventBoolExp>? $_and,
    Input$CertEventBoolExp? $_not,
    List<Input$CertEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$CertBoolExp? cert,
    Input$StringComparisonExp? certId,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
  });
  TRes $_and(
      Iterable<Input$CertEventBoolExp>? Function(
              Iterable<
                  CopyWith$Input$CertEventBoolExp<Input$CertEventBoolExp>>?)
          _fn);
  CopyWith$Input$CertEventBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$CertEventBoolExp>? Function(
              Iterable<
                  CopyWith$Input$CertEventBoolExp<Input$CertEventBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$CertBoolExp<TRes> get cert;
  CopyWith$Input$StringComparisonExp<TRes> get certId;
  CopyWith$Input$EventBoolExp<TRes> get event;
  CopyWith$Input$StringComparisonExp<TRes> get eventId;
  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType;
  CopyWith$Input$StringComparisonExp<TRes> get id;
}

class _CopyWithImpl$Input$CertEventBoolExp<TRes>
    implements CopyWith$Input$CertEventBoolExp<TRes> {
  _CopyWithImpl$Input$CertEventBoolExp(
    this._instance,
    this._then,
  );

  final Input$CertEventBoolExp _instance;

  final TRes Function(Input$CertEventBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? blockNumber = _undefined,
    Object? cert = _undefined,
    Object? certId = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? eventType = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$CertEventBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$CertEventBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$CertEventBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$CertEventBoolExp>?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (cert != _undefined) 'cert': (cert as Input$CertBoolExp?),
        if (certId != _undefined)
          'certId': (certId as Input$StringComparisonExp?),
        if (event != _undefined) 'event': (event as Input$EventBoolExp?),
        if (eventId != _undefined)
          'eventId': (eventId as Input$StringComparisonExp?),
        if (eventType != _undefined)
          'eventType': (eventType as Input$EventTypeEnumComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$CertEventBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$CertEventBoolExp<Input$CertEventBoolExp>>?)
              _fn) =>
      call(
          $_and:
              _fn(_instance.$_and?.map((e) => CopyWith$Input$CertEventBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$CertEventBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$CertEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertEventBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$CertEventBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$CertEventBoolExp<Input$CertEventBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$CertEventBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$CertBoolExp<TRes> get cert {
    final local$cert = _instance.cert;
    return local$cert == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(local$cert, (e) => call(cert: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get certId {
    final local$certId = _instance.certId;
    return local$certId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$certId, (e) => call(certId: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$event, (e) => call(event: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get eventId {
    final local$eventId = _instance.eventId;
    return local$eventId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$eventId, (e) => call(eventId: e));
  }

  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType {
    final local$eventType = _instance.eventType;
    return local$eventType == null
        ? CopyWith$Input$EventTypeEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$EventTypeEnumComparisonExp(
            local$eventType, (e) => call(eventType: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }
}

class _CopyWithStubImpl$Input$CertEventBoolExp<TRes>
    implements CopyWith$Input$CertEventBoolExp<TRes> {
  _CopyWithStubImpl$Input$CertEventBoolExp(this._res);

  TRes _res;

  call({
    List<Input$CertEventBoolExp>? $_and,
    Input$CertEventBoolExp? $_not,
    List<Input$CertEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$CertBoolExp? cert,
    Input$StringComparisonExp? certId,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$CertEventBoolExp<TRes> get $_not =>
      CopyWith$Input$CertEventBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$CertBoolExp<TRes> get cert =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get certId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get event =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get eventId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType =>
      CopyWith$Input$EventTypeEnumComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$CertEventMaxOrderBy {
  factory Input$CertEventMaxOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  }) =>
      Input$CertEventMaxOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (certId != null) r'certId': certId,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
      });

  Input$CertEventMaxOrderBy._(this._$data);

  factory Input$CertEventMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('certId')) {
      final l$certId = data['certId'];
      result$data['certId'] =
          l$certId == null ? null : fromJson$Enum$OrderBy((l$certId as String));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    return Input$CertEventMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get certId => (_$data['certId'] as Enum$OrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('certId')) {
      final l$certId = certId;
      result$data['certId'] =
          l$certId == null ? null : toJson$Enum$OrderBy(l$certId);
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    return result$data;
  }

  CopyWith$Input$CertEventMaxOrderBy<Input$CertEventMaxOrderBy> get copyWith =>
      CopyWith$Input$CertEventMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$certId = certId;
    final lOther$certId = other.certId;
    if (_$data.containsKey('certId') != other._$data.containsKey('certId')) {
      return false;
    }
    if (l$certId != lOther$certId) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$certId = certId;
    final l$eventId = eventId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('certId') ? l$certId : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertEventMaxOrderBy<TRes> {
  factory CopyWith$Input$CertEventMaxOrderBy(
    Input$CertEventMaxOrderBy instance,
    TRes Function(Input$CertEventMaxOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventMaxOrderBy;

  factory CopyWith$Input$CertEventMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventMaxOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  });
}

class _CopyWithImpl$Input$CertEventMaxOrderBy<TRes>
    implements CopyWith$Input$CertEventMaxOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventMaxOrderBy _instance;

  final TRes Function(Input$CertEventMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? certId = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$CertEventMaxOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (certId != _undefined) 'certId': (certId as Enum$OrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventMaxOrderBy<TRes>
    implements CopyWith$Input$CertEventMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  }) =>
      _res;
}

class Input$CertEventMinOrderBy {
  factory Input$CertEventMinOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  }) =>
      Input$CertEventMinOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (certId != null) r'certId': certId,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
      });

  Input$CertEventMinOrderBy._(this._$data);

  factory Input$CertEventMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('certId')) {
      final l$certId = data['certId'];
      result$data['certId'] =
          l$certId == null ? null : fromJson$Enum$OrderBy((l$certId as String));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    return Input$CertEventMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get certId => (_$data['certId'] as Enum$OrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('certId')) {
      final l$certId = certId;
      result$data['certId'] =
          l$certId == null ? null : toJson$Enum$OrderBy(l$certId);
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    return result$data;
  }

  CopyWith$Input$CertEventMinOrderBy<Input$CertEventMinOrderBy> get copyWith =>
      CopyWith$Input$CertEventMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$certId = certId;
    final lOther$certId = other.certId;
    if (_$data.containsKey('certId') != other._$data.containsKey('certId')) {
      return false;
    }
    if (l$certId != lOther$certId) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$certId = certId;
    final l$eventId = eventId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('certId') ? l$certId : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertEventMinOrderBy<TRes> {
  factory CopyWith$Input$CertEventMinOrderBy(
    Input$CertEventMinOrderBy instance,
    TRes Function(Input$CertEventMinOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventMinOrderBy;

  factory CopyWith$Input$CertEventMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventMinOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  });
}

class _CopyWithImpl$Input$CertEventMinOrderBy<TRes>
    implements CopyWith$Input$CertEventMinOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventMinOrderBy _instance;

  final TRes Function(Input$CertEventMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? certId = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$CertEventMinOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (certId != _undefined) 'certId': (certId as Enum$OrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventMinOrderBy<TRes>
    implements CopyWith$Input$CertEventMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? certId,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
  }) =>
      _res;
}

class Input$CertEventOrderBy {
  factory Input$CertEventOrderBy({
    Enum$OrderBy? blockNumber,
    Input$CertOrderBy? cert,
    Enum$OrderBy? certId,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
  }) =>
      Input$CertEventOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (cert != null) r'cert': cert,
        if (certId != null) r'certId': certId,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (eventType != null) r'eventType': eventType,
        if (id != null) r'id': id,
      });

  Input$CertEventOrderBy._(this._$data);

  factory Input$CertEventOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('cert')) {
      final l$cert = data['cert'];
      result$data['cert'] = l$cert == null
          ? null
          : Input$CertOrderBy.fromJson((l$cert as Map<String, dynamic>));
    }
    if (data.containsKey('certId')) {
      final l$certId = data['certId'];
      result$data['certId'] =
          l$certId == null ? null : fromJson$Enum$OrderBy((l$certId as String));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventOrderBy.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('eventType')) {
      final l$eventType = data['eventType'];
      result$data['eventType'] = l$eventType == null
          ? null
          : fromJson$Enum$OrderBy((l$eventType as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    return Input$CertEventOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Input$CertOrderBy? get cert => (_$data['cert'] as Input$CertOrderBy?);

  Enum$OrderBy? get certId => (_$data['certId'] as Enum$OrderBy?);

  Input$EventOrderBy? get event => (_$data['event'] as Input$EventOrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get eventType => (_$data['eventType'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('cert')) {
      final l$cert = cert;
      result$data['cert'] = l$cert?.toJson();
    }
    if (_$data.containsKey('certId')) {
      final l$certId = certId;
      result$data['certId'] =
          l$certId == null ? null : toJson$Enum$OrderBy(l$certId);
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('eventType')) {
      final l$eventType = eventType;
      result$data['eventType'] =
          l$eventType == null ? null : toJson$Enum$OrderBy(l$eventType);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    return result$data;
  }

  CopyWith$Input$CertEventOrderBy<Input$CertEventOrderBy> get copyWith =>
      CopyWith$Input$CertEventOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$cert = cert;
    final lOther$cert = other.cert;
    if (_$data.containsKey('cert') != other._$data.containsKey('cert')) {
      return false;
    }
    if (l$cert != lOther$cert) {
      return false;
    }
    final l$certId = certId;
    final lOther$certId = other.certId;
    if (_$data.containsKey('certId') != other._$data.containsKey('certId')) {
      return false;
    }
    if (l$certId != lOther$certId) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$eventType = eventType;
    final lOther$eventType = other.eventType;
    if (_$data.containsKey('eventType') !=
        other._$data.containsKey('eventType')) {
      return false;
    }
    if (l$eventType != lOther$eventType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$cert = cert;
    final l$certId = certId;
    final l$event = event;
    final l$eventId = eventId;
    final l$eventType = eventType;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('cert') ? l$cert : const {},
      _$data.containsKey('certId') ? l$certId : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('eventType') ? l$eventType : const {},
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertEventOrderBy<TRes> {
  factory CopyWith$Input$CertEventOrderBy(
    Input$CertEventOrderBy instance,
    TRes Function(Input$CertEventOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventOrderBy;

  factory CopyWith$Input$CertEventOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Input$CertOrderBy? cert,
    Enum$OrderBy? certId,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
  });
  CopyWith$Input$CertOrderBy<TRes> get cert;
  CopyWith$Input$EventOrderBy<TRes> get event;
}

class _CopyWithImpl$Input$CertEventOrderBy<TRes>
    implements CopyWith$Input$CertEventOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventOrderBy _instance;

  final TRes Function(Input$CertEventOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? cert = _undefined,
    Object? certId = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? eventType = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$CertEventOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (cert != _undefined) 'cert': (cert as Input$CertOrderBy?),
        if (certId != _undefined) 'certId': (certId as Enum$OrderBy?),
        if (event != _undefined) 'event': (event as Input$EventOrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (eventType != _undefined) 'eventType': (eventType as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
      }));

  CopyWith$Input$CertOrderBy<TRes> get cert {
    final local$cert = _instance.cert;
    return local$cert == null
        ? CopyWith$Input$CertOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertOrderBy(local$cert, (e) => call(cert: e));
  }

  CopyWith$Input$EventOrderBy<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(local$event, (e) => call(event: e));
  }
}

class _CopyWithStubImpl$Input$CertEventOrderBy<TRes>
    implements CopyWith$Input$CertEventOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Input$CertOrderBy? cert,
    Enum$OrderBy? certId,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
  }) =>
      _res;

  CopyWith$Input$CertOrderBy<TRes> get cert =>
      CopyWith$Input$CertOrderBy.stub(_res);

  CopyWith$Input$EventOrderBy<TRes> get event =>
      CopyWith$Input$EventOrderBy.stub(_res);
}

class Input$CertEventStddevOrderBy {
  factory Input$CertEventStddevOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventStddevOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventStddevOrderBy._(this._$data);

  factory Input$CertEventStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventStddevOrderBy<Input$CertEventStddevOrderBy>
      get copyWith => CopyWith$Input$CertEventStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventStddevOrderBy<TRes> {
  factory CopyWith$Input$CertEventStddevOrderBy(
    Input$CertEventStddevOrderBy instance,
    TRes Function(Input$CertEventStddevOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventStddevOrderBy;

  factory CopyWith$Input$CertEventStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventStddevOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventStddevOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventStddevOrderBy _instance;

  final TRes Function(Input$CertEventStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventStddevOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventStddevOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventStddevOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventStddevPopOrderBy {
  factory Input$CertEventStddevPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventStddevPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventStddevPopOrderBy._(this._$data);

  factory Input$CertEventStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventStddevPopOrderBy<Input$CertEventStddevPopOrderBy>
      get copyWith => CopyWith$Input$CertEventStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventStddevPopOrderBy<TRes> {
  factory CopyWith$Input$CertEventStddevPopOrderBy(
    Input$CertEventStddevPopOrderBy instance,
    TRes Function(Input$CertEventStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventStddevPopOrderBy;

  factory CopyWith$Input$CertEventStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventStddevPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventStddevPopOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventStddevPopOrderBy _instance;

  final TRes Function(Input$CertEventStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventStddevPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventStddevPopOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventStddevPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventStddevSampOrderBy {
  factory Input$CertEventStddevSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventStddevSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventStddevSampOrderBy._(this._$data);

  factory Input$CertEventStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventStddevSampOrderBy<Input$CertEventStddevSampOrderBy>
      get copyWith => CopyWith$Input$CertEventStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventStddevSampOrderBy<TRes> {
  factory CopyWith$Input$CertEventStddevSampOrderBy(
    Input$CertEventStddevSampOrderBy instance,
    TRes Function(Input$CertEventStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventStddevSampOrderBy;

  factory CopyWith$Input$CertEventStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventStddevSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventStddevSampOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventStddevSampOrderBy _instance;

  final TRes Function(Input$CertEventStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventStddevSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventStddevSampOrderBy<TRes>
    implements CopyWith$Input$CertEventStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventStddevSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventSumOrderBy {
  factory Input$CertEventSumOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventSumOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventSumOrderBy._(this._$data);

  factory Input$CertEventSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventSumOrderBy<Input$CertEventSumOrderBy> get copyWith =>
      CopyWith$Input$CertEventSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventSumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventSumOrderBy<TRes> {
  factory CopyWith$Input$CertEventSumOrderBy(
    Input$CertEventSumOrderBy instance,
    TRes Function(Input$CertEventSumOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventSumOrderBy;

  factory CopyWith$Input$CertEventSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventSumOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventSumOrderBy<TRes>
    implements CopyWith$Input$CertEventSumOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventSumOrderBy _instance;

  final TRes Function(Input$CertEventSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventSumOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventSumOrderBy<TRes>
    implements CopyWith$Input$CertEventSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventSumOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventVarianceOrderBy {
  factory Input$CertEventVarianceOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventVarianceOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventVarianceOrderBy._(this._$data);

  factory Input$CertEventVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventVarianceOrderBy<Input$CertEventVarianceOrderBy>
      get copyWith => CopyWith$Input$CertEventVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventVarianceOrderBy<TRes> {
  factory CopyWith$Input$CertEventVarianceOrderBy(
    Input$CertEventVarianceOrderBy instance,
    TRes Function(Input$CertEventVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventVarianceOrderBy;

  factory CopyWith$Input$CertEventVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventVarianceOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventVarianceOrderBy<TRes>
    implements CopyWith$Input$CertEventVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventVarianceOrderBy _instance;

  final TRes Function(Input$CertEventVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventVarianceOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventVarianceOrderBy<TRes>
    implements CopyWith$Input$CertEventVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventVarianceOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventVarPopOrderBy {
  factory Input$CertEventVarPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventVarPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventVarPopOrderBy._(this._$data);

  factory Input$CertEventVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventVarPopOrderBy<Input$CertEventVarPopOrderBy>
      get copyWith => CopyWith$Input$CertEventVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventVarPopOrderBy<TRes> {
  factory CopyWith$Input$CertEventVarPopOrderBy(
    Input$CertEventVarPopOrderBy instance,
    TRes Function(Input$CertEventVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventVarPopOrderBy;

  factory CopyWith$Input$CertEventVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventVarPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventVarPopOrderBy<TRes>
    implements CopyWith$Input$CertEventVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventVarPopOrderBy _instance;

  final TRes Function(Input$CertEventVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventVarPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventVarPopOrderBy<TRes>
    implements CopyWith$Input$CertEventVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventVarPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertEventVarSampOrderBy {
  factory Input$CertEventVarSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$CertEventVarSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$CertEventVarSampOrderBy._(this._$data);

  factory Input$CertEventVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$CertEventVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$CertEventVarSampOrderBy<Input$CertEventVarSampOrderBy>
      get copyWith => CopyWith$Input$CertEventVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertEventVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$CertEventVarSampOrderBy<TRes> {
  factory CopyWith$Input$CertEventVarSampOrderBy(
    Input$CertEventVarSampOrderBy instance,
    TRes Function(Input$CertEventVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$CertEventVarSampOrderBy;

  factory CopyWith$Input$CertEventVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertEventVarSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$CertEventVarSampOrderBy<TRes>
    implements CopyWith$Input$CertEventVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$CertEventVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertEventVarSampOrderBy _instance;

  final TRes Function(Input$CertEventVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$CertEventVarSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertEventVarSampOrderBy<TRes>
    implements CopyWith$Input$CertEventVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertEventVarSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CertMaxOrderBy {
  factory Input$CertMaxOrderBy({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertMaxOrderBy._({
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiverId != null) r'receiverId': receiverId,
        if (updatedInId != null) r'updatedInId': updatedInId,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertMaxOrderBy._(this._$data);

  factory Input$CertMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : fromJson$Enum$OrderBy((l$createdInId as String));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    if (data.containsKey('updatedInId')) {
      final l$updatedInId = data['updatedInId'];
      result$data['updatedInId'] = l$updatedInId == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedInId as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdInId => (_$data['createdInId'] as Enum$OrderBy?);

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedInId => (_$data['updatedInId'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] =
          l$createdInId == null ? null : toJson$Enum$OrderBy(l$createdInId);
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    if (_$data.containsKey('updatedInId')) {
      final l$updatedInId = updatedInId;
      result$data['updatedInId'] =
          l$updatedInId == null ? null : toJson$Enum$OrderBy(l$updatedInId);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertMaxOrderBy<Input$CertMaxOrderBy> get copyWith =>
      CopyWith$Input$CertMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertMaxOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$updatedInId = updatedInId;
    final lOther$updatedInId = other.updatedInId;
    if (_$data.containsKey('updatedInId') !=
        other._$data.containsKey('updatedInId')) {
      return false;
    }
    if (l$updatedInId != lOther$updatedInId) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$issuerId = issuerId;
    final l$receiverId = receiverId;
    final l$updatedInId = updatedInId;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('updatedInId') ? l$updatedInId : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertMaxOrderBy<TRes> {
  factory CopyWith$Input$CertMaxOrderBy(
    Input$CertMaxOrderBy instance,
    TRes Function(Input$CertMaxOrderBy) then,
  ) = _CopyWithImpl$Input$CertMaxOrderBy;

  factory CopyWith$Input$CertMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertMaxOrderBy;

  TRes call({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertMaxOrderBy<TRes>
    implements CopyWith$Input$CertMaxOrderBy<TRes> {
  _CopyWithImpl$Input$CertMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertMaxOrderBy _instance;

  final TRes Function(Input$CertMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? issuerId = _undefined,
    Object? receiverId = _undefined,
    Object? updatedInId = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertMaxOrderBy._({
        ..._instance._$data,
        if (createdInId != _undefined)
          'createdInId': (createdInId as Enum$OrderBy?),
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
        if (updatedInId != _undefined)
          'updatedInId': (updatedInId as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertMaxOrderBy<TRes>
    implements CopyWith$Input$CertMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertMinOrderBy {
  factory Input$CertMinOrderBy({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertMinOrderBy._({
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiverId != null) r'receiverId': receiverId,
        if (updatedInId != null) r'updatedInId': updatedInId,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertMinOrderBy._(this._$data);

  factory Input$CertMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : fromJson$Enum$OrderBy((l$createdInId as String));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    if (data.containsKey('updatedInId')) {
      final l$updatedInId = data['updatedInId'];
      result$data['updatedInId'] = l$updatedInId == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedInId as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdInId => (_$data['createdInId'] as Enum$OrderBy?);

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedInId => (_$data['updatedInId'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] =
          l$createdInId == null ? null : toJson$Enum$OrderBy(l$createdInId);
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    if (_$data.containsKey('updatedInId')) {
      final l$updatedInId = updatedInId;
      result$data['updatedInId'] =
          l$updatedInId == null ? null : toJson$Enum$OrderBy(l$updatedInId);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertMinOrderBy<Input$CertMinOrderBy> get copyWith =>
      CopyWith$Input$CertMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertMinOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$updatedInId = updatedInId;
    final lOther$updatedInId = other.updatedInId;
    if (_$data.containsKey('updatedInId') !=
        other._$data.containsKey('updatedInId')) {
      return false;
    }
    if (l$updatedInId != lOther$updatedInId) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$issuerId = issuerId;
    final l$receiverId = receiverId;
    final l$updatedInId = updatedInId;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('updatedInId') ? l$updatedInId : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertMinOrderBy<TRes> {
  factory CopyWith$Input$CertMinOrderBy(
    Input$CertMinOrderBy instance,
    TRes Function(Input$CertMinOrderBy) then,
  ) = _CopyWithImpl$Input$CertMinOrderBy;

  factory CopyWith$Input$CertMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertMinOrderBy;

  TRes call({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertMinOrderBy<TRes>
    implements CopyWith$Input$CertMinOrderBy<TRes> {
  _CopyWithImpl$Input$CertMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertMinOrderBy _instance;

  final TRes Function(Input$CertMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? issuerId = _undefined,
    Object? receiverId = _undefined,
    Object? updatedInId = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertMinOrderBy._({
        ..._instance._$data,
        if (createdInId != _undefined)
          'createdInId': (createdInId as Enum$OrderBy?),
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
        if (updatedInId != _undefined)
          'updatedInId': (updatedInId as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertMinOrderBy<TRes>
    implements CopyWith$Input$CertMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertOrderBy {
  factory Input$CertOrderBy({
    Input$CertEventAggregateOrderBy? certHistoryAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? isActive,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
    Input$EventOrderBy? updatedIn,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertOrderBy._({
        if (certHistoryAggregate != null)
          r'certHistoryAggregate': certHistoryAggregate,
        if (createdIn != null) r'createdIn': createdIn,
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (isActive != null) r'isActive': isActive,
        if (issuer != null) r'issuer': issuer,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiver != null) r'receiver': receiver,
        if (receiverId != null) r'receiverId': receiverId,
        if (updatedIn != null) r'updatedIn': updatedIn,
        if (updatedInId != null) r'updatedInId': updatedInId,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertOrderBy._(this._$data);

  factory Input$CertOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('certHistoryAggregate')) {
      final l$certHistoryAggregate = data['certHistoryAggregate'];
      result$data['certHistoryAggregate'] = l$certHistoryAggregate == null
          ? null
          : Input$CertEventAggregateOrderBy.fromJson(
              (l$certHistoryAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('createdIn')) {
      final l$createdIn = data['createdIn'];
      result$data['createdIn'] = l$createdIn == null
          ? null
          : Input$EventOrderBy.fromJson((l$createdIn as Map<String, dynamic>));
    }
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : fromJson$Enum$OrderBy((l$createdInId as String));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : fromJson$Enum$OrderBy((l$isActive as String));
    }
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = l$issuer == null
          ? null
          : Input$IdentityOrderBy.fromJson((l$issuer as Map<String, dynamic>));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiver')) {
      final l$receiver = data['receiver'];
      result$data['receiver'] = l$receiver == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$receiver as Map<String, dynamic>));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    if (data.containsKey('updatedIn')) {
      final l$updatedIn = data['updatedIn'];
      result$data['updatedIn'] = l$updatedIn == null
          ? null
          : Input$EventOrderBy.fromJson((l$updatedIn as Map<String, dynamic>));
    }
    if (data.containsKey('updatedInId')) {
      final l$updatedInId = data['updatedInId'];
      result$data['updatedInId'] = l$updatedInId == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedInId as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CertEventAggregateOrderBy? get certHistoryAggregate =>
      (_$data['certHistoryAggregate'] as Input$CertEventAggregateOrderBy?);

  Input$EventOrderBy? get createdIn =>
      (_$data['createdIn'] as Input$EventOrderBy?);

  Enum$OrderBy? get createdInId => (_$data['createdInId'] as Enum$OrderBy?);

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get isActive => (_$data['isActive'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get issuer =>
      (_$data['issuer'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get receiver =>
      (_$data['receiver'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Input$EventOrderBy? get updatedIn =>
      (_$data['updatedIn'] as Input$EventOrderBy?);

  Enum$OrderBy? get updatedInId => (_$data['updatedInId'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('certHistoryAggregate')) {
      final l$certHistoryAggregate = certHistoryAggregate;
      result$data['certHistoryAggregate'] = l$certHistoryAggregate?.toJson();
    }
    if (_$data.containsKey('createdIn')) {
      final l$createdIn = createdIn;
      result$data['createdIn'] = l$createdIn?.toJson();
    }
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] =
          l$createdInId == null ? null : toJson$Enum$OrderBy(l$createdInId);
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] =
          l$isActive == null ? null : toJson$Enum$OrderBy(l$isActive);
    }
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer?.toJson();
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiver')) {
      final l$receiver = receiver;
      result$data['receiver'] = l$receiver?.toJson();
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    if (_$data.containsKey('updatedIn')) {
      final l$updatedIn = updatedIn;
      result$data['updatedIn'] = l$updatedIn?.toJson();
    }
    if (_$data.containsKey('updatedInId')) {
      final l$updatedInId = updatedInId;
      result$data['updatedInId'] =
          l$updatedInId == null ? null : toJson$Enum$OrderBy(l$updatedInId);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertOrderBy<Input$CertOrderBy> get copyWith =>
      CopyWith$Input$CertOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$certHistoryAggregate = certHistoryAggregate;
    final lOther$certHistoryAggregate = other.certHistoryAggregate;
    if (_$data.containsKey('certHistoryAggregate') !=
        other._$data.containsKey('certHistoryAggregate')) {
      return false;
    }
    if (l$certHistoryAggregate != lOther$certHistoryAggregate) {
      return false;
    }
    final l$createdIn = createdIn;
    final lOther$createdIn = other.createdIn;
    if (_$data.containsKey('createdIn') !=
        other._$data.containsKey('createdIn')) {
      return false;
    }
    if (l$createdIn != lOther$createdIn) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiver = receiver;
    final lOther$receiver = other.receiver;
    if (_$data.containsKey('receiver') !=
        other._$data.containsKey('receiver')) {
      return false;
    }
    if (l$receiver != lOther$receiver) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$updatedIn = updatedIn;
    final lOther$updatedIn = other.updatedIn;
    if (_$data.containsKey('updatedIn') !=
        other._$data.containsKey('updatedIn')) {
      return false;
    }
    if (l$updatedIn != lOther$updatedIn) {
      return false;
    }
    final l$updatedInId = updatedInId;
    final lOther$updatedInId = other.updatedInId;
    if (_$data.containsKey('updatedInId') !=
        other._$data.containsKey('updatedInId')) {
      return false;
    }
    if (l$updatedInId != lOther$updatedInId) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$certHistoryAggregate = certHistoryAggregate;
    final l$createdIn = createdIn;
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$isActive = isActive;
    final l$issuer = issuer;
    final l$issuerId = issuerId;
    final l$receiver = receiver;
    final l$receiverId = receiverId;
    final l$updatedIn = updatedIn;
    final l$updatedInId = updatedInId;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('certHistoryAggregate')
          ? l$certHistoryAggregate
          : const {},
      _$data.containsKey('createdIn') ? l$createdIn : const {},
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('issuer') ? l$issuer : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiver') ? l$receiver : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('updatedIn') ? l$updatedIn : const {},
      _$data.containsKey('updatedInId') ? l$updatedInId : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertOrderBy<TRes> {
  factory CopyWith$Input$CertOrderBy(
    Input$CertOrderBy instance,
    TRes Function(Input$CertOrderBy) then,
  ) = _CopyWithImpl$Input$CertOrderBy;

  factory CopyWith$Input$CertOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertOrderBy;

  TRes call({
    Input$CertEventAggregateOrderBy? certHistoryAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? isActive,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
    Input$EventOrderBy? updatedIn,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  });
  CopyWith$Input$CertEventAggregateOrderBy<TRes> get certHistoryAggregate;
  CopyWith$Input$EventOrderBy<TRes> get createdIn;
  CopyWith$Input$IdentityOrderBy<TRes> get issuer;
  CopyWith$Input$IdentityOrderBy<TRes> get receiver;
  CopyWith$Input$EventOrderBy<TRes> get updatedIn;
}

class _CopyWithImpl$Input$CertOrderBy<TRes>
    implements CopyWith$Input$CertOrderBy<TRes> {
  _CopyWithImpl$Input$CertOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertOrderBy _instance;

  final TRes Function(Input$CertOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? certHistoryAggregate = _undefined,
    Object? createdIn = _undefined,
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? isActive = _undefined,
    Object? issuer = _undefined,
    Object? issuerId = _undefined,
    Object? receiver = _undefined,
    Object? receiverId = _undefined,
    Object? updatedIn = _undefined,
    Object? updatedInId = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertOrderBy._({
        ..._instance._$data,
        if (certHistoryAggregate != _undefined)
          'certHistoryAggregate':
              (certHistoryAggregate as Input$CertEventAggregateOrderBy?),
        if (createdIn != _undefined)
          'createdIn': (createdIn as Input$EventOrderBy?),
        if (createdInId != _undefined)
          'createdInId': (createdInId as Enum$OrderBy?),
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (isActive != _undefined) 'isActive': (isActive as Enum$OrderBy?),
        if (issuer != _undefined) 'issuer': (issuer as Input$IdentityOrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiver != _undefined)
          'receiver': (receiver as Input$IdentityOrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
        if (updatedIn != _undefined)
          'updatedIn': (updatedIn as Input$EventOrderBy?),
        if (updatedInId != _undefined)
          'updatedInId': (updatedInId as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));

  CopyWith$Input$CertEventAggregateOrderBy<TRes> get certHistoryAggregate {
    final local$certHistoryAggregate = _instance.certHistoryAggregate;
    return local$certHistoryAggregate == null
        ? CopyWith$Input$CertEventAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertEventAggregateOrderBy(
            local$certHistoryAggregate, (e) => call(certHistoryAggregate: e));
  }

  CopyWith$Input$EventOrderBy<TRes> get createdIn {
    final local$createdIn = _instance.createdIn;
    return local$createdIn == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(
            local$createdIn, (e) => call(createdIn: e));
  }

  CopyWith$Input$IdentityOrderBy<TRes> get issuer {
    final local$issuer = _instance.issuer;
    return local$issuer == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(local$issuer, (e) => call(issuer: e));
  }

  CopyWith$Input$IdentityOrderBy<TRes> get receiver {
    final local$receiver = _instance.receiver;
    return local$receiver == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$receiver, (e) => call(receiver: e));
  }

  CopyWith$Input$EventOrderBy<TRes> get updatedIn {
    final local$updatedIn = _instance.updatedIn;
    return local$updatedIn == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(
            local$updatedIn, (e) => call(updatedIn: e));
  }
}

class _CopyWithStubImpl$Input$CertOrderBy<TRes>
    implements CopyWith$Input$CertOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertOrderBy(this._res);

  TRes _res;

  call({
    Input$CertEventAggregateOrderBy? certHistoryAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? isActive,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
    Input$EventOrderBy? updatedIn,
    Enum$OrderBy? updatedInId,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;

  CopyWith$Input$CertEventAggregateOrderBy<TRes> get certHistoryAggregate =>
      CopyWith$Input$CertEventAggregateOrderBy.stub(_res);

  CopyWith$Input$EventOrderBy<TRes> get createdIn =>
      CopyWith$Input$EventOrderBy.stub(_res);

  CopyWith$Input$IdentityOrderBy<TRes> get issuer =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$IdentityOrderBy<TRes> get receiver =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$EventOrderBy<TRes> get updatedIn =>
      CopyWith$Input$EventOrderBy.stub(_res);
}

class Input$CertStddevOrderBy {
  factory Input$CertStddevOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertStddevOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertStddevOrderBy._(this._$data);

  factory Input$CertStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertStddevOrderBy<Input$CertStddevOrderBy> get copyWith =>
      CopyWith$Input$CertStddevOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertStddevOrderBy<TRes> {
  factory CopyWith$Input$CertStddevOrderBy(
    Input$CertStddevOrderBy instance,
    TRes Function(Input$CertStddevOrderBy) then,
  ) = _CopyWithImpl$Input$CertStddevOrderBy;

  factory CopyWith$Input$CertStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertStddevOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertStddevOrderBy<TRes>
    implements CopyWith$Input$CertStddevOrderBy<TRes> {
  _CopyWithImpl$Input$CertStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertStddevOrderBy _instance;

  final TRes Function(Input$CertStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertStddevOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertStddevOrderBy<TRes>
    implements CopyWith$Input$CertStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertStddevOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertStddevPopOrderBy {
  factory Input$CertStddevPopOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertStddevPopOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertStddevPopOrderBy._(this._$data);

  factory Input$CertStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertStddevPopOrderBy<Input$CertStddevPopOrderBy>
      get copyWith => CopyWith$Input$CertStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertStddevPopOrderBy<TRes> {
  factory CopyWith$Input$CertStddevPopOrderBy(
    Input$CertStddevPopOrderBy instance,
    TRes Function(Input$CertStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$CertStddevPopOrderBy;

  factory CopyWith$Input$CertStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertStddevPopOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertStddevPopOrderBy<TRes>
    implements CopyWith$Input$CertStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$CertStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertStddevPopOrderBy _instance;

  final TRes Function(Input$CertStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertStddevPopOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertStddevPopOrderBy<TRes>
    implements CopyWith$Input$CertStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertStddevPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertStddevSampOrderBy {
  factory Input$CertStddevSampOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertStddevSampOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertStddevSampOrderBy._(this._$data);

  factory Input$CertStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertStddevSampOrderBy<Input$CertStddevSampOrderBy>
      get copyWith => CopyWith$Input$CertStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertStddevSampOrderBy<TRes> {
  factory CopyWith$Input$CertStddevSampOrderBy(
    Input$CertStddevSampOrderBy instance,
    TRes Function(Input$CertStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$CertStddevSampOrderBy;

  factory CopyWith$Input$CertStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertStddevSampOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertStddevSampOrderBy<TRes>
    implements CopyWith$Input$CertStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$CertStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertStddevSampOrderBy _instance;

  final TRes Function(Input$CertStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertStddevSampOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertStddevSampOrderBy<TRes>
    implements CopyWith$Input$CertStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertStddevSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertSumOrderBy {
  factory Input$CertSumOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertSumOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertSumOrderBy._(this._$data);

  factory Input$CertSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertSumOrderBy<Input$CertSumOrderBy> get copyWith =>
      CopyWith$Input$CertSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertSumOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertSumOrderBy<TRes> {
  factory CopyWith$Input$CertSumOrderBy(
    Input$CertSumOrderBy instance,
    TRes Function(Input$CertSumOrderBy) then,
  ) = _CopyWithImpl$Input$CertSumOrderBy;

  factory CopyWith$Input$CertSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertSumOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertSumOrderBy<TRes>
    implements CopyWith$Input$CertSumOrderBy<TRes> {
  _CopyWithImpl$Input$CertSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertSumOrderBy _instance;

  final TRes Function(Input$CertSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertSumOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertSumOrderBy<TRes>
    implements CopyWith$Input$CertSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertSumOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertVarianceOrderBy {
  factory Input$CertVarianceOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertVarianceOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertVarianceOrderBy._(this._$data);

  factory Input$CertVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertVarianceOrderBy<Input$CertVarianceOrderBy> get copyWith =>
      CopyWith$Input$CertVarianceOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertVarianceOrderBy<TRes> {
  factory CopyWith$Input$CertVarianceOrderBy(
    Input$CertVarianceOrderBy instance,
    TRes Function(Input$CertVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$CertVarianceOrderBy;

  factory CopyWith$Input$CertVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertVarianceOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertVarianceOrderBy<TRes>
    implements CopyWith$Input$CertVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$CertVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertVarianceOrderBy _instance;

  final TRes Function(Input$CertVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertVarianceOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertVarianceOrderBy<TRes>
    implements CopyWith$Input$CertVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertVarianceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertVarPopOrderBy {
  factory Input$CertVarPopOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertVarPopOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertVarPopOrderBy._(this._$data);

  factory Input$CertVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertVarPopOrderBy<Input$CertVarPopOrderBy> get copyWith =>
      CopyWith$Input$CertVarPopOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertVarPopOrderBy<TRes> {
  factory CopyWith$Input$CertVarPopOrderBy(
    Input$CertVarPopOrderBy instance,
    TRes Function(Input$CertVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$CertVarPopOrderBy;

  factory CopyWith$Input$CertVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertVarPopOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertVarPopOrderBy<TRes>
    implements CopyWith$Input$CertVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$CertVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertVarPopOrderBy _instance;

  final TRes Function(Input$CertVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertVarPopOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertVarPopOrderBy<TRes>
    implements CopyWith$Input$CertVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertVarPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$CertVarSampOrderBy {
  factory Input$CertVarSampOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      Input$CertVarSampOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (updatedOn != null) r'updatedOn': updatedOn,
      });

  Input$CertVarSampOrderBy._(this._$data);

  factory Input$CertVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('updatedOn')) {
      final l$updatedOn = data['updatedOn'];
      result$data['updatedOn'] = l$updatedOn == null
          ? null
          : fromJson$Enum$OrderBy((l$updatedOn as String));
    }
    return Input$CertVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get updatedOn => (_$data['updatedOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('updatedOn')) {
      final l$updatedOn = updatedOn;
      result$data['updatedOn'] =
          l$updatedOn == null ? null : toJson$Enum$OrderBy(l$updatedOn);
    }
    return result$data;
  }

  CopyWith$Input$CertVarSampOrderBy<Input$CertVarSampOrderBy> get copyWith =>
      CopyWith$Input$CertVarSampOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CertVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$updatedOn = updatedOn;
    final lOther$updatedOn = other.updatedOn;
    if (_$data.containsKey('updatedOn') !=
        other._$data.containsKey('updatedOn')) {
      return false;
    }
    if (l$updatedOn != lOther$updatedOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$updatedOn = updatedOn;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('updatedOn') ? l$updatedOn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CertVarSampOrderBy<TRes> {
  factory CopyWith$Input$CertVarSampOrderBy(
    Input$CertVarSampOrderBy instance,
    TRes Function(Input$CertVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$CertVarSampOrderBy;

  factory CopyWith$Input$CertVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$CertVarSampOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  });
}

class _CopyWithImpl$Input$CertVarSampOrderBy<TRes>
    implements CopyWith$Input$CertVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$CertVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$CertVarSampOrderBy _instance;

  final TRes Function(Input$CertVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? updatedOn = _undefined,
  }) =>
      _then(Input$CertVarSampOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (updatedOn != _undefined) 'updatedOn': (updatedOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$CertVarSampOrderBy<TRes>
    implements CopyWith$Input$CertVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$CertVarSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? updatedOn,
  }) =>
      _res;
}

class Input$ChangeOwnerKeyAggregateBoolExp {
  factory Input$ChangeOwnerKeyAggregateBoolExp(
          {Input$changeOwnerKeyAggregateBoolExpCount? count}) =>
      Input$ChangeOwnerKeyAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$ChangeOwnerKeyAggregateBoolExp._(this._$data);

  factory Input$ChangeOwnerKeyAggregateBoolExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$changeOwnerKeyAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$ChangeOwnerKeyAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$changeOwnerKeyAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$changeOwnerKeyAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<
          Input$ChangeOwnerKeyAggregateBoolExp>
      get copyWith => CopyWith$Input$ChangeOwnerKeyAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyAggregateBoolExp(
    Input$ChangeOwnerKeyAggregateBoolExp instance,
    TRes Function(Input$ChangeOwnerKeyAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyAggregateBoolExp;

  factory CopyWith$Input$ChangeOwnerKeyAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateBoolExp;

  TRes call({Input$changeOwnerKeyAggregateBoolExpCount? count});
  CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyAggregateBoolExp _instance;

  final TRes Function(Input$ChangeOwnerKeyAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$ChangeOwnerKeyAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$changeOwnerKeyAggregateBoolExpCount?),
      }));

  CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$changeOwnerKeyAggregateBoolExpCount.stub(
            _then(_instance))
        : CopyWith$Input$changeOwnerKeyAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateBoolExp(this._res);

  TRes _res;

  call({Input$changeOwnerKeyAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$changeOwnerKeyAggregateBoolExpCount.stub(_res);
}

class Input$changeOwnerKeyAggregateBoolExpCount {
  factory Input$changeOwnerKeyAggregateBoolExpCount({
    List<Enum$ChangeOwnerKeySelectColumn>? arguments,
    bool? distinct,
    Input$ChangeOwnerKeyBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$changeOwnerKeyAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$changeOwnerKeyAggregateBoolExpCount._(this._$data);

  factory Input$changeOwnerKeyAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ChangeOwnerKeySelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$ChangeOwnerKeyBoolExp.fromJson(
              (l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$changeOwnerKeyAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$ChangeOwnerKeySelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$ChangeOwnerKeySelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$ChangeOwnerKeyBoolExp? get filter =>
      (_$data['filter'] as Input$ChangeOwnerKeyBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] = l$arguments
          ?.map((e) => toJson$Enum$ChangeOwnerKeySelectColumn(e))
          .toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<
          Input$changeOwnerKeyAggregateBoolExpCount>
      get copyWith => CopyWith$Input$changeOwnerKeyAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$changeOwnerKeyAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$changeOwnerKeyAggregateBoolExpCount(
    Input$changeOwnerKeyAggregateBoolExpCount instance,
    TRes Function(Input$changeOwnerKeyAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$changeOwnerKeyAggregateBoolExpCount;

  factory CopyWith$Input$changeOwnerKeyAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$changeOwnerKeyAggregateBoolExpCount;

  TRes call({
    List<Enum$ChangeOwnerKeySelectColumn>? arguments,
    bool? distinct,
    Input$ChangeOwnerKeyBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$changeOwnerKeyAggregateBoolExpCount<TRes>
    implements CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$changeOwnerKeyAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$changeOwnerKeyAggregateBoolExpCount _instance;

  final TRes Function(Input$changeOwnerKeyAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$changeOwnerKeyAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$ChangeOwnerKeySelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined)
          'filter': (filter as Input$ChangeOwnerKeyBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyBoolExp(
            local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$changeOwnerKeyAggregateBoolExpCount<TRes>
    implements CopyWith$Input$changeOwnerKeyAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$changeOwnerKeyAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$ChangeOwnerKeySelectColumn>? arguments,
    bool? distinct,
    Input$ChangeOwnerKeyBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get filter =>
      CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$ChangeOwnerKeyAggregateOrderBy {
  factory Input$ChangeOwnerKeyAggregateOrderBy({
    Input$ChangeOwnerKeyAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ChangeOwnerKeyMaxOrderBy? max,
    Input$ChangeOwnerKeyMinOrderBy? min,
    Input$ChangeOwnerKeyStddevOrderBy? stddev,
    Input$ChangeOwnerKeyStddevPopOrderBy? stddevPop,
    Input$ChangeOwnerKeyStddevSampOrderBy? stddevSamp,
    Input$ChangeOwnerKeySumOrderBy? sum,
    Input$ChangeOwnerKeyVarPopOrderBy? varPop,
    Input$ChangeOwnerKeyVarSampOrderBy? varSamp,
    Input$ChangeOwnerKeyVarianceOrderBy? variance,
  }) =>
      Input$ChangeOwnerKeyAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$ChangeOwnerKeyAggregateOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$ChangeOwnerKeyAvgOrderBy.fromJson(
              (l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$ChangeOwnerKeyMaxOrderBy.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$ChangeOwnerKeyMinOrderBy.fromJson(
              (l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$ChangeOwnerKeyStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$ChangeOwnerKeyStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$ChangeOwnerKeyStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$ChangeOwnerKeySumOrderBy.fromJson(
              (l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$ChangeOwnerKeyVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$ChangeOwnerKeyVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$ChangeOwnerKeyVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$ChangeOwnerKeyAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ChangeOwnerKeyAvgOrderBy? get avg =>
      (_$data['avg'] as Input$ChangeOwnerKeyAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$ChangeOwnerKeyMaxOrderBy? get max =>
      (_$data['max'] as Input$ChangeOwnerKeyMaxOrderBy?);

  Input$ChangeOwnerKeyMinOrderBy? get min =>
      (_$data['min'] as Input$ChangeOwnerKeyMinOrderBy?);

  Input$ChangeOwnerKeyStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$ChangeOwnerKeyStddevOrderBy?);

  Input$ChangeOwnerKeyStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$ChangeOwnerKeyStddevPopOrderBy?);

  Input$ChangeOwnerKeyStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$ChangeOwnerKeyStddevSampOrderBy?);

  Input$ChangeOwnerKeySumOrderBy? get sum =>
      (_$data['sum'] as Input$ChangeOwnerKeySumOrderBy?);

  Input$ChangeOwnerKeyVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$ChangeOwnerKeyVarPopOrderBy?);

  Input$ChangeOwnerKeyVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$ChangeOwnerKeyVarSampOrderBy?);

  Input$ChangeOwnerKeyVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$ChangeOwnerKeyVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<
          Input$ChangeOwnerKeyAggregateOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyAggregateOrderBy(
    Input$ChangeOwnerKeyAggregateOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyAggregateOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateOrderBy;

  TRes call({
    Input$ChangeOwnerKeyAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ChangeOwnerKeyMaxOrderBy? max,
    Input$ChangeOwnerKeyMinOrderBy? min,
    Input$ChangeOwnerKeyStddevOrderBy? stddev,
    Input$ChangeOwnerKeyStddevPopOrderBy? stddevPop,
    Input$ChangeOwnerKeyStddevSampOrderBy? stddevSamp,
    Input$ChangeOwnerKeySumOrderBy? sum,
    Input$ChangeOwnerKeyVarPopOrderBy? varPop,
    Input$ChangeOwnerKeyVarSampOrderBy? varSamp,
    Input$ChangeOwnerKeyVarianceOrderBy? variance,
  });
  CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> get avg;
  CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> get max;
  CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> get min;
  CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> get stddev;
  CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> get sum;
  CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyAggregateOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$ChangeOwnerKeyAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$ChangeOwnerKeyAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$ChangeOwnerKeyMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$ChangeOwnerKeyMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$ChangeOwnerKeyStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$ChangeOwnerKeyStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$ChangeOwnerKeyStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$ChangeOwnerKeySumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$ChangeOwnerKeyVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$ChangeOwnerKeyVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$ChangeOwnerKeyVarianceOrderBy?),
      }));

  CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$ChangeOwnerKeyAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyAvgOrderBy(
            local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$ChangeOwnerKeyMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyMaxOrderBy(
            local$max, (e) => call(max: e));
  }

  CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$ChangeOwnerKeyMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyMinOrderBy(
            local$min, (e) => call(min: e));
  }

  CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$ChangeOwnerKeyStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$ChangeOwnerKeySumOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeySumOrderBy(
            local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$ChangeOwnerKeyVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$ChangeOwnerKeyVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$ChangeOwnerKeyVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$ChangeOwnerKeyAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ChangeOwnerKeyMaxOrderBy? max,
    Input$ChangeOwnerKeyMinOrderBy? min,
    Input$ChangeOwnerKeyStddevOrderBy? stddev,
    Input$ChangeOwnerKeyStddevPopOrderBy? stddevPop,
    Input$ChangeOwnerKeyStddevSampOrderBy? stddevSamp,
    Input$ChangeOwnerKeySumOrderBy? sum,
    Input$ChangeOwnerKeyVarPopOrderBy? varPop,
    Input$ChangeOwnerKeyVarSampOrderBy? varSamp,
    Input$ChangeOwnerKeyVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> get avg =>
      CopyWith$Input$ChangeOwnerKeyAvgOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> get max =>
      CopyWith$Input$ChangeOwnerKeyMaxOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> get min =>
      CopyWith$Input$ChangeOwnerKeyMinOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$ChangeOwnerKeyStddevOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> get sum =>
      CopyWith$Input$ChangeOwnerKeySumOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$ChangeOwnerKeyVarPopOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$ChangeOwnerKeyVarSampOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$ChangeOwnerKeyVarianceOrderBy.stub(_res);
}

class Input$ChangeOwnerKeyAvgOrderBy {
  factory Input$ChangeOwnerKeyAvgOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyAvgOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyAvgOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyAvgOrderBy<Input$ChangeOwnerKeyAvgOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyAvgOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyAvgOrderBy(
    Input$ChangeOwnerKeyAvgOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyAvgOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyAvgOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyAvgOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyAvgOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyAvgOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyAvgOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyAvgOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyAvgOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyBoolExp {
  factory Input$ChangeOwnerKeyBoolExp({
    List<Input$ChangeOwnerKeyBoolExp>? $_and,
    Input$ChangeOwnerKeyBoolExp? $_not,
    List<Input$ChangeOwnerKeyBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$AccountBoolExp? next,
    Input$StringComparisonExp? nextId,
    Input$AccountBoolExp? previous,
    Input$StringComparisonExp? previousId,
  }) =>
      Input$ChangeOwnerKeyBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
        if (next != null) r'next': next,
        if (nextId != null) r'nextId': nextId,
        if (previous != null) r'previous': previous,
        if (previousId != null) r'previousId': previousId,
      });

  Input$ChangeOwnerKeyBoolExp._(this._$data);

  factory Input$ChangeOwnerKeyBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$ChangeOwnerKeyBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$ChangeOwnerKeyBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$ChangeOwnerKeyBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$identityId as Map<String, dynamic>));
    }
    if (data.containsKey('next')) {
      final l$next = data['next'];
      result$data['next'] = l$next == null
          ? null
          : Input$AccountBoolExp.fromJson((l$next as Map<String, dynamic>));
    }
    if (data.containsKey('nextId')) {
      final l$nextId = data['nextId'];
      result$data['nextId'] = l$nextId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$nextId as Map<String, dynamic>));
    }
    if (data.containsKey('previous')) {
      final l$previous = data['previous'];
      result$data['previous'] = l$previous == null
          ? null
          : Input$AccountBoolExp.fromJson((l$previous as Map<String, dynamic>));
    }
    if (data.containsKey('previousId')) {
      final l$previousId = data['previousId'];
      result$data['previousId'] = l$previousId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$previousId as Map<String, dynamic>));
    }
    return Input$ChangeOwnerKeyBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ChangeOwnerKeyBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$ChangeOwnerKeyBoolExp>?);

  Input$ChangeOwnerKeyBoolExp? get $_not =>
      (_$data['_not'] as Input$ChangeOwnerKeyBoolExp?);

  List<Input$ChangeOwnerKeyBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$ChangeOwnerKeyBoolExp>?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get identity =>
      (_$data['identity'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get identityId =>
      (_$data['identityId'] as Input$StringComparisonExp?);

  Input$AccountBoolExp? get next => (_$data['next'] as Input$AccountBoolExp?);

  Input$StringComparisonExp? get nextId =>
      (_$data['nextId'] as Input$StringComparisonExp?);

  Input$AccountBoolExp? get previous =>
      (_$data['previous'] as Input$AccountBoolExp?);

  Input$StringComparisonExp? get previousId =>
      (_$data['previousId'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] = l$identityId?.toJson();
    }
    if (_$data.containsKey('next')) {
      final l$next = next;
      result$data['next'] = l$next?.toJson();
    }
    if (_$data.containsKey('nextId')) {
      final l$nextId = nextId;
      result$data['nextId'] = l$nextId?.toJson();
    }
    if (_$data.containsKey('previous')) {
      final l$previous = previous;
      result$data['previous'] = l$previous?.toJson();
    }
    if (_$data.containsKey('previousId')) {
      final l$previousId = previousId;
      result$data['previousId'] = l$previousId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyBoolExp<Input$ChangeOwnerKeyBoolExp>
      get copyWith => CopyWith$Input$ChangeOwnerKeyBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$next = next;
    final lOther$next = other.next;
    if (_$data.containsKey('next') != other._$data.containsKey('next')) {
      return false;
    }
    if (l$next != lOther$next) {
      return false;
    }
    final l$nextId = nextId;
    final lOther$nextId = other.nextId;
    if (_$data.containsKey('nextId') != other._$data.containsKey('nextId')) {
      return false;
    }
    if (l$nextId != lOther$nextId) {
      return false;
    }
    final l$previous = previous;
    final lOther$previous = other.previous;
    if (_$data.containsKey('previous') !=
        other._$data.containsKey('previous')) {
      return false;
    }
    if (l$previous != lOther$previous) {
      return false;
    }
    final l$previousId = previousId;
    final lOther$previousId = other.previousId;
    if (_$data.containsKey('previousId') !=
        other._$data.containsKey('previousId')) {
      return false;
    }
    if (l$previousId != lOther$previousId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    final l$next = next;
    final l$nextId = nextId;
    final l$previous = previous;
    final l$previousId = previousId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('next') ? l$next : const {},
      _$data.containsKey('nextId') ? l$nextId : const {},
      _$data.containsKey('previous') ? l$previous : const {},
      _$data.containsKey('previousId') ? l$previousId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyBoolExp(
    Input$ChangeOwnerKeyBoolExp instance,
    TRes Function(Input$ChangeOwnerKeyBoolExp) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyBoolExp;

  factory CopyWith$Input$ChangeOwnerKeyBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyBoolExp;

  TRes call({
    List<Input$ChangeOwnerKeyBoolExp>? $_and,
    Input$ChangeOwnerKeyBoolExp? $_not,
    List<Input$ChangeOwnerKeyBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$AccountBoolExp? next,
    Input$StringComparisonExp? nextId,
    Input$AccountBoolExp? previous,
    Input$StringComparisonExp? previousId,
  });
  TRes $_and(
      Iterable<Input$ChangeOwnerKeyBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ChangeOwnerKeyBoolExp<
                      Input$ChangeOwnerKeyBoolExp>>?)
          _fn);
  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$ChangeOwnerKeyBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ChangeOwnerKeyBoolExp<
                      Input$ChangeOwnerKeyBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IdentityBoolExp<TRes> get identity;
  CopyWith$Input$StringComparisonExp<TRes> get identityId;
  CopyWith$Input$AccountBoolExp<TRes> get next;
  CopyWith$Input$StringComparisonExp<TRes> get nextId;
  CopyWith$Input$AccountBoolExp<TRes> get previous;
  CopyWith$Input$StringComparisonExp<TRes> get previousId;
}

class _CopyWithImpl$Input$ChangeOwnerKeyBoolExp<TRes>
    implements CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyBoolExp(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyBoolExp _instance;

  final TRes Function(Input$ChangeOwnerKeyBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
    Object? next = _undefined,
    Object? nextId = _undefined,
    Object? previous = _undefined,
    Object? previousId = _undefined,
  }) =>
      _then(Input$ChangeOwnerKeyBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$ChangeOwnerKeyBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as Input$ChangeOwnerKeyBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<Input$ChangeOwnerKeyBoolExp>?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityBoolExp?),
        if (identityId != _undefined)
          'identityId': (identityId as Input$StringComparisonExp?),
        if (next != _undefined) 'next': (next as Input$AccountBoolExp?),
        if (nextId != _undefined)
          'nextId': (nextId as Input$StringComparisonExp?),
        if (previous != _undefined)
          'previous': (previous as Input$AccountBoolExp?),
        if (previousId != _undefined)
          'previousId': (previousId as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$ChangeOwnerKeyBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ChangeOwnerKeyBoolExp<
                          Input$ChangeOwnerKeyBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(
              _instance.$_and?.map((e) => CopyWith$Input$ChangeOwnerKeyBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$ChangeOwnerKeyBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ChangeOwnerKeyBoolExp<
                          Input$ChangeOwnerKeyBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(
              _instance.$_or?.map((e) => CopyWith$Input$ChangeOwnerKeyBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get identityId {
    final local$identityId = _instance.identityId;
    return local$identityId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$identityId, (e) => call(identityId: e));
  }

  CopyWith$Input$AccountBoolExp<TRes> get next {
    final local$next = _instance.next;
    return local$next == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$next, (e) => call(next: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get nextId {
    final local$nextId = _instance.nextId;
    return local$nextId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$nextId, (e) => call(nextId: e));
  }

  CopyWith$Input$AccountBoolExp<TRes> get previous {
    final local$previous = _instance.previous;
    return local$previous == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(
            local$previous, (e) => call(previous: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get previousId {
    final local$previousId = _instance.previousId;
    return local$previousId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$previousId, (e) => call(previousId: e));
  }
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyBoolExp<TRes>
    implements CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyBoolExp(this._res);

  TRes _res;

  call({
    List<Input$ChangeOwnerKeyBoolExp>? $_and,
    Input$ChangeOwnerKeyBoolExp? $_not,
    List<Input$ChangeOwnerKeyBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$AccountBoolExp? next,
    Input$StringComparisonExp? nextId,
    Input$AccountBoolExp? previous,
    Input$StringComparisonExp? previousId,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get $_not =>
      CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get identity =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get identityId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$AccountBoolExp<TRes> get next =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get nextId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$AccountBoolExp<TRes> get previous =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get previousId =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$ChangeOwnerKeyMaxOrderBy {
  factory Input$ChangeOwnerKeyMaxOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  }) =>
      Input$ChangeOwnerKeyMaxOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
        if (nextId != null) r'nextId': nextId,
        if (previousId != null) r'previousId': previousId,
      });

  Input$ChangeOwnerKeyMaxOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('nextId')) {
      final l$nextId = data['nextId'];
      result$data['nextId'] =
          l$nextId == null ? null : fromJson$Enum$OrderBy((l$nextId as String));
    }
    if (data.containsKey('previousId')) {
      final l$previousId = data['previousId'];
      result$data['previousId'] = l$previousId == null
          ? null
          : fromJson$Enum$OrderBy((l$previousId as String));
    }
    return Input$ChangeOwnerKeyMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Enum$OrderBy? get nextId => (_$data['nextId'] as Enum$OrderBy?);

  Enum$OrderBy? get previousId => (_$data['previousId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('nextId')) {
      final l$nextId = nextId;
      result$data['nextId'] =
          l$nextId == null ? null : toJson$Enum$OrderBy(l$nextId);
    }
    if (_$data.containsKey('previousId')) {
      final l$previousId = previousId;
      result$data['previousId'] =
          l$previousId == null ? null : toJson$Enum$OrderBy(l$previousId);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyMaxOrderBy<Input$ChangeOwnerKeyMaxOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyMaxOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$nextId = nextId;
    final lOther$nextId = other.nextId;
    if (_$data.containsKey('nextId') != other._$data.containsKey('nextId')) {
      return false;
    }
    if (l$nextId != lOther$nextId) {
      return false;
    }
    final l$previousId = previousId;
    final lOther$previousId = other.previousId;
    if (_$data.containsKey('previousId') !=
        other._$data.containsKey('previousId')) {
      return false;
    }
    if (l$previousId != lOther$previousId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identityId = identityId;
    final l$nextId = nextId;
    final l$previousId = previousId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('nextId') ? l$nextId : const {},
      _$data.containsKey('previousId') ? l$previousId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyMaxOrderBy(
    Input$ChangeOwnerKeyMaxOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyMaxOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyMaxOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyMaxOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  });
}

class _CopyWithImpl$Input$ChangeOwnerKeyMaxOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyMaxOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
    Object? nextId = _undefined,
    Object? previousId = _undefined,
  }) =>
      _then(Input$ChangeOwnerKeyMaxOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (nextId != _undefined) 'nextId': (nextId as Enum$OrderBy?),
        if (previousId != _undefined)
          'previousId': (previousId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyMaxOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  }) =>
      _res;
}

class Input$ChangeOwnerKeyMinOrderBy {
  factory Input$ChangeOwnerKeyMinOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  }) =>
      Input$ChangeOwnerKeyMinOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
        if (nextId != null) r'nextId': nextId,
        if (previousId != null) r'previousId': previousId,
      });

  Input$ChangeOwnerKeyMinOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('nextId')) {
      final l$nextId = data['nextId'];
      result$data['nextId'] =
          l$nextId == null ? null : fromJson$Enum$OrderBy((l$nextId as String));
    }
    if (data.containsKey('previousId')) {
      final l$previousId = data['previousId'];
      result$data['previousId'] = l$previousId == null
          ? null
          : fromJson$Enum$OrderBy((l$previousId as String));
    }
    return Input$ChangeOwnerKeyMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Enum$OrderBy? get nextId => (_$data['nextId'] as Enum$OrderBy?);

  Enum$OrderBy? get previousId => (_$data['previousId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('nextId')) {
      final l$nextId = nextId;
      result$data['nextId'] =
          l$nextId == null ? null : toJson$Enum$OrderBy(l$nextId);
    }
    if (_$data.containsKey('previousId')) {
      final l$previousId = previousId;
      result$data['previousId'] =
          l$previousId == null ? null : toJson$Enum$OrderBy(l$previousId);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyMinOrderBy<Input$ChangeOwnerKeyMinOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyMinOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$nextId = nextId;
    final lOther$nextId = other.nextId;
    if (_$data.containsKey('nextId') != other._$data.containsKey('nextId')) {
      return false;
    }
    if (l$nextId != lOther$nextId) {
      return false;
    }
    final l$previousId = previousId;
    final lOther$previousId = other.previousId;
    if (_$data.containsKey('previousId') !=
        other._$data.containsKey('previousId')) {
      return false;
    }
    if (l$previousId != lOther$previousId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identityId = identityId;
    final l$nextId = nextId;
    final l$previousId = previousId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('nextId') ? l$nextId : const {},
      _$data.containsKey('previousId') ? l$previousId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyMinOrderBy(
    Input$ChangeOwnerKeyMinOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyMinOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyMinOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyMinOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  });
}

class _CopyWithImpl$Input$ChangeOwnerKeyMinOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyMinOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
    Object? nextId = _undefined,
    Object? previousId = _undefined,
  }) =>
      _then(Input$ChangeOwnerKeyMinOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (nextId != _undefined) 'nextId': (nextId as Enum$OrderBy?),
        if (previousId != _undefined)
          'previousId': (previousId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyMinOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? nextId,
    Enum$OrderBy? previousId,
  }) =>
      _res;
}

class Input$ChangeOwnerKeyOrderBy {
  factory Input$ChangeOwnerKeyOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Input$AccountOrderBy? next,
    Enum$OrderBy? nextId,
    Input$AccountOrderBy? previous,
    Enum$OrderBy? previousId,
  }) =>
      Input$ChangeOwnerKeyOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
        if (next != null) r'next': next,
        if (nextId != null) r'nextId': nextId,
        if (previous != null) r'previous': previous,
        if (previousId != null) r'previousId': previousId,
      });

  Input$ChangeOwnerKeyOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('next')) {
      final l$next = data['next'];
      result$data['next'] = l$next == null
          ? null
          : Input$AccountOrderBy.fromJson((l$next as Map<String, dynamic>));
    }
    if (data.containsKey('nextId')) {
      final l$nextId = data['nextId'];
      result$data['nextId'] =
          l$nextId == null ? null : fromJson$Enum$OrderBy((l$nextId as String));
    }
    if (data.containsKey('previous')) {
      final l$previous = data['previous'];
      result$data['previous'] = l$previous == null
          ? null
          : Input$AccountOrderBy.fromJson((l$previous as Map<String, dynamic>));
    }
    if (data.containsKey('previousId')) {
      final l$previousId = data['previousId'];
      result$data['previousId'] = l$previousId == null
          ? null
          : fromJson$Enum$OrderBy((l$previousId as String));
    }
    return Input$ChangeOwnerKeyOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get identity =>
      (_$data['identity'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Input$AccountOrderBy? get next => (_$data['next'] as Input$AccountOrderBy?);

  Enum$OrderBy? get nextId => (_$data['nextId'] as Enum$OrderBy?);

  Input$AccountOrderBy? get previous =>
      (_$data['previous'] as Input$AccountOrderBy?);

  Enum$OrderBy? get previousId => (_$data['previousId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('next')) {
      final l$next = next;
      result$data['next'] = l$next?.toJson();
    }
    if (_$data.containsKey('nextId')) {
      final l$nextId = nextId;
      result$data['nextId'] =
          l$nextId == null ? null : toJson$Enum$OrderBy(l$nextId);
    }
    if (_$data.containsKey('previous')) {
      final l$previous = previous;
      result$data['previous'] = l$previous?.toJson();
    }
    if (_$data.containsKey('previousId')) {
      final l$previousId = previousId;
      result$data['previousId'] =
          l$previousId == null ? null : toJson$Enum$OrderBy(l$previousId);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyOrderBy<Input$ChangeOwnerKeyOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$next = next;
    final lOther$next = other.next;
    if (_$data.containsKey('next') != other._$data.containsKey('next')) {
      return false;
    }
    if (l$next != lOther$next) {
      return false;
    }
    final l$nextId = nextId;
    final lOther$nextId = other.nextId;
    if (_$data.containsKey('nextId') != other._$data.containsKey('nextId')) {
      return false;
    }
    if (l$nextId != lOther$nextId) {
      return false;
    }
    final l$previous = previous;
    final lOther$previous = other.previous;
    if (_$data.containsKey('previous') !=
        other._$data.containsKey('previous')) {
      return false;
    }
    if (l$previous != lOther$previous) {
      return false;
    }
    final l$previousId = previousId;
    final lOther$previousId = other.previousId;
    if (_$data.containsKey('previousId') !=
        other._$data.containsKey('previousId')) {
      return false;
    }
    if (l$previousId != lOther$previousId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    final l$next = next;
    final l$nextId = nextId;
    final l$previous = previous;
    final l$previousId = previousId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('next') ? l$next : const {},
      _$data.containsKey('nextId') ? l$nextId : const {},
      _$data.containsKey('previous') ? l$previous : const {},
      _$data.containsKey('previousId') ? l$previousId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyOrderBy(
    Input$ChangeOwnerKeyOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Input$AccountOrderBy? next,
    Enum$OrderBy? nextId,
    Input$AccountOrderBy? previous,
    Enum$OrderBy? previousId,
  });
  CopyWith$Input$IdentityOrderBy<TRes> get identity;
  CopyWith$Input$AccountOrderBy<TRes> get next;
  CopyWith$Input$AccountOrderBy<TRes> get previous;
}

class _CopyWithImpl$Input$ChangeOwnerKeyOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
    Object? next = _undefined,
    Object? nextId = _undefined,
    Object? previous = _undefined,
    Object? previousId = _undefined,
  }) =>
      _then(Input$ChangeOwnerKeyOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityOrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (next != _undefined) 'next': (next as Input$AccountOrderBy?),
        if (nextId != _undefined) 'nextId': (nextId as Enum$OrderBy?),
        if (previous != _undefined)
          'previous': (previous as Input$AccountOrderBy?),
        if (previousId != _undefined)
          'previousId': (previousId as Enum$OrderBy?),
      }));

  CopyWith$Input$IdentityOrderBy<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$AccountOrderBy<TRes> get next {
    final local$next = _instance.next;
    return local$next == null
        ? CopyWith$Input$AccountOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountOrderBy(local$next, (e) => call(next: e));
  }

  CopyWith$Input$AccountOrderBy<TRes> get previous {
    final local$previous = _instance.previous;
    return local$previous == null
        ? CopyWith$Input$AccountOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountOrderBy(
            local$previous, (e) => call(previous: e));
  }
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Input$AccountOrderBy? next,
    Enum$OrderBy? nextId,
    Input$AccountOrderBy? previous,
    Enum$OrderBy? previousId,
  }) =>
      _res;

  CopyWith$Input$IdentityOrderBy<TRes> get identity =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$AccountOrderBy<TRes> get next =>
      CopyWith$Input$AccountOrderBy.stub(_res);

  CopyWith$Input$AccountOrderBy<TRes> get previous =>
      CopyWith$Input$AccountOrderBy.stub(_res);
}

class Input$ChangeOwnerKeyStddevOrderBy {
  factory Input$ChangeOwnerKeyStddevOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyStddevOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyStddevOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyStddevOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyStddevOrderBy<Input$ChangeOwnerKeyStddevOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyStddevOrderBy(
    Input$ChangeOwnerKeyStddevOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyStddevOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyStddevOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyStddevOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyStddevOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyStddevOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyStddevOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyStddevOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyStddevOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyStddevPopOrderBy {
  factory Input$ChangeOwnerKeyStddevPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyStddevPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyStddevPopOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyStddevPopOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<
          Input$ChangeOwnerKeyStddevPopOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy(
    Input$ChangeOwnerKeyStddevPopOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyStddevPopOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyStddevPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyStddevPopOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyStddevPopOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyStddevPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyStddevPopOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyStddevPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyStddevSampOrderBy {
  factory Input$ChangeOwnerKeyStddevSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyStddevSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyStddevSampOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyStddevSampOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<
          Input$ChangeOwnerKeyStddevSampOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy(
    Input$ChangeOwnerKeyStddevSampOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyStddevSampOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyStddevSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyStddevSampOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyStddevSampOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyStddevSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyStddevSampOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyStddevSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeySumOrderBy {
  factory Input$ChangeOwnerKeySumOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeySumOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeySumOrderBy._(this._$data);

  factory Input$ChangeOwnerKeySumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeySumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeySumOrderBy<Input$ChangeOwnerKeySumOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeySumOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeySumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeySumOrderBy(
    Input$ChangeOwnerKeySumOrderBy instance,
    TRes Function(Input$ChangeOwnerKeySumOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeySumOrderBy;

  factory CopyWith$Input$ChangeOwnerKeySumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeySumOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeySumOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeySumOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeySumOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeySumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeySumOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeySumOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeySumOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeySumOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyVarianceOrderBy {
  factory Input$ChangeOwnerKeyVarianceOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyVarianceOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyVarianceOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyVarianceOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<
          Input$ChangeOwnerKeyVarianceOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyVarianceOrderBy(
    Input$ChangeOwnerKeyVarianceOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyVarianceOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyVarianceOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyVarianceOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyVarianceOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyVarianceOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyVarianceOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyVarianceOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyVarPopOrderBy {
  factory Input$ChangeOwnerKeyVarPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyVarPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyVarPopOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyVarPopOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<Input$ChangeOwnerKeyVarPopOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyVarPopOrderBy(
    Input$ChangeOwnerKeyVarPopOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyVarPopOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyVarPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyVarPopOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyVarPopOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyVarPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyVarPopOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyVarPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$ChangeOwnerKeyVarSampOrderBy {
  factory Input$ChangeOwnerKeyVarSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$ChangeOwnerKeyVarSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$ChangeOwnerKeyVarSampOrderBy._(this._$data);

  factory Input$ChangeOwnerKeyVarSampOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$ChangeOwnerKeyVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<
          Input$ChangeOwnerKeyVarSampOrderBy>
      get copyWith => CopyWith$Input$ChangeOwnerKeyVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeOwnerKeyVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> {
  factory CopyWith$Input$ChangeOwnerKeyVarSampOrderBy(
    Input$ChangeOwnerKeyVarSampOrderBy instance,
    TRes Function(Input$ChangeOwnerKeyVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$ChangeOwnerKeyVarSampOrderBy;

  factory CopyWith$Input$ChangeOwnerKeyVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOwnerKeyVarSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$ChangeOwnerKeyVarSampOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$ChangeOwnerKeyVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$ChangeOwnerKeyVarSampOrderBy _instance;

  final TRes Function(Input$ChangeOwnerKeyVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$ChangeOwnerKeyVarSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ChangeOwnerKeyVarSampOrderBy<TRes>
    implements CopyWith$Input$ChangeOwnerKeyVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$ChangeOwnerKeyVarSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$CounterLevelEnumComparisonExp {
  factory Input$CounterLevelEnumComparisonExp({
    Enum$CounterLevelEnum? $_eq,
    List<Enum$CounterLevelEnum>? $_in,
    bool? $_isNull,
    Enum$CounterLevelEnum? $_neq,
    List<Enum$CounterLevelEnum>? $_nin,
  }) =>
      Input$CounterLevelEnumComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$CounterLevelEnumComparisonExp._(this._$data);

  factory Input$CounterLevelEnumComparisonExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = l$$_eq == null
          ? null
          : fromJson$Enum$CounterLevelEnum((l$$_eq as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CounterLevelEnum((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromJson$Enum$CounterLevelEnum((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CounterLevelEnum((e as String)))
          .toList();
    }
    return Input$CounterLevelEnumComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CounterLevelEnum? get $_eq => (_$data['_eq'] as Enum$CounterLevelEnum?);

  List<Enum$CounterLevelEnum>? get $_in =>
      (_$data['_in'] as List<Enum$CounterLevelEnum>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Enum$CounterLevelEnum? get $_neq =>
      (_$data['_neq'] as Enum$CounterLevelEnum?);

  List<Enum$CounterLevelEnum>? get $_nin =>
      (_$data['_nin'] as List<Enum$CounterLevelEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : toJson$Enum$CounterLevelEnum(l$$_eq);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => toJson$Enum$CounterLevelEnum(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] =
          l$$_neq == null ? null : toJson$Enum$CounterLevelEnum(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => toJson$Enum$CounterLevelEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$CounterLevelEnumComparisonExp<
          Input$CounterLevelEnumComparisonExp>
      get copyWith => CopyWith$Input$CounterLevelEnumComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CounterLevelEnumComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CounterLevelEnumComparisonExp<TRes> {
  factory CopyWith$Input$CounterLevelEnumComparisonExp(
    Input$CounterLevelEnumComparisonExp instance,
    TRes Function(Input$CounterLevelEnumComparisonExp) then,
  ) = _CopyWithImpl$Input$CounterLevelEnumComparisonExp;

  factory CopyWith$Input$CounterLevelEnumComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$CounterLevelEnumComparisonExp;

  TRes call({
    Enum$CounterLevelEnum? $_eq,
    List<Enum$CounterLevelEnum>? $_in,
    bool? $_isNull,
    Enum$CounterLevelEnum? $_neq,
    List<Enum$CounterLevelEnum>? $_nin,
  });
}

class _CopyWithImpl$Input$CounterLevelEnumComparisonExp<TRes>
    implements CopyWith$Input$CounterLevelEnumComparisonExp<TRes> {
  _CopyWithImpl$Input$CounterLevelEnumComparisonExp(
    this._instance,
    this._then,
  );

  final Input$CounterLevelEnumComparisonExp _instance;

  final TRes Function(Input$CounterLevelEnumComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$CounterLevelEnumComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Enum$CounterLevelEnum?),
        if ($_in != _undefined) '_in': ($_in as List<Enum$CounterLevelEnum>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as Enum$CounterLevelEnum?),
        if ($_nin != _undefined)
          '_nin': ($_nin as List<Enum$CounterLevelEnum>?),
      }));
}

class _CopyWithStubImpl$Input$CounterLevelEnumComparisonExp<TRes>
    implements CopyWith$Input$CounterLevelEnumComparisonExp<TRes> {
  _CopyWithStubImpl$Input$CounterLevelEnumComparisonExp(this._res);

  TRes _res;

  call({
    Enum$CounterLevelEnum? $_eq,
    List<Enum$CounterLevelEnum>? $_in,
    bool? $_isNull,
    Enum$CounterLevelEnum? $_neq,
    List<Enum$CounterLevelEnum>? $_nin,
  }) =>
      _res;
}

class Input$EventAggregateBoolExp {
  factory Input$EventAggregateBoolExp(
          {Input$eventAggregateBoolExpCount? count}) =>
      Input$EventAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$EventAggregateBoolExp._(this._$data);

  factory Input$EventAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$eventAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$EventAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$eventAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$eventAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EventAggregateBoolExp<Input$EventAggregateBoolExp>
      get copyWith => CopyWith$Input$EventAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$EventAggregateBoolExp<TRes> {
  factory CopyWith$Input$EventAggregateBoolExp(
    Input$EventAggregateBoolExp instance,
    TRes Function(Input$EventAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$EventAggregateBoolExp;

  factory CopyWith$Input$EventAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$EventAggregateBoolExp;

  TRes call({Input$eventAggregateBoolExpCount? count});
  CopyWith$Input$eventAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$EventAggregateBoolExp<TRes>
    implements CopyWith$Input$EventAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$EventAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$EventAggregateBoolExp _instance;

  final TRes Function(Input$EventAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$EventAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$eventAggregateBoolExpCount?),
      }));

  CopyWith$Input$eventAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$eventAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$eventAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$EventAggregateBoolExp<TRes>
    implements CopyWith$Input$EventAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$EventAggregateBoolExp(this._res);

  TRes _res;

  call({Input$eventAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$eventAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$eventAggregateBoolExpCount.stub(_res);
}

class Input$eventAggregateBoolExpCount {
  factory Input$eventAggregateBoolExpCount({
    List<Enum$EventSelectColumn>? arguments,
    bool? distinct,
    Input$EventBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$eventAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$eventAggregateBoolExpCount._(this._$data);

  factory Input$eventAggregateBoolExpCount.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$EventSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$EventBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$eventAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$EventSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$EventSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$EventBoolExp? get filter => (_$data['filter'] as Input$EventBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] =
          l$arguments?.map((e) => toJson$Enum$EventSelectColumn(e)).toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$eventAggregateBoolExpCount<Input$eventAggregateBoolExpCount>
      get copyWith => CopyWith$Input$eventAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$eventAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$eventAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$eventAggregateBoolExpCount(
    Input$eventAggregateBoolExpCount instance,
    TRes Function(Input$eventAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$eventAggregateBoolExpCount;

  factory CopyWith$Input$eventAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$eventAggregateBoolExpCount;

  TRes call({
    List<Enum$EventSelectColumn>? arguments,
    bool? distinct,
    Input$EventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$EventBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$eventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$eventAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$eventAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$eventAggregateBoolExpCount _instance;

  final TRes Function(Input$eventAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$eventAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$EventSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$EventBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$EventBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$eventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$eventAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$eventAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$EventSelectColumn>? arguments,
    bool? distinct,
    Input$EventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$EventBoolExp<TRes> get filter =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$EventAggregateOrderBy {
  factory Input$EventAggregateOrderBy({
    Input$EventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$EventMaxOrderBy? max,
    Input$EventMinOrderBy? min,
    Input$EventStddevOrderBy? stddev,
    Input$EventStddevPopOrderBy? stddevPop,
    Input$EventStddevSampOrderBy? stddevSamp,
    Input$EventSumOrderBy? sum,
    Input$EventVarPopOrderBy? varPop,
    Input$EventVarSampOrderBy? varSamp,
    Input$EventVarianceOrderBy? variance,
  }) =>
      Input$EventAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$EventAggregateOrderBy._(this._$data);

  factory Input$EventAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$EventAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$EventMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$EventMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$EventStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$EventStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$EventStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$EventSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$EventVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$EventVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$EventVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$EventAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EventAvgOrderBy? get avg => (_$data['avg'] as Input$EventAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$EventMaxOrderBy? get max => (_$data['max'] as Input$EventMaxOrderBy?);

  Input$EventMinOrderBy? get min => (_$data['min'] as Input$EventMinOrderBy?);

  Input$EventStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$EventStddevOrderBy?);

  Input$EventStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$EventStddevPopOrderBy?);

  Input$EventStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$EventStddevSampOrderBy?);

  Input$EventSumOrderBy? get sum => (_$data['sum'] as Input$EventSumOrderBy?);

  Input$EventVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$EventVarPopOrderBy?);

  Input$EventVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$EventVarSampOrderBy?);

  Input$EventVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$EventVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EventAggregateOrderBy<Input$EventAggregateOrderBy>
      get copyWith => CopyWith$Input$EventAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventAggregateOrderBy<TRes> {
  factory CopyWith$Input$EventAggregateOrderBy(
    Input$EventAggregateOrderBy instance,
    TRes Function(Input$EventAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$EventAggregateOrderBy;

  factory CopyWith$Input$EventAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventAggregateOrderBy;

  TRes call({
    Input$EventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$EventMaxOrderBy? max,
    Input$EventMinOrderBy? min,
    Input$EventStddevOrderBy? stddev,
    Input$EventStddevPopOrderBy? stddevPop,
    Input$EventStddevSampOrderBy? stddevSamp,
    Input$EventSumOrderBy? sum,
    Input$EventVarPopOrderBy? varPop,
    Input$EventVarSampOrderBy? varSamp,
    Input$EventVarianceOrderBy? variance,
  });
  CopyWith$Input$EventAvgOrderBy<TRes> get avg;
  CopyWith$Input$EventMaxOrderBy<TRes> get max;
  CopyWith$Input$EventMinOrderBy<TRes> get min;
  CopyWith$Input$EventStddevOrderBy<TRes> get stddev;
  CopyWith$Input$EventStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$EventStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$EventSumOrderBy<TRes> get sum;
  CopyWith$Input$EventVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$EventVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$EventVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$EventAggregateOrderBy<TRes>
    implements CopyWith$Input$EventAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$EventAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventAggregateOrderBy _instance;

  final TRes Function(Input$EventAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$EventAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$EventAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$EventMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$EventMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$EventStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$EventStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$EventStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$EventSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$EventVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$EventVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$EventVarianceOrderBy?),
      }));

  CopyWith$Input$EventAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$EventAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$EventMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$EventMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$EventMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$EventMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$EventStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$EventStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$EventStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$EventStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$EventStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$EventStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$EventSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$EventSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$EventVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$EventVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$EventVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$EventVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$EventVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$EventVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$EventAggregateOrderBy<TRes>
    implements CopyWith$Input$EventAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$EventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$EventMaxOrderBy? max,
    Input$EventMinOrderBy? min,
    Input$EventStddevOrderBy? stddev,
    Input$EventStddevPopOrderBy? stddevPop,
    Input$EventStddevSampOrderBy? stddevSamp,
    Input$EventSumOrderBy? sum,
    Input$EventVarPopOrderBy? varPop,
    Input$EventVarSampOrderBy? varSamp,
    Input$EventVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$EventAvgOrderBy<TRes> get avg =>
      CopyWith$Input$EventAvgOrderBy.stub(_res);

  CopyWith$Input$EventMaxOrderBy<TRes> get max =>
      CopyWith$Input$EventMaxOrderBy.stub(_res);

  CopyWith$Input$EventMinOrderBy<TRes> get min =>
      CopyWith$Input$EventMinOrderBy.stub(_res);

  CopyWith$Input$EventStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$EventStddevOrderBy.stub(_res);

  CopyWith$Input$EventStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$EventStddevPopOrderBy.stub(_res);

  CopyWith$Input$EventStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$EventStddevSampOrderBy.stub(_res);

  CopyWith$Input$EventSumOrderBy<TRes> get sum =>
      CopyWith$Input$EventSumOrderBy.stub(_res);

  CopyWith$Input$EventVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$EventVarPopOrderBy.stub(_res);

  CopyWith$Input$EventVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$EventVarSampOrderBy.stub(_res);

  CopyWith$Input$EventVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$EventVarianceOrderBy.stub(_res);
}

class Input$EventAvgOrderBy {
  factory Input$EventAvgOrderBy({Enum$OrderBy? index}) =>
      Input$EventAvgOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventAvgOrderBy._(this._$data);

  factory Input$EventAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventAvgOrderBy<Input$EventAvgOrderBy> get copyWith =>
      CopyWith$Input$EventAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventAvgOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventAvgOrderBy<TRes> {
  factory CopyWith$Input$EventAvgOrderBy(
    Input$EventAvgOrderBy instance,
    TRes Function(Input$EventAvgOrderBy) then,
  ) = _CopyWithImpl$Input$EventAvgOrderBy;

  factory CopyWith$Input$EventAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventAvgOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventAvgOrderBy<TRes>
    implements CopyWith$Input$EventAvgOrderBy<TRes> {
  _CopyWithImpl$Input$EventAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventAvgOrderBy _instance;

  final TRes Function(Input$EventAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) => _then(Input$EventAvgOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventAvgOrderBy<TRes>
    implements CopyWith$Input$EventAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventAvgOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventBoolExp {
  factory Input$EventBoolExp({
    List<Input$EventBoolExp>? $_and,
    Input$EventBoolExp? $_not,
    List<Input$EventBoolExp>? $_or,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$StringComparisonExp? phase,
  }) =>
      Input$EventBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (args != null) r'args': args,
        if (argsStr != null) r'argsStr': argsStr,
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if ($call != null) r'call': $call,
        if (callId != null) r'callId': callId,
        if (extrinsic != null) r'extrinsic': extrinsic,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (phase != null) r'phase': phase,
      });

  Input$EventBoolExp._(this._$data);

  factory Input$EventBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$EventBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$EventBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$EventBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('args')) {
      final l$args = data['args'];
      result$data['args'] = l$args == null
          ? null
          : Input$JsonbComparisonExp.fromJson((l$args as Map<String, dynamic>));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : Input$StringArrayComparisonExp.fromJson(
              (l$argsStr as Map<String, dynamic>));
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockBoolExp.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$blockId as Map<String, dynamic>));
    }
    if (data.containsKey('call')) {
      final l$$call = data['call'];
      result$data['call'] = l$$call == null
          ? null
          : Input$CallBoolExp.fromJson((l$$call as Map<String, dynamic>));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] = l$callId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$callId as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsic')) {
      final l$extrinsic = data['extrinsic'];
      result$data['extrinsic'] = l$extrinsic == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson(
              (l$extrinsic as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$extrinsicId as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntComparisonExp.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] = l$pallet == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$pallet as Map<String, dynamic>));
    }
    if (data.containsKey('phase')) {
      final l$phase = data['phase'];
      result$data['phase'] = l$phase == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$phase as Map<String, dynamic>));
    }
    return Input$EventBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EventBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$EventBoolExp>?);

  Input$EventBoolExp? get $_not => (_$data['_not'] as Input$EventBoolExp?);

  List<Input$EventBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$EventBoolExp>?);

  Input$JsonbComparisonExp? get args =>
      (_$data['args'] as Input$JsonbComparisonExp?);

  Input$StringArrayComparisonExp? get argsStr =>
      (_$data['argsStr'] as Input$StringArrayComparisonExp?);

  Input$BlockBoolExp? get block => (_$data['block'] as Input$BlockBoolExp?);

  Input$StringComparisonExp? get blockId =>
      (_$data['blockId'] as Input$StringComparisonExp?);

  Input$CallBoolExp? get $call => (_$data['call'] as Input$CallBoolExp?);

  Input$StringComparisonExp? get callId =>
      (_$data['callId'] as Input$StringComparisonExp?);

  Input$ExtrinsicBoolExp? get extrinsic =>
      (_$data['extrinsic'] as Input$ExtrinsicBoolExp?);

  Input$StringComparisonExp? get extrinsicId =>
      (_$data['extrinsicId'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get index =>
      (_$data['index'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get name =>
      (_$data['name'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get pallet =>
      (_$data['pallet'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get phase =>
      (_$data['phase'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('args')) {
      final l$args = args;
      result$data['args'] = l$args?.toJson();
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] = l$argsStr?.toJson();
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] = l$blockId?.toJson();
    }
    if (_$data.containsKey('call')) {
      final l$$call = $call;
      result$data['call'] = l$$call?.toJson();
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] = l$callId?.toJson();
    }
    if (_$data.containsKey('extrinsic')) {
      final l$extrinsic = extrinsic;
      result$data['extrinsic'] = l$extrinsic?.toJson();
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] = l$extrinsicId?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] = l$pallet?.toJson();
    }
    if (_$data.containsKey('phase')) {
      final l$phase = phase;
      result$data['phase'] = l$phase?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EventBoolExp<Input$EventBoolExp> get copyWith =>
      CopyWith$Input$EventBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$args = args;
    final lOther$args = other.args;
    if (_$data.containsKey('args') != other._$data.containsKey('args')) {
      return false;
    }
    if (l$args != lOther$args) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$$call = $call;
    final lOther$$call = other.$call;
    if (_$data.containsKey('call') != other._$data.containsKey('call')) {
      return false;
    }
    if (l$$call != lOther$$call) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$extrinsic = extrinsic;
    final lOther$extrinsic = other.extrinsic;
    if (_$data.containsKey('extrinsic') !=
        other._$data.containsKey('extrinsic')) {
      return false;
    }
    if (l$extrinsic != lOther$extrinsic) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$phase = phase;
    final lOther$phase = other.phase;
    if (_$data.containsKey('phase') != other._$data.containsKey('phase')) {
      return false;
    }
    if (l$phase != lOther$phase) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$args = args;
    final l$argsStr = argsStr;
    final l$block = block;
    final l$blockId = blockId;
    final l$$call = $call;
    final l$callId = callId;
    final l$extrinsic = extrinsic;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$index = index;
    final l$name = name;
    final l$pallet = pallet;
    final l$phase = phase;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('args') ? l$args : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('call') ? l$$call : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('extrinsic') ? l$extrinsic : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('phase') ? l$phase : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventBoolExp<TRes> {
  factory CopyWith$Input$EventBoolExp(
    Input$EventBoolExp instance,
    TRes Function(Input$EventBoolExp) then,
  ) = _CopyWithImpl$Input$EventBoolExp;

  factory CopyWith$Input$EventBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$EventBoolExp;

  TRes call({
    List<Input$EventBoolExp>? $_and,
    Input$EventBoolExp? $_not,
    List<Input$EventBoolExp>? $_or,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$StringComparisonExp? phase,
  });
  TRes $_and(
      Iterable<Input$EventBoolExp>? Function(
              Iterable<CopyWith$Input$EventBoolExp<Input$EventBoolExp>>?)
          _fn);
  CopyWith$Input$EventBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$EventBoolExp>? Function(
              Iterable<CopyWith$Input$EventBoolExp<Input$EventBoolExp>>?)
          _fn);
  CopyWith$Input$JsonbComparisonExp<TRes> get args;
  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr;
  CopyWith$Input$BlockBoolExp<TRes> get block;
  CopyWith$Input$StringComparisonExp<TRes> get blockId;
  CopyWith$Input$CallBoolExp<TRes> get $call;
  CopyWith$Input$StringComparisonExp<TRes> get callId;
  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic;
  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IntComparisonExp<TRes> get index;
  CopyWith$Input$StringComparisonExp<TRes> get name;
  CopyWith$Input$StringComparisonExp<TRes> get pallet;
  CopyWith$Input$StringComparisonExp<TRes> get phase;
}

class _CopyWithImpl$Input$EventBoolExp<TRes>
    implements CopyWith$Input$EventBoolExp<TRes> {
  _CopyWithImpl$Input$EventBoolExp(
    this._instance,
    this._then,
  );

  final Input$EventBoolExp _instance;

  final TRes Function(Input$EventBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? args = _undefined,
    Object? argsStr = _undefined,
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? $call = _undefined,
    Object? callId = _undefined,
    Object? extrinsic = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? phase = _undefined,
  }) =>
      _then(Input$EventBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<Input$EventBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$EventBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$EventBoolExp>?),
        if (args != _undefined) 'args': (args as Input$JsonbComparisonExp?),
        if (argsStr != _undefined)
          'argsStr': (argsStr as Input$StringArrayComparisonExp?),
        if (block != _undefined) 'block': (block as Input$BlockBoolExp?),
        if (blockId != _undefined)
          'blockId': (blockId as Input$StringComparisonExp?),
        if ($call != _undefined) 'call': ($call as Input$CallBoolExp?),
        if (callId != _undefined)
          'callId': (callId as Input$StringComparisonExp?),
        if (extrinsic != _undefined)
          'extrinsic': (extrinsic as Input$ExtrinsicBoolExp?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Input$StringComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (index != _undefined) 'index': (index as Input$IntComparisonExp?),
        if (name != _undefined) 'name': (name as Input$StringComparisonExp?),
        if (pallet != _undefined)
          'pallet': (pallet as Input$StringComparisonExp?),
        if (phase != _undefined) 'phase': (phase as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$EventBoolExp>? Function(
                  Iterable<CopyWith$Input$EventBoolExp<Input$EventBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$EventBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$EventBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$EventBoolExp>? Function(
                  Iterable<CopyWith$Input$EventBoolExp<Input$EventBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$EventBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$JsonbComparisonExp<TRes> get args {
    final local$args = _instance.args;
    return local$args == null
        ? CopyWith$Input$JsonbComparisonExp.stub(_then(_instance))
        : CopyWith$Input$JsonbComparisonExp(local$args, (e) => call(args: e));
  }

  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr {
    final local$argsStr = _instance.argsStr;
    return local$argsStr == null
        ? CopyWith$Input$StringArrayComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringArrayComparisonExp(
            local$argsStr, (e) => call(argsStr: e));
  }

  CopyWith$Input$BlockBoolExp<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockBoolExp.stub(_then(_instance))
        : CopyWith$Input$BlockBoolExp(local$block, (e) => call(block: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get blockId {
    final local$blockId = _instance.blockId;
    return local$blockId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$blockId, (e) => call(blockId: e));
  }

  CopyWith$Input$CallBoolExp<TRes> get $call {
    final local$$call = _instance.$call;
    return local$$call == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$$call, (e) => call($call: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get callId {
    final local$callId = _instance.callId;
    return local$callId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$callId, (e) => call(callId: e));
  }

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic {
    final local$extrinsic = _instance.extrinsic;
    return local$extrinsic == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(
            local$extrinsic, (e) => call(extrinsic: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId {
    final local$extrinsicId = _instance.extrinsicId;
    return local$extrinsicId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$extrinsicId, (e) => call(extrinsicId: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$index, (e) => call(index: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get pallet {
    final local$pallet = _instance.pallet;
    return local$pallet == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$pallet, (e) => call(pallet: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get phase {
    final local$phase = _instance.phase;
    return local$phase == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$phase, (e) => call(phase: e));
  }
}

class _CopyWithStubImpl$Input$EventBoolExp<TRes>
    implements CopyWith$Input$EventBoolExp<TRes> {
  _CopyWithStubImpl$Input$EventBoolExp(this._res);

  TRes _res;

  call({
    List<Input$EventBoolExp>? $_and,
    Input$EventBoolExp? $_not,
    List<Input$EventBoolExp>? $_or,
    Input$JsonbComparisonExp? args,
    Input$StringArrayComparisonExp? argsStr,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$ExtrinsicBoolExp? extrinsic,
    Input$StringComparisonExp? extrinsicId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$StringComparisonExp? name,
    Input$StringComparisonExp? pallet,
    Input$StringComparisonExp? phase,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$EventBoolExp<TRes> get $_not =>
      CopyWith$Input$EventBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$JsonbComparisonExp<TRes> get args =>
      CopyWith$Input$JsonbComparisonExp.stub(_res);

  CopyWith$Input$StringArrayComparisonExp<TRes> get argsStr =>
      CopyWith$Input$StringArrayComparisonExp.stub(_res);

  CopyWith$Input$BlockBoolExp<TRes> get block =>
      CopyWith$Input$BlockBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get blockId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CallBoolExp<TRes> get $call =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get callId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$ExtrinsicBoolExp<TRes> get extrinsic =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get extrinsicId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get index =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get name =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get pallet =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get phase =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$EventMaxOrderBy {
  factory Input$EventMaxOrderBy({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      Input$EventMaxOrderBy._({
        if (argsStr != null) r'argsStr': argsStr,
        if (blockId != null) r'blockId': blockId,
        if (callId != null) r'callId': callId,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (phase != null) r'phase': phase,
      });

  Input$EventMaxOrderBy._(this._$data);

  factory Input$EventMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('phase')) {
      final l$phase = data['phase'];
      result$data['phase'] =
          l$phase == null ? null : fromJson$Enum$OrderBy((l$phase as String));
    }
    return Input$EventMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Enum$OrderBy? get phase => (_$data['phase'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('phase')) {
      final l$phase = phase;
      result$data['phase'] =
          l$phase == null ? null : toJson$Enum$OrderBy(l$phase);
    }
    return result$data;
  }

  CopyWith$Input$EventMaxOrderBy<Input$EventMaxOrderBy> get copyWith =>
      CopyWith$Input$EventMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventMaxOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$phase = phase;
    final lOther$phase = other.phase;
    if (_$data.containsKey('phase') != other._$data.containsKey('phase')) {
      return false;
    }
    if (l$phase != lOther$phase) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$argsStr = argsStr;
    final l$blockId = blockId;
    final l$callId = callId;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$index = index;
    final l$name = name;
    final l$pallet = pallet;
    final l$phase = phase;
    return Object.hashAll([
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('phase') ? l$phase : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventMaxOrderBy<TRes> {
  factory CopyWith$Input$EventMaxOrderBy(
    Input$EventMaxOrderBy instance,
    TRes Function(Input$EventMaxOrderBy) then,
  ) = _CopyWithImpl$Input$EventMaxOrderBy;

  factory CopyWith$Input$EventMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventMaxOrderBy;

  TRes call({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  });
}

class _CopyWithImpl$Input$EventMaxOrderBy<TRes>
    implements CopyWith$Input$EventMaxOrderBy<TRes> {
  _CopyWithImpl$Input$EventMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventMaxOrderBy _instance;

  final TRes Function(Input$EventMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? argsStr = _undefined,
    Object? blockId = _undefined,
    Object? callId = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? phase = _undefined,
  }) =>
      _then(Input$EventMaxOrderBy._({
        ..._instance._$data,
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (phase != _undefined) 'phase': (phase as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventMaxOrderBy<TRes>
    implements CopyWith$Input$EventMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      _res;
}

class Input$EventMinOrderBy {
  factory Input$EventMinOrderBy({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      Input$EventMinOrderBy._({
        if (argsStr != null) r'argsStr': argsStr,
        if (blockId != null) r'blockId': blockId,
        if (callId != null) r'callId': callId,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (phase != null) r'phase': phase,
      });

  Input$EventMinOrderBy._(this._$data);

  factory Input$EventMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('phase')) {
      final l$phase = data['phase'];
      result$data['phase'] =
          l$phase == null ? null : fromJson$Enum$OrderBy((l$phase as String));
    }
    return Input$EventMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Enum$OrderBy? get phase => (_$data['phase'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('phase')) {
      final l$phase = phase;
      result$data['phase'] =
          l$phase == null ? null : toJson$Enum$OrderBy(l$phase);
    }
    return result$data;
  }

  CopyWith$Input$EventMinOrderBy<Input$EventMinOrderBy> get copyWith =>
      CopyWith$Input$EventMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventMinOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$phase = phase;
    final lOther$phase = other.phase;
    if (_$data.containsKey('phase') != other._$data.containsKey('phase')) {
      return false;
    }
    if (l$phase != lOther$phase) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$argsStr = argsStr;
    final l$blockId = blockId;
    final l$callId = callId;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$index = index;
    final l$name = name;
    final l$pallet = pallet;
    final l$phase = phase;
    return Object.hashAll([
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('phase') ? l$phase : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventMinOrderBy<TRes> {
  factory CopyWith$Input$EventMinOrderBy(
    Input$EventMinOrderBy instance,
    TRes Function(Input$EventMinOrderBy) then,
  ) = _CopyWithImpl$Input$EventMinOrderBy;

  factory CopyWith$Input$EventMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventMinOrderBy;

  TRes call({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  });
}

class _CopyWithImpl$Input$EventMinOrderBy<TRes>
    implements CopyWith$Input$EventMinOrderBy<TRes> {
  _CopyWithImpl$Input$EventMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventMinOrderBy _instance;

  final TRes Function(Input$EventMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? argsStr = _undefined,
    Object? blockId = _undefined,
    Object? callId = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? phase = _undefined,
  }) =>
      _then(Input$EventMinOrderBy._({
        ..._instance._$data,
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (phase != _undefined) 'phase': (phase as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventMinOrderBy<TRes>
    implements CopyWith$Input$EventMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? argsStr,
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      _res;
}

class Input$EventOrderBy {
  factory Input$EventOrderBy({
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      Input$EventOrderBy._({
        if (args != null) r'args': args,
        if (argsStr != null) r'argsStr': argsStr,
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if ($call != null) r'call': $call,
        if (callId != null) r'callId': callId,
        if (extrinsic != null) r'extrinsic': extrinsic,
        if (extrinsicId != null) r'extrinsicId': extrinsicId,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (name != null) r'name': name,
        if (pallet != null) r'pallet': pallet,
        if (phase != null) r'phase': phase,
      });

  Input$EventOrderBy._(this._$data);

  factory Input$EventOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('args')) {
      final l$args = data['args'];
      result$data['args'] =
          l$args == null ? null : fromJson$Enum$OrderBy((l$args as String));
    }
    if (data.containsKey('argsStr')) {
      final l$argsStr = data['argsStr'];
      result$data['argsStr'] = l$argsStr == null
          ? null
          : fromJson$Enum$OrderBy((l$argsStr as String));
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockOrderBy.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('call')) {
      final l$$call = data['call'];
      result$data['call'] = l$$call == null
          ? null
          : Input$CallOrderBy.fromJson((l$$call as Map<String, dynamic>));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('extrinsic')) {
      final l$extrinsic = data['extrinsic'];
      result$data['extrinsic'] = l$extrinsic == null
          ? null
          : Input$ExtrinsicOrderBy.fromJson(
              (l$extrinsic as Map<String, dynamic>));
    }
    if (data.containsKey('extrinsicId')) {
      final l$extrinsicId = data['extrinsicId'];
      result$data['extrinsicId'] = l$extrinsicId == null
          ? null
          : fromJson$Enum$OrderBy((l$extrinsicId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('pallet')) {
      final l$pallet = data['pallet'];
      result$data['pallet'] =
          l$pallet == null ? null : fromJson$Enum$OrderBy((l$pallet as String));
    }
    if (data.containsKey('phase')) {
      final l$phase = data['phase'];
      result$data['phase'] =
          l$phase == null ? null : fromJson$Enum$OrderBy((l$phase as String));
    }
    return Input$EventOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get args => (_$data['args'] as Enum$OrderBy?);

  Enum$OrderBy? get argsStr => (_$data['argsStr'] as Enum$OrderBy?);

  Input$BlockOrderBy? get block => (_$data['block'] as Input$BlockOrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Input$CallOrderBy? get $call => (_$data['call'] as Input$CallOrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Input$ExtrinsicOrderBy? get extrinsic =>
      (_$data['extrinsic'] as Input$ExtrinsicOrderBy?);

  Enum$OrderBy? get extrinsicId => (_$data['extrinsicId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Enum$OrderBy? get pallet => (_$data['pallet'] as Enum$OrderBy?);

  Enum$OrderBy? get phase => (_$data['phase'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('args')) {
      final l$args = args;
      result$data['args'] = l$args == null ? null : toJson$Enum$OrderBy(l$args);
    }
    if (_$data.containsKey('argsStr')) {
      final l$argsStr = argsStr;
      result$data['argsStr'] =
          l$argsStr == null ? null : toJson$Enum$OrderBy(l$argsStr);
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('call')) {
      final l$$call = $call;
      result$data['call'] = l$$call?.toJson();
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('extrinsic')) {
      final l$extrinsic = extrinsic;
      result$data['extrinsic'] = l$extrinsic?.toJson();
    }
    if (_$data.containsKey('extrinsicId')) {
      final l$extrinsicId = extrinsicId;
      result$data['extrinsicId'] =
          l$extrinsicId == null ? null : toJson$Enum$OrderBy(l$extrinsicId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('pallet')) {
      final l$pallet = pallet;
      result$data['pallet'] =
          l$pallet == null ? null : toJson$Enum$OrderBy(l$pallet);
    }
    if (_$data.containsKey('phase')) {
      final l$phase = phase;
      result$data['phase'] =
          l$phase == null ? null : toJson$Enum$OrderBy(l$phase);
    }
    return result$data;
  }

  CopyWith$Input$EventOrderBy<Input$EventOrderBy> get copyWith =>
      CopyWith$Input$EventOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$args = args;
    final lOther$args = other.args;
    if (_$data.containsKey('args') != other._$data.containsKey('args')) {
      return false;
    }
    if (l$args != lOther$args) {
      return false;
    }
    final l$argsStr = argsStr;
    final lOther$argsStr = other.argsStr;
    if (_$data.containsKey('argsStr') != other._$data.containsKey('argsStr')) {
      return false;
    }
    if (l$argsStr != lOther$argsStr) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$$call = $call;
    final lOther$$call = other.$call;
    if (_$data.containsKey('call') != other._$data.containsKey('call')) {
      return false;
    }
    if (l$$call != lOther$$call) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$extrinsic = extrinsic;
    final lOther$extrinsic = other.extrinsic;
    if (_$data.containsKey('extrinsic') !=
        other._$data.containsKey('extrinsic')) {
      return false;
    }
    if (l$extrinsic != lOther$extrinsic) {
      return false;
    }
    final l$extrinsicId = extrinsicId;
    final lOther$extrinsicId = other.extrinsicId;
    if (_$data.containsKey('extrinsicId') !=
        other._$data.containsKey('extrinsicId')) {
      return false;
    }
    if (l$extrinsicId != lOther$extrinsicId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$pallet = pallet;
    final lOther$pallet = other.pallet;
    if (_$data.containsKey('pallet') != other._$data.containsKey('pallet')) {
      return false;
    }
    if (l$pallet != lOther$pallet) {
      return false;
    }
    final l$phase = phase;
    final lOther$phase = other.phase;
    if (_$data.containsKey('phase') != other._$data.containsKey('phase')) {
      return false;
    }
    if (l$phase != lOther$phase) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$args = args;
    final l$argsStr = argsStr;
    final l$block = block;
    final l$blockId = blockId;
    final l$$call = $call;
    final l$callId = callId;
    final l$extrinsic = extrinsic;
    final l$extrinsicId = extrinsicId;
    final l$id = id;
    final l$index = index;
    final l$name = name;
    final l$pallet = pallet;
    final l$phase = phase;
    return Object.hashAll([
      _$data.containsKey('args') ? l$args : const {},
      _$data.containsKey('argsStr') ? l$argsStr : const {},
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('call') ? l$$call : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('extrinsic') ? l$extrinsic : const {},
      _$data.containsKey('extrinsicId') ? l$extrinsicId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('pallet') ? l$pallet : const {},
      _$data.containsKey('phase') ? l$phase : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventOrderBy<TRes> {
  factory CopyWith$Input$EventOrderBy(
    Input$EventOrderBy instance,
    TRes Function(Input$EventOrderBy) then,
  ) = _CopyWithImpl$Input$EventOrderBy;

  factory CopyWith$Input$EventOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventOrderBy;

  TRes call({
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  });
  CopyWith$Input$BlockOrderBy<TRes> get block;
  CopyWith$Input$CallOrderBy<TRes> get $call;
  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic;
}

class _CopyWithImpl$Input$EventOrderBy<TRes>
    implements CopyWith$Input$EventOrderBy<TRes> {
  _CopyWithImpl$Input$EventOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventOrderBy _instance;

  final TRes Function(Input$EventOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? args = _undefined,
    Object? argsStr = _undefined,
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? $call = _undefined,
    Object? callId = _undefined,
    Object? extrinsic = _undefined,
    Object? extrinsicId = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? name = _undefined,
    Object? pallet = _undefined,
    Object? phase = _undefined,
  }) =>
      _then(Input$EventOrderBy._({
        ..._instance._$data,
        if (args != _undefined) 'args': (args as Enum$OrderBy?),
        if (argsStr != _undefined) 'argsStr': (argsStr as Enum$OrderBy?),
        if (block != _undefined) 'block': (block as Input$BlockOrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if ($call != _undefined) 'call': ($call as Input$CallOrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (extrinsic != _undefined)
          'extrinsic': (extrinsic as Input$ExtrinsicOrderBy?),
        if (extrinsicId != _undefined)
          'extrinsicId': (extrinsicId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (pallet != _undefined) 'pallet': (pallet as Enum$OrderBy?),
        if (phase != _undefined) 'phase': (phase as Enum$OrderBy?),
      }));

  CopyWith$Input$BlockOrderBy<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockOrderBy.stub(_then(_instance))
        : CopyWith$Input$BlockOrderBy(local$block, (e) => call(block: e));
  }

  CopyWith$Input$CallOrderBy<TRes> get $call {
    final local$$call = _instance.$call;
    return local$$call == null
        ? CopyWith$Input$CallOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallOrderBy(local$$call, (e) => call($call: e));
  }

  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic {
    final local$extrinsic = _instance.extrinsic;
    return local$extrinsic == null
        ? CopyWith$Input$ExtrinsicOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicOrderBy(
            local$extrinsic, (e) => call(extrinsic: e));
  }
}

class _CopyWithStubImpl$Input$EventOrderBy<TRes>
    implements CopyWith$Input$EventOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? args,
    Enum$OrderBy? argsStr,
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$ExtrinsicOrderBy? extrinsic,
    Enum$OrderBy? extrinsicId,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? name,
    Enum$OrderBy? pallet,
    Enum$OrderBy? phase,
  }) =>
      _res;

  CopyWith$Input$BlockOrderBy<TRes> get block =>
      CopyWith$Input$BlockOrderBy.stub(_res);

  CopyWith$Input$CallOrderBy<TRes> get $call =>
      CopyWith$Input$CallOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicOrderBy<TRes> get extrinsic =>
      CopyWith$Input$ExtrinsicOrderBy.stub(_res);
}

class Input$EventStddevOrderBy {
  factory Input$EventStddevOrderBy({Enum$OrderBy? index}) =>
      Input$EventStddevOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventStddevOrderBy._(this._$data);

  factory Input$EventStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventStddevOrderBy<Input$EventStddevOrderBy> get copyWith =>
      CopyWith$Input$EventStddevOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventStddevOrderBy<TRes> {
  factory CopyWith$Input$EventStddevOrderBy(
    Input$EventStddevOrderBy instance,
    TRes Function(Input$EventStddevOrderBy) then,
  ) = _CopyWithImpl$Input$EventStddevOrderBy;

  factory CopyWith$Input$EventStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventStddevOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventStddevOrderBy<TRes>
    implements CopyWith$Input$EventStddevOrderBy<TRes> {
  _CopyWithImpl$Input$EventStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventStddevOrderBy _instance;

  final TRes Function(Input$EventStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) => _then(Input$EventStddevOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventStddevOrderBy<TRes>
    implements CopyWith$Input$EventStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventStddevOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventStddevPopOrderBy {
  factory Input$EventStddevPopOrderBy({Enum$OrderBy? index}) =>
      Input$EventStddevPopOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventStddevPopOrderBy._(this._$data);

  factory Input$EventStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventStddevPopOrderBy<Input$EventStddevPopOrderBy>
      get copyWith => CopyWith$Input$EventStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventStddevPopOrderBy<TRes> {
  factory CopyWith$Input$EventStddevPopOrderBy(
    Input$EventStddevPopOrderBy instance,
    TRes Function(Input$EventStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$EventStddevPopOrderBy;

  factory CopyWith$Input$EventStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventStddevPopOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventStddevPopOrderBy<TRes>
    implements CopyWith$Input$EventStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$EventStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventStddevPopOrderBy _instance;

  final TRes Function(Input$EventStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) =>
      _then(Input$EventStddevPopOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventStddevPopOrderBy<TRes>
    implements CopyWith$Input$EventStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventStddevPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventStddevSampOrderBy {
  factory Input$EventStddevSampOrderBy({Enum$OrderBy? index}) =>
      Input$EventStddevSampOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventStddevSampOrderBy._(this._$data);

  factory Input$EventStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventStddevSampOrderBy<Input$EventStddevSampOrderBy>
      get copyWith => CopyWith$Input$EventStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventStddevSampOrderBy<TRes> {
  factory CopyWith$Input$EventStddevSampOrderBy(
    Input$EventStddevSampOrderBy instance,
    TRes Function(Input$EventStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$EventStddevSampOrderBy;

  factory CopyWith$Input$EventStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventStddevSampOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventStddevSampOrderBy<TRes>
    implements CopyWith$Input$EventStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$EventStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventStddevSampOrderBy _instance;

  final TRes Function(Input$EventStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) =>
      _then(Input$EventStddevSampOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventStddevSampOrderBy<TRes>
    implements CopyWith$Input$EventStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventStddevSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventSumOrderBy {
  factory Input$EventSumOrderBy({Enum$OrderBy? index}) =>
      Input$EventSumOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventSumOrderBy._(this._$data);

  factory Input$EventSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventSumOrderBy<Input$EventSumOrderBy> get copyWith =>
      CopyWith$Input$EventSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventSumOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventSumOrderBy<TRes> {
  factory CopyWith$Input$EventSumOrderBy(
    Input$EventSumOrderBy instance,
    TRes Function(Input$EventSumOrderBy) then,
  ) = _CopyWithImpl$Input$EventSumOrderBy;

  factory CopyWith$Input$EventSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventSumOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventSumOrderBy<TRes>
    implements CopyWith$Input$EventSumOrderBy<TRes> {
  _CopyWithImpl$Input$EventSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventSumOrderBy _instance;

  final TRes Function(Input$EventSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) => _then(Input$EventSumOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventSumOrderBy<TRes>
    implements CopyWith$Input$EventSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventSumOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventTypeEnumComparisonExp {
  factory Input$EventTypeEnumComparisonExp({
    Enum$EventTypeEnum? $_eq,
    List<Enum$EventTypeEnum>? $_in,
    bool? $_isNull,
    Enum$EventTypeEnum? $_neq,
    List<Enum$EventTypeEnum>? $_nin,
  }) =>
      Input$EventTypeEnumComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$EventTypeEnumComparisonExp._(this._$data);

  factory Input$EventTypeEnumComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = l$$_eq == null
          ? null
          : fromJson$Enum$EventTypeEnum((l$$_eq as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$EventTypeEnum((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromJson$Enum$EventTypeEnum((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$EventTypeEnum((e as String)))
          .toList();
    }
    return Input$EventTypeEnumComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EventTypeEnum? get $_eq => (_$data['_eq'] as Enum$EventTypeEnum?);

  List<Enum$EventTypeEnum>? get $_in =>
      (_$data['_in'] as List<Enum$EventTypeEnum>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Enum$EventTypeEnum? get $_neq => (_$data['_neq'] as Enum$EventTypeEnum?);

  List<Enum$EventTypeEnum>? get $_nin =>
      (_$data['_nin'] as List<Enum$EventTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : toJson$Enum$EventTypeEnum(l$$_eq);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => toJson$Enum$EventTypeEnum(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] =
          l$$_neq == null ? null : toJson$Enum$EventTypeEnum(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => toJson$Enum$EventTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$EventTypeEnumComparisonExp<Input$EventTypeEnumComparisonExp>
      get copyWith => CopyWith$Input$EventTypeEnumComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventTypeEnumComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventTypeEnumComparisonExp<TRes> {
  factory CopyWith$Input$EventTypeEnumComparisonExp(
    Input$EventTypeEnumComparisonExp instance,
    TRes Function(Input$EventTypeEnumComparisonExp) then,
  ) = _CopyWithImpl$Input$EventTypeEnumComparisonExp;

  factory CopyWith$Input$EventTypeEnumComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$EventTypeEnumComparisonExp;

  TRes call({
    Enum$EventTypeEnum? $_eq,
    List<Enum$EventTypeEnum>? $_in,
    bool? $_isNull,
    Enum$EventTypeEnum? $_neq,
    List<Enum$EventTypeEnum>? $_nin,
  });
}

class _CopyWithImpl$Input$EventTypeEnumComparisonExp<TRes>
    implements CopyWith$Input$EventTypeEnumComparisonExp<TRes> {
  _CopyWithImpl$Input$EventTypeEnumComparisonExp(
    this._instance,
    this._then,
  );

  final Input$EventTypeEnumComparisonExp _instance;

  final TRes Function(Input$EventTypeEnumComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$EventTypeEnumComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Enum$EventTypeEnum?),
        if ($_in != _undefined) '_in': ($_in as List<Enum$EventTypeEnum>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as Enum$EventTypeEnum?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Enum$EventTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$EventTypeEnumComparisonExp<TRes>
    implements CopyWith$Input$EventTypeEnumComparisonExp<TRes> {
  _CopyWithStubImpl$Input$EventTypeEnumComparisonExp(this._res);

  TRes _res;

  call({
    Enum$EventTypeEnum? $_eq,
    List<Enum$EventTypeEnum>? $_in,
    bool? $_isNull,
    Enum$EventTypeEnum? $_neq,
    List<Enum$EventTypeEnum>? $_nin,
  }) =>
      _res;
}

class Input$EventVarianceOrderBy {
  factory Input$EventVarianceOrderBy({Enum$OrderBy? index}) =>
      Input$EventVarianceOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventVarianceOrderBy._(this._$data);

  factory Input$EventVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventVarianceOrderBy<Input$EventVarianceOrderBy>
      get copyWith => CopyWith$Input$EventVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventVarianceOrderBy<TRes> {
  factory CopyWith$Input$EventVarianceOrderBy(
    Input$EventVarianceOrderBy instance,
    TRes Function(Input$EventVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$EventVarianceOrderBy;

  factory CopyWith$Input$EventVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventVarianceOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventVarianceOrderBy<TRes>
    implements CopyWith$Input$EventVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$EventVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventVarianceOrderBy _instance;

  final TRes Function(Input$EventVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) =>
      _then(Input$EventVarianceOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventVarianceOrderBy<TRes>
    implements CopyWith$Input$EventVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventVarianceOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventVarPopOrderBy {
  factory Input$EventVarPopOrderBy({Enum$OrderBy? index}) =>
      Input$EventVarPopOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventVarPopOrderBy._(this._$data);

  factory Input$EventVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventVarPopOrderBy<Input$EventVarPopOrderBy> get copyWith =>
      CopyWith$Input$EventVarPopOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventVarPopOrderBy<TRes> {
  factory CopyWith$Input$EventVarPopOrderBy(
    Input$EventVarPopOrderBy instance,
    TRes Function(Input$EventVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$EventVarPopOrderBy;

  factory CopyWith$Input$EventVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventVarPopOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventVarPopOrderBy<TRes>
    implements CopyWith$Input$EventVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$EventVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventVarPopOrderBy _instance;

  final TRes Function(Input$EventVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) => _then(Input$EventVarPopOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventVarPopOrderBy<TRes>
    implements CopyWith$Input$EventVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventVarPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$EventVarSampOrderBy {
  factory Input$EventVarSampOrderBy({Enum$OrderBy? index}) =>
      Input$EventVarSampOrderBy._({
        if (index != null) r'index': index,
      });

  Input$EventVarSampOrderBy._(this._$data);

  factory Input$EventVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    return Input$EventVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    return result$data;
  }

  CopyWith$Input$EventVarSampOrderBy<Input$EventVarSampOrderBy> get copyWith =>
      CopyWith$Input$EventVarSampOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$index = index;
    return Object.hashAll([_$data.containsKey('index') ? l$index : const {}]);
  }
}

abstract class CopyWith$Input$EventVarSampOrderBy<TRes> {
  factory CopyWith$Input$EventVarSampOrderBy(
    Input$EventVarSampOrderBy instance,
    TRes Function(Input$EventVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$EventVarSampOrderBy;

  factory CopyWith$Input$EventVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$EventVarSampOrderBy;

  TRes call({Enum$OrderBy? index});
}

class _CopyWithImpl$Input$EventVarSampOrderBy<TRes>
    implements CopyWith$Input$EventVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$EventVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$EventVarSampOrderBy _instance;

  final TRes Function(Input$EventVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? index = _undefined}) => _then(Input$EventVarSampOrderBy._({
        ..._instance._$data,
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$EventVarSampOrderBy<TRes>
    implements CopyWith$Input$EventVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$EventVarSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? index}) => _res;
}

class Input$ExtrinsicAggregateBoolExp {
  factory Input$ExtrinsicAggregateBoolExp({
    Input$extrinsicAggregateBoolExpBool_and? bool_and,
    Input$extrinsicAggregateBoolExpBool_or? bool_or,
    Input$extrinsicAggregateBoolExpCount? count,
  }) =>
      Input$ExtrinsicAggregateBoolExp._({
        if (bool_and != null) r'bool_and': bool_and,
        if (bool_or != null) r'bool_or': bool_or,
        if (count != null) r'count': count,
      });

  Input$ExtrinsicAggregateBoolExp._(this._$data);

  factory Input$ExtrinsicAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bool_and')) {
      final l$bool_and = data['bool_and'];
      result$data['bool_and'] = l$bool_and == null
          ? null
          : Input$extrinsicAggregateBoolExpBool_and.fromJson(
              (l$bool_and as Map<String, dynamic>));
    }
    if (data.containsKey('bool_or')) {
      final l$bool_or = data['bool_or'];
      result$data['bool_or'] = l$bool_or == null
          ? null
          : Input$extrinsicAggregateBoolExpBool_or.fromJson(
              (l$bool_or as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$extrinsicAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$ExtrinsicAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$extrinsicAggregateBoolExpBool_and? get bool_and =>
      (_$data['bool_and'] as Input$extrinsicAggregateBoolExpBool_and?);

  Input$extrinsicAggregateBoolExpBool_or? get bool_or =>
      (_$data['bool_or'] as Input$extrinsicAggregateBoolExpBool_or?);

  Input$extrinsicAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$extrinsicAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bool_and')) {
      final l$bool_and = bool_and;
      result$data['bool_and'] = l$bool_and?.toJson();
    }
    if (_$data.containsKey('bool_or')) {
      final l$bool_or = bool_or;
      result$data['bool_or'] = l$bool_or?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicAggregateBoolExp<Input$ExtrinsicAggregateBoolExp>
      get copyWith => CopyWith$Input$ExtrinsicAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bool_and = bool_and;
    final lOther$bool_and = other.bool_and;
    if (_$data.containsKey('bool_and') !=
        other._$data.containsKey('bool_and')) {
      return false;
    }
    if (l$bool_and != lOther$bool_and) {
      return false;
    }
    final l$bool_or = bool_or;
    final lOther$bool_or = other.bool_or;
    if (_$data.containsKey('bool_or') != other._$data.containsKey('bool_or')) {
      return false;
    }
    if (l$bool_or != lOther$bool_or) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bool_and = bool_and;
    final l$bool_or = bool_or;
    final l$count = count;
    return Object.hashAll([
      _$data.containsKey('bool_and') ? l$bool_and : const {},
      _$data.containsKey('bool_or') ? l$bool_or : const {},
      _$data.containsKey('count') ? l$count : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> {
  factory CopyWith$Input$ExtrinsicAggregateBoolExp(
    Input$ExtrinsicAggregateBoolExp instance,
    TRes Function(Input$ExtrinsicAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$ExtrinsicAggregateBoolExp;

  factory CopyWith$Input$ExtrinsicAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicAggregateBoolExp;

  TRes call({
    Input$extrinsicAggregateBoolExpBool_and? bool_and,
    Input$extrinsicAggregateBoolExpBool_or? bool_or,
    Input$extrinsicAggregateBoolExpCount? count,
  });
  CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> get bool_and;
  CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> get bool_or;
  CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$ExtrinsicAggregateBoolExp<TRes>
    implements CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$ExtrinsicAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicAggregateBoolExp _instance;

  final TRes Function(Input$ExtrinsicAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bool_and = _undefined,
    Object? bool_or = _undefined,
    Object? count = _undefined,
  }) =>
      _then(Input$ExtrinsicAggregateBoolExp._({
        ..._instance._$data,
        if (bool_and != _undefined)
          'bool_and': (bool_and as Input$extrinsicAggregateBoolExpBool_and?),
        if (bool_or != _undefined)
          'bool_or': (bool_or as Input$extrinsicAggregateBoolExpBool_or?),
        if (count != _undefined)
          'count': (count as Input$extrinsicAggregateBoolExpCount?),
      }));

  CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> get bool_and {
    final local$bool_and = _instance.bool_and;
    return local$bool_and == null
        ? CopyWith$Input$extrinsicAggregateBoolExpBool_and.stub(
            _then(_instance))
        : CopyWith$Input$extrinsicAggregateBoolExpBool_and(
            local$bool_and, (e) => call(bool_and: e));
  }

  CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> get bool_or {
    final local$bool_or = _instance.bool_or;
    return local$bool_or == null
        ? CopyWith$Input$extrinsicAggregateBoolExpBool_or.stub(_then(_instance))
        : CopyWith$Input$extrinsicAggregateBoolExpBool_or(
            local$bool_or, (e) => call(bool_or: e));
  }

  CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$extrinsicAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$extrinsicAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$ExtrinsicAggregateBoolExp<TRes>
    implements CopyWith$Input$ExtrinsicAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicAggregateBoolExp(this._res);

  TRes _res;

  call({
    Input$extrinsicAggregateBoolExpBool_and? bool_and,
    Input$extrinsicAggregateBoolExpBool_or? bool_or,
    Input$extrinsicAggregateBoolExpCount? count,
  }) =>
      _res;

  CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> get bool_and =>
      CopyWith$Input$extrinsicAggregateBoolExpBool_and.stub(_res);

  CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> get bool_or =>
      CopyWith$Input$extrinsicAggregateBoolExpBool_or.stub(_res);

  CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$extrinsicAggregateBoolExpCount.stub(_res);
}

class Input$extrinsicAggregateBoolExpBool_and {
  factory Input$extrinsicAggregateBoolExpBool_and({
    required Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$extrinsicAggregateBoolExpBool_and._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$extrinsicAggregateBoolExpBool_and._(this._$data);

  factory Input$extrinsicAggregateBoolExpBool_and.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$extrinsicAggregateBoolExpBool_and._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$ExtrinsicBoolExp? get filter =>
      (_$data['filter'] as Input$ExtrinsicBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$extrinsicAggregateBoolExpBool_and<
          Input$extrinsicAggregateBoolExpBool_and>
      get copyWith => CopyWith$Input$extrinsicAggregateBoolExpBool_and(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$extrinsicAggregateBoolExpBool_and) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> {
  factory CopyWith$Input$extrinsicAggregateBoolExpBool_and(
    Input$extrinsicAggregateBoolExpBool_and instance,
    TRes Function(Input$extrinsicAggregateBoolExpBool_and) then,
  ) = _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_and;

  factory CopyWith$Input$extrinsicAggregateBoolExpBool_and.stub(TRes res) =
      _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_and;

  TRes call({
    Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> {
  _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_and(
    this._instance,
    this._then,
  );

  final Input$extrinsicAggregateBoolExpBool_and _instance;

  final TRes Function(Input$extrinsicAggregateBoolExpBool_and) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$extrinsicAggregateBoolExpBool_and._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$ExtrinsicBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_and<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpBool_and<TRes> {
  _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_and(this._res);

  TRes _res;

  call({
    Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns?
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$extrinsicAggregateBoolExpBool_or {
  factory Input$extrinsicAggregateBoolExpBool_or({
    required Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    required Input$BooleanComparisonExp predicate,
  }) =>
      Input$extrinsicAggregateBoolExpBool_or._({
        r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$extrinsicAggregateBoolExpBool_or._(this._$data);

  factory Input$extrinsicAggregateBoolExpBool_or.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$arguments = data['arguments'];
    result$data['arguments'] =
        fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
            (l$arguments as String));
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] = Input$BooleanComparisonExp.fromJson(
        (l$predicate as Map<String, dynamic>));
    return Input$extrinsicAggregateBoolExpBool_or._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
      get arguments => (_$data['arguments']
          as Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$ExtrinsicBoolExp? get filter =>
      (_$data['filter'] as Input$ExtrinsicBoolExp?);

  Input$BooleanComparisonExp get predicate =>
      (_$data['predicate'] as Input$BooleanComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$arguments = arguments;
    result$data['arguments'] =
        toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
            l$arguments);
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$extrinsicAggregateBoolExpBool_or<
          Input$extrinsicAggregateBoolExpBool_or>
      get copyWith => CopyWith$Input$extrinsicAggregateBoolExpBool_or(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$extrinsicAggregateBoolExpBool_or) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      l$arguments,
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> {
  factory CopyWith$Input$extrinsicAggregateBoolExpBool_or(
    Input$extrinsicAggregateBoolExpBool_or instance,
    TRes Function(Input$extrinsicAggregateBoolExpBool_or) then,
  ) = _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_or;

  factory CopyWith$Input$extrinsicAggregateBoolExpBool_or.stub(TRes res) =
      _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_or;

  TRes call({
    Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns?
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  });
  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter;
  CopyWith$Input$BooleanComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> {
  _CopyWithImpl$Input$extrinsicAggregateBoolExpBool_or(
    this._instance,
    this._then,
  );

  final Input$extrinsicAggregateBoolExpBool_or _instance;

  final TRes Function(Input$extrinsicAggregateBoolExpBool_or) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$extrinsicAggregateBoolExpBool_or._({
        ..._instance._$data,
        if (arguments != _undefined && arguments != null)
          'arguments': (arguments
              as Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$ExtrinsicBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$BooleanComparisonExp),
      }));

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$BooleanComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_or<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpBool_or<TRes> {
  _CopyWithStubImpl$Input$extrinsicAggregateBoolExpBool_or(this._res);

  TRes _res;

  call({
    Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns?
        arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$BooleanComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get predicate =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);
}

class Input$extrinsicAggregateBoolExpCount {
  factory Input$extrinsicAggregateBoolExpCount({
    List<Enum$ExtrinsicSelectColumn>? arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$extrinsicAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$extrinsicAggregateBoolExpCount._(this._$data);

  factory Input$extrinsicAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ExtrinsicSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$extrinsicAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$ExtrinsicSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$ExtrinsicSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$ExtrinsicBoolExp? get filter =>
      (_$data['filter'] as Input$ExtrinsicBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] = l$arguments
          ?.map((e) => toJson$Enum$ExtrinsicSelectColumn(e))
          .toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$extrinsicAggregateBoolExpCount<
          Input$extrinsicAggregateBoolExpCount>
      get copyWith => CopyWith$Input$extrinsicAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$extrinsicAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$extrinsicAggregateBoolExpCount(
    Input$extrinsicAggregateBoolExpCount instance,
    TRes Function(Input$extrinsicAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$extrinsicAggregateBoolExpCount;

  factory CopyWith$Input$extrinsicAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$extrinsicAggregateBoolExpCount;

  TRes call({
    List<Enum$ExtrinsicSelectColumn>? arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$extrinsicAggregateBoolExpCount<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$extrinsicAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$extrinsicAggregateBoolExpCount _instance;

  final TRes Function(Input$extrinsicAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$extrinsicAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$ExtrinsicSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$ExtrinsicBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$extrinsicAggregateBoolExpCount<TRes>
    implements CopyWith$Input$extrinsicAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$extrinsicAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$ExtrinsicSelectColumn>? arguments,
    bool? distinct,
    Input$ExtrinsicBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$ExtrinsicBoolExp<TRes> get filter =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$ExtrinsicAggregateOrderBy {
  factory Input$ExtrinsicAggregateOrderBy({
    Input$ExtrinsicAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ExtrinsicMaxOrderBy? max,
    Input$ExtrinsicMinOrderBy? min,
    Input$ExtrinsicStddevOrderBy? stddev,
    Input$ExtrinsicStddevPopOrderBy? stddevPop,
    Input$ExtrinsicStddevSampOrderBy? stddevSamp,
    Input$ExtrinsicSumOrderBy? sum,
    Input$ExtrinsicVarPopOrderBy? varPop,
    Input$ExtrinsicVarSampOrderBy? varSamp,
    Input$ExtrinsicVarianceOrderBy? variance,
  }) =>
      Input$ExtrinsicAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$ExtrinsicAggregateOrderBy._(this._$data);

  factory Input$ExtrinsicAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$ExtrinsicAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$ExtrinsicMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$ExtrinsicMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$ExtrinsicStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$ExtrinsicStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$ExtrinsicStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$ExtrinsicSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$ExtrinsicVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$ExtrinsicVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$ExtrinsicVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$ExtrinsicAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ExtrinsicAvgOrderBy? get avg =>
      (_$data['avg'] as Input$ExtrinsicAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$ExtrinsicMaxOrderBy? get max =>
      (_$data['max'] as Input$ExtrinsicMaxOrderBy?);

  Input$ExtrinsicMinOrderBy? get min =>
      (_$data['min'] as Input$ExtrinsicMinOrderBy?);

  Input$ExtrinsicStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$ExtrinsicStddevOrderBy?);

  Input$ExtrinsicStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$ExtrinsicStddevPopOrderBy?);

  Input$ExtrinsicStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$ExtrinsicStddevSampOrderBy?);

  Input$ExtrinsicSumOrderBy? get sum =>
      (_$data['sum'] as Input$ExtrinsicSumOrderBy?);

  Input$ExtrinsicVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$ExtrinsicVarPopOrderBy?);

  Input$ExtrinsicVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$ExtrinsicVarSampOrderBy?);

  Input$ExtrinsicVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$ExtrinsicVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicAggregateOrderBy<Input$ExtrinsicAggregateOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicAggregateOrderBy(
    Input$ExtrinsicAggregateOrderBy instance,
    TRes Function(Input$ExtrinsicAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicAggregateOrderBy;

  factory CopyWith$Input$ExtrinsicAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicAggregateOrderBy;

  TRes call({
    Input$ExtrinsicAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ExtrinsicMaxOrderBy? max,
    Input$ExtrinsicMinOrderBy? min,
    Input$ExtrinsicStddevOrderBy? stddev,
    Input$ExtrinsicStddevPopOrderBy? stddevPop,
    Input$ExtrinsicStddevSampOrderBy? stddevSamp,
    Input$ExtrinsicSumOrderBy? sum,
    Input$ExtrinsicVarPopOrderBy? varPop,
    Input$ExtrinsicVarSampOrderBy? varSamp,
    Input$ExtrinsicVarianceOrderBy? variance,
  });
  CopyWith$Input$ExtrinsicAvgOrderBy<TRes> get avg;
  CopyWith$Input$ExtrinsicMaxOrderBy<TRes> get max;
  CopyWith$Input$ExtrinsicMinOrderBy<TRes> get min;
  CopyWith$Input$ExtrinsicStddevOrderBy<TRes> get stddev;
  CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$ExtrinsicSumOrderBy<TRes> get sum;
  CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$ExtrinsicAggregateOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicAggregateOrderBy _instance;

  final TRes Function(Input$ExtrinsicAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$ExtrinsicAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$ExtrinsicAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$ExtrinsicMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$ExtrinsicMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$ExtrinsicStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$ExtrinsicStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$ExtrinsicStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$ExtrinsicSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$ExtrinsicVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$ExtrinsicVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$ExtrinsicVarianceOrderBy?),
      }));

  CopyWith$Input$ExtrinsicAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$ExtrinsicAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$ExtrinsicMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$ExtrinsicMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$ExtrinsicMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$ExtrinsicMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$ExtrinsicStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$ExtrinsicStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$ExtrinsicStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$ExtrinsicStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$ExtrinsicSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$ExtrinsicSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$ExtrinsicVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$ExtrinsicVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$ExtrinsicVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$ExtrinsicAggregateOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$ExtrinsicAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$ExtrinsicMaxOrderBy? max,
    Input$ExtrinsicMinOrderBy? min,
    Input$ExtrinsicStddevOrderBy? stddev,
    Input$ExtrinsicStddevPopOrderBy? stddevPop,
    Input$ExtrinsicStddevSampOrderBy? stddevSamp,
    Input$ExtrinsicSumOrderBy? sum,
    Input$ExtrinsicVarPopOrderBy? varPop,
    Input$ExtrinsicVarSampOrderBy? varSamp,
    Input$ExtrinsicVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$ExtrinsicAvgOrderBy<TRes> get avg =>
      CopyWith$Input$ExtrinsicAvgOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicMaxOrderBy<TRes> get max =>
      CopyWith$Input$ExtrinsicMaxOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicMinOrderBy<TRes> get min =>
      CopyWith$Input$ExtrinsicMinOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$ExtrinsicStddevOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$ExtrinsicStddevPopOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$ExtrinsicStddevSampOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicSumOrderBy<TRes> get sum =>
      CopyWith$Input$ExtrinsicSumOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$ExtrinsicVarPopOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$ExtrinsicVarSampOrderBy.stub(_res);

  CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$ExtrinsicVarianceOrderBy.stub(_res);
}

class Input$ExtrinsicAvgOrderBy {
  factory Input$ExtrinsicAvgOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicAvgOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicAvgOrderBy._(this._$data);

  factory Input$ExtrinsicAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicAvgOrderBy<Input$ExtrinsicAvgOrderBy> get copyWith =>
      CopyWith$Input$ExtrinsicAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicAvgOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicAvgOrderBy(
    Input$ExtrinsicAvgOrderBy instance,
    TRes Function(Input$ExtrinsicAvgOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicAvgOrderBy;

  factory CopyWith$Input$ExtrinsicAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicAvgOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicAvgOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicAvgOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicAvgOrderBy _instance;

  final TRes Function(Input$ExtrinsicAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicAvgOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicAvgOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicAvgOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicBoolExp {
  factory Input$ExtrinsicBoolExp({
    List<Input$ExtrinsicBoolExp>? $_and,
    Input$ExtrinsicBoolExp? $_not,
    List<Input$ExtrinsicBoolExp>? $_or,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$NumericComparisonExp? fee,
    Input$ByteaComparisonExp? hash,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$JsonbComparisonExp? signature,
    Input$BooleanComparisonExp? success,
    Input$NumericComparisonExp? tip,
    Input$IntComparisonExp? version,
  }) =>
      Input$ExtrinsicBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if ($call != null) r'call': $call,
        if (callId != null) r'callId': callId,
        if (calls != null) r'calls': calls,
        if (callsAggregate != null) r'callsAggregate': callsAggregate,
        if (error != null) r'error': error,
        if (events != null) r'events': events,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (fee != null) r'fee': fee,
        if (hash != null) r'hash': hash,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (signature != null) r'signature': signature,
        if (success != null) r'success': success,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicBoolExp._(this._$data);

  factory Input$ExtrinsicBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$ExtrinsicBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$ExtrinsicBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$ExtrinsicBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockBoolExp.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$blockId as Map<String, dynamic>));
    }
    if (data.containsKey('call')) {
      final l$$call = data['call'];
      result$data['call'] = l$$call == null
          ? null
          : Input$CallBoolExp.fromJson((l$$call as Map<String, dynamic>));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] = l$callId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$callId as Map<String, dynamic>));
    }
    if (data.containsKey('calls')) {
      final l$calls = data['calls'];
      result$data['calls'] = l$calls == null
          ? null
          : Input$CallBoolExp.fromJson((l$calls as Map<String, dynamic>));
    }
    if (data.containsKey('callsAggregate')) {
      final l$callsAggregate = data['callsAggregate'];
      result$data['callsAggregate'] = l$callsAggregate == null
          ? null
          : Input$CallAggregateBoolExp.fromJson(
              (l$callsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('error')) {
      final l$error = data['error'];
      result$data['error'] = l$error == null
          ? null
          : Input$JsonbComparisonExp.fromJson(
              (l$error as Map<String, dynamic>));
    }
    if (data.containsKey('events')) {
      final l$events = data['events'];
      result$data['events'] = l$events == null
          ? null
          : Input$EventBoolExp.fromJson((l$events as Map<String, dynamic>));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateBoolExp.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] = l$fee == null
          ? null
          : Input$NumericComparisonExp.fromJson(
              (l$fee as Map<String, dynamic>));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] = l$hash == null
          ? null
          : Input$ByteaComparisonExp.fromJson((l$hash as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntComparisonExp.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('signature')) {
      final l$signature = data['signature'];
      result$data['signature'] = l$signature == null
          ? null
          : Input$JsonbComparisonExp.fromJson(
              (l$signature as Map<String, dynamic>));
    }
    if (data.containsKey('success')) {
      final l$success = data['success'];
      result$data['success'] = l$success == null
          ? null
          : Input$BooleanComparisonExp.fromJson(
              (l$success as Map<String, dynamic>));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] = l$tip == null
          ? null
          : Input$NumericComparisonExp.fromJson(
              (l$tip as Map<String, dynamic>));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$version as Map<String, dynamic>));
    }
    return Input$ExtrinsicBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ExtrinsicBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$ExtrinsicBoolExp>?);

  Input$ExtrinsicBoolExp? get $_not =>
      (_$data['_not'] as Input$ExtrinsicBoolExp?);

  List<Input$ExtrinsicBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$ExtrinsicBoolExp>?);

  Input$BlockBoolExp? get block => (_$data['block'] as Input$BlockBoolExp?);

  Input$StringComparisonExp? get blockId =>
      (_$data['blockId'] as Input$StringComparisonExp?);

  Input$CallBoolExp? get $call => (_$data['call'] as Input$CallBoolExp?);

  Input$StringComparisonExp? get callId =>
      (_$data['callId'] as Input$StringComparisonExp?);

  Input$CallBoolExp? get calls => (_$data['calls'] as Input$CallBoolExp?);

  Input$CallAggregateBoolExp? get callsAggregate =>
      (_$data['callsAggregate'] as Input$CallAggregateBoolExp?);

  Input$JsonbComparisonExp? get error =>
      (_$data['error'] as Input$JsonbComparisonExp?);

  Input$EventBoolExp? get events => (_$data['events'] as Input$EventBoolExp?);

  Input$EventAggregateBoolExp? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateBoolExp?);

  Input$NumericComparisonExp? get fee =>
      (_$data['fee'] as Input$NumericComparisonExp?);

  Input$ByteaComparisonExp? get hash =>
      (_$data['hash'] as Input$ByteaComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get index =>
      (_$data['index'] as Input$IntComparisonExp?);

  Input$JsonbComparisonExp? get signature =>
      (_$data['signature'] as Input$JsonbComparisonExp?);

  Input$BooleanComparisonExp? get success =>
      (_$data['success'] as Input$BooleanComparisonExp?);

  Input$NumericComparisonExp? get tip =>
      (_$data['tip'] as Input$NumericComparisonExp?);

  Input$IntComparisonExp? get version =>
      (_$data['version'] as Input$IntComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] = l$blockId?.toJson();
    }
    if (_$data.containsKey('call')) {
      final l$$call = $call;
      result$data['call'] = l$$call?.toJson();
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] = l$callId?.toJson();
    }
    if (_$data.containsKey('calls')) {
      final l$calls = calls;
      result$data['calls'] = l$calls?.toJson();
    }
    if (_$data.containsKey('callsAggregate')) {
      final l$callsAggregate = callsAggregate;
      result$data['callsAggregate'] = l$callsAggregate?.toJson();
    }
    if (_$data.containsKey('error')) {
      final l$error = error;
      result$data['error'] = l$error?.toJson();
    }
    if (_$data.containsKey('events')) {
      final l$events = events;
      result$data['events'] = l$events?.toJson();
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee?.toJson();
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('signature')) {
      final l$signature = signature;
      result$data['signature'] = l$signature?.toJson();
    }
    if (_$data.containsKey('success')) {
      final l$success = success;
      result$data['success'] = l$success?.toJson();
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicBoolExp<Input$ExtrinsicBoolExp> get copyWith =>
      CopyWith$Input$ExtrinsicBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$$call = $call;
    final lOther$$call = other.$call;
    if (_$data.containsKey('call') != other._$data.containsKey('call')) {
      return false;
    }
    if (l$$call != lOther$$call) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$calls = calls;
    final lOther$calls = other.calls;
    if (_$data.containsKey('calls') != other._$data.containsKey('calls')) {
      return false;
    }
    if (l$calls != lOther$calls) {
      return false;
    }
    final l$callsAggregate = callsAggregate;
    final lOther$callsAggregate = other.callsAggregate;
    if (_$data.containsKey('callsAggregate') !=
        other._$data.containsKey('callsAggregate')) {
      return false;
    }
    if (l$callsAggregate != lOther$callsAggregate) {
      return false;
    }
    final l$error = error;
    final lOther$error = other.error;
    if (_$data.containsKey('error') != other._$data.containsKey('error')) {
      return false;
    }
    if (l$error != lOther$error) {
      return false;
    }
    final l$events = events;
    final lOther$events = other.events;
    if (_$data.containsKey('events') != other._$data.containsKey('events')) {
      return false;
    }
    if (l$events != lOther$events) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$signature = signature;
    final lOther$signature = other.signature;
    if (_$data.containsKey('signature') !=
        other._$data.containsKey('signature')) {
      return false;
    }
    if (l$signature != lOther$signature) {
      return false;
    }
    final l$success = success;
    final lOther$success = other.success;
    if (_$data.containsKey('success') != other._$data.containsKey('success')) {
      return false;
    }
    if (l$success != lOther$success) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$block = block;
    final l$blockId = blockId;
    final l$$call = $call;
    final l$callId = callId;
    final l$calls = calls;
    final l$callsAggregate = callsAggregate;
    final l$error = error;
    final l$events = events;
    final l$eventsAggregate = eventsAggregate;
    final l$fee = fee;
    final l$hash = hash;
    final l$id = id;
    final l$index = index;
    final l$signature = signature;
    final l$success = success;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('call') ? l$$call : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('calls') ? l$calls : const {},
      _$data.containsKey('callsAggregate') ? l$callsAggregate : const {},
      _$data.containsKey('error') ? l$error : const {},
      _$data.containsKey('events') ? l$events : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('signature') ? l$signature : const {},
      _$data.containsKey('success') ? l$success : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicBoolExp<TRes> {
  factory CopyWith$Input$ExtrinsicBoolExp(
    Input$ExtrinsicBoolExp instance,
    TRes Function(Input$ExtrinsicBoolExp) then,
  ) = _CopyWithImpl$Input$ExtrinsicBoolExp;

  factory CopyWith$Input$ExtrinsicBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicBoolExp;

  TRes call({
    List<Input$ExtrinsicBoolExp>? $_and,
    Input$ExtrinsicBoolExp? $_not,
    List<Input$ExtrinsicBoolExp>? $_or,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$NumericComparisonExp? fee,
    Input$ByteaComparisonExp? hash,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$JsonbComparisonExp? signature,
    Input$BooleanComparisonExp? success,
    Input$NumericComparisonExp? tip,
    Input$IntComparisonExp? version,
  });
  TRes $_and(
      Iterable<Input$ExtrinsicBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ExtrinsicBoolExp<Input$ExtrinsicBoolExp>>?)
          _fn);
  CopyWith$Input$ExtrinsicBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$ExtrinsicBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ExtrinsicBoolExp<Input$ExtrinsicBoolExp>>?)
          _fn);
  CopyWith$Input$BlockBoolExp<TRes> get block;
  CopyWith$Input$StringComparisonExp<TRes> get blockId;
  CopyWith$Input$CallBoolExp<TRes> get $call;
  CopyWith$Input$StringComparisonExp<TRes> get callId;
  CopyWith$Input$CallBoolExp<TRes> get calls;
  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate;
  CopyWith$Input$JsonbComparisonExp<TRes> get error;
  CopyWith$Input$EventBoolExp<TRes> get events;
  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate;
  CopyWith$Input$NumericComparisonExp<TRes> get fee;
  CopyWith$Input$ByteaComparisonExp<TRes> get hash;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IntComparisonExp<TRes> get index;
  CopyWith$Input$JsonbComparisonExp<TRes> get signature;
  CopyWith$Input$BooleanComparisonExp<TRes> get success;
  CopyWith$Input$NumericComparisonExp<TRes> get tip;
  CopyWith$Input$IntComparisonExp<TRes> get version;
}

class _CopyWithImpl$Input$ExtrinsicBoolExp<TRes>
    implements CopyWith$Input$ExtrinsicBoolExp<TRes> {
  _CopyWithImpl$Input$ExtrinsicBoolExp(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicBoolExp _instance;

  final TRes Function(Input$ExtrinsicBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? $call = _undefined,
    Object? callId = _undefined,
    Object? calls = _undefined,
    Object? callsAggregate = _undefined,
    Object? error = _undefined,
    Object? events = _undefined,
    Object? eventsAggregate = _undefined,
    Object? fee = _undefined,
    Object? hash = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? signature = _undefined,
    Object? success = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$ExtrinsicBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$ExtrinsicBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$ExtrinsicBoolExp>?),
        if (block != _undefined) 'block': (block as Input$BlockBoolExp?),
        if (blockId != _undefined)
          'blockId': (blockId as Input$StringComparisonExp?),
        if ($call != _undefined) 'call': ($call as Input$CallBoolExp?),
        if (callId != _undefined)
          'callId': (callId as Input$StringComparisonExp?),
        if (calls != _undefined) 'calls': (calls as Input$CallBoolExp?),
        if (callsAggregate != _undefined)
          'callsAggregate': (callsAggregate as Input$CallAggregateBoolExp?),
        if (error != _undefined) 'error': (error as Input$JsonbComparisonExp?),
        if (events != _undefined) 'events': (events as Input$EventBoolExp?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateBoolExp?),
        if (fee != _undefined) 'fee': (fee as Input$NumericComparisonExp?),
        if (hash != _undefined) 'hash': (hash as Input$ByteaComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (index != _undefined) 'index': (index as Input$IntComparisonExp?),
        if (signature != _undefined)
          'signature': (signature as Input$JsonbComparisonExp?),
        if (success != _undefined)
          'success': (success as Input$BooleanComparisonExp?),
        if (tip != _undefined) 'tip': (tip as Input$NumericComparisonExp?),
        if (version != _undefined)
          'version': (version as Input$IntComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$ExtrinsicBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ExtrinsicBoolExp<Input$ExtrinsicBoolExp>>?)
              _fn) =>
      call(
          $_and:
              _fn(_instance.$_and?.map((e) => CopyWith$Input$ExtrinsicBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ExtrinsicBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$ExtrinsicBoolExp.stub(_then(_instance))
        : CopyWith$Input$ExtrinsicBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$ExtrinsicBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ExtrinsicBoolExp<Input$ExtrinsicBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$ExtrinsicBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$BlockBoolExp<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockBoolExp.stub(_then(_instance))
        : CopyWith$Input$BlockBoolExp(local$block, (e) => call(block: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get blockId {
    final local$blockId = _instance.blockId;
    return local$blockId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$blockId, (e) => call(blockId: e));
  }

  CopyWith$Input$CallBoolExp<TRes> get $call {
    final local$$call = _instance.$call;
    return local$$call == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$$call, (e) => call($call: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get callId {
    final local$callId = _instance.callId;
    return local$callId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$callId, (e) => call(callId: e));
  }

  CopyWith$Input$CallBoolExp<TRes> get calls {
    final local$calls = _instance.calls;
    return local$calls == null
        ? CopyWith$Input$CallBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallBoolExp(local$calls, (e) => call(calls: e));
  }

  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate {
    final local$callsAggregate = _instance.callsAggregate;
    return local$callsAggregate == null
        ? CopyWith$Input$CallAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CallAggregateBoolExp(
            local$callsAggregate, (e) => call(callsAggregate: e));
  }

  CopyWith$Input$JsonbComparisonExp<TRes> get error {
    final local$error = _instance.error;
    return local$error == null
        ? CopyWith$Input$JsonbComparisonExp.stub(_then(_instance))
        : CopyWith$Input$JsonbComparisonExp(local$error, (e) => call(error: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get events {
    final local$events = _instance.events;
    return local$events == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$events, (e) => call(events: e));
  }

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventAggregateBoolExp(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }

  CopyWith$Input$NumericComparisonExp<TRes> get fee {
    final local$fee = _instance.fee;
    return local$fee == null
        ? CopyWith$Input$NumericComparisonExp.stub(_then(_instance))
        : CopyWith$Input$NumericComparisonExp(local$fee, (e) => call(fee: e));
  }

  CopyWith$Input$ByteaComparisonExp<TRes> get hash {
    final local$hash = _instance.hash;
    return local$hash == null
        ? CopyWith$Input$ByteaComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ByteaComparisonExp(local$hash, (e) => call(hash: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$index, (e) => call(index: e));
  }

  CopyWith$Input$JsonbComparisonExp<TRes> get signature {
    final local$signature = _instance.signature;
    return local$signature == null
        ? CopyWith$Input$JsonbComparisonExp.stub(_then(_instance))
        : CopyWith$Input$JsonbComparisonExp(
            local$signature, (e) => call(signature: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get success {
    final local$success = _instance.success;
    return local$success == null
        ? CopyWith$Input$BooleanComparisonExp.stub(_then(_instance))
        : CopyWith$Input$BooleanComparisonExp(
            local$success, (e) => call(success: e));
  }

  CopyWith$Input$NumericComparisonExp<TRes> get tip {
    final local$tip = _instance.tip;
    return local$tip == null
        ? CopyWith$Input$NumericComparisonExp.stub(_then(_instance))
        : CopyWith$Input$NumericComparisonExp(local$tip, (e) => call(tip: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$version, (e) => call(version: e));
  }
}

class _CopyWithStubImpl$Input$ExtrinsicBoolExp<TRes>
    implements CopyWith$Input$ExtrinsicBoolExp<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicBoolExp(this._res);

  TRes _res;

  call({
    List<Input$ExtrinsicBoolExp>? $_and,
    Input$ExtrinsicBoolExp? $_not,
    List<Input$ExtrinsicBoolExp>? $_or,
    Input$BlockBoolExp? block,
    Input$StringComparisonExp? blockId,
    Input$CallBoolExp? $call,
    Input$StringComparisonExp? callId,
    Input$CallBoolExp? calls,
    Input$CallAggregateBoolExp? callsAggregate,
    Input$JsonbComparisonExp? error,
    Input$EventBoolExp? events,
    Input$EventAggregateBoolExp? eventsAggregate,
    Input$NumericComparisonExp? fee,
    Input$ByteaComparisonExp? hash,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$JsonbComparisonExp? signature,
    Input$BooleanComparisonExp? success,
    Input$NumericComparisonExp? tip,
    Input$IntComparisonExp? version,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$ExtrinsicBoolExp<TRes> get $_not =>
      CopyWith$Input$ExtrinsicBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$BlockBoolExp<TRes> get block =>
      CopyWith$Input$BlockBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get blockId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CallBoolExp<TRes> get $call =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get callId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CallBoolExp<TRes> get calls =>
      CopyWith$Input$CallBoolExp.stub(_res);

  CopyWith$Input$CallAggregateBoolExp<TRes> get callsAggregate =>
      CopyWith$Input$CallAggregateBoolExp.stub(_res);

  CopyWith$Input$JsonbComparisonExp<TRes> get error =>
      CopyWith$Input$JsonbComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get events =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$EventAggregateBoolExp<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateBoolExp.stub(_res);

  CopyWith$Input$NumericComparisonExp<TRes> get fee =>
      CopyWith$Input$NumericComparisonExp.stub(_res);

  CopyWith$Input$ByteaComparisonExp<TRes> get hash =>
      CopyWith$Input$ByteaComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get index =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$JsonbComparisonExp<TRes> get signature =>
      CopyWith$Input$JsonbComparisonExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get success =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);

  CopyWith$Input$NumericComparisonExp<TRes> get tip =>
      CopyWith$Input$NumericComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get version =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$ExtrinsicMaxOrderBy {
  factory Input$ExtrinsicMaxOrderBy({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicMaxOrderBy._({
        if (blockId != null) r'blockId': blockId,
        if (callId != null) r'callId': callId,
        if (fee != null) r'fee': fee,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicMaxOrderBy._(this._$data);

  factory Input$ExtrinsicMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicMaxOrderBy<Input$ExtrinsicMaxOrderBy> get copyWith =>
      CopyWith$Input$ExtrinsicMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockId = blockId;
    final l$callId = callId;
    final l$fee = fee;
    final l$id = id;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicMaxOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicMaxOrderBy(
    Input$ExtrinsicMaxOrderBy instance,
    TRes Function(Input$ExtrinsicMaxOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicMaxOrderBy;

  factory CopyWith$Input$ExtrinsicMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicMaxOrderBy;

  TRes call({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicMaxOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicMaxOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicMaxOrderBy _instance;

  final TRes Function(Input$ExtrinsicMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockId = _undefined,
    Object? callId = _undefined,
    Object? fee = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicMaxOrderBy._({
        ..._instance._$data,
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicMaxOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicMinOrderBy {
  factory Input$ExtrinsicMinOrderBy({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicMinOrderBy._({
        if (blockId != null) r'blockId': blockId,
        if (callId != null) r'callId': callId,
        if (fee != null) r'fee': fee,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicMinOrderBy._(this._$data);

  factory Input$ExtrinsicMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicMinOrderBy<Input$ExtrinsicMinOrderBy> get copyWith =>
      CopyWith$Input$ExtrinsicMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockId = blockId;
    final l$callId = callId;
    final l$fee = fee;
    final l$id = id;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicMinOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicMinOrderBy(
    Input$ExtrinsicMinOrderBy instance,
    TRes Function(Input$ExtrinsicMinOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicMinOrderBy;

  factory CopyWith$Input$ExtrinsicMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicMinOrderBy;

  TRes call({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicMinOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicMinOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicMinOrderBy _instance;

  final TRes Function(Input$ExtrinsicMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockId = _undefined,
    Object? callId = _undefined,
    Object? fee = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicMinOrderBy._({
        ..._instance._$data,
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicMinOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockId,
    Enum$OrderBy? callId,
    Enum$OrderBy? fee,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicOrderBy {
  factory Input$ExtrinsicOrderBy({
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? fee,
    Enum$OrderBy? hash,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? signature,
    Enum$OrderBy? success,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicOrderBy._({
        if (block != null) r'block': block,
        if (blockId != null) r'blockId': blockId,
        if ($call != null) r'call': $call,
        if (callId != null) r'callId': callId,
        if (callsAggregate != null) r'callsAggregate': callsAggregate,
        if (error != null) r'error': error,
        if (eventsAggregate != null) r'eventsAggregate': eventsAggregate,
        if (fee != null) r'fee': fee,
        if (hash != null) r'hash': hash,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (signature != null) r'signature': signature,
        if (success != null) r'success': success,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicOrderBy._(this._$data);

  factory Input$ExtrinsicOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = l$block == null
          ? null
          : Input$BlockOrderBy.fromJson((l$block as Map<String, dynamic>));
    }
    if (data.containsKey('blockId')) {
      final l$blockId = data['blockId'];
      result$data['blockId'] = l$blockId == null
          ? null
          : fromJson$Enum$OrderBy((l$blockId as String));
    }
    if (data.containsKey('call')) {
      final l$$call = data['call'];
      result$data['call'] = l$$call == null
          ? null
          : Input$CallOrderBy.fromJson((l$$call as Map<String, dynamic>));
    }
    if (data.containsKey('callId')) {
      final l$callId = data['callId'];
      result$data['callId'] =
          l$callId == null ? null : fromJson$Enum$OrderBy((l$callId as String));
    }
    if (data.containsKey('callsAggregate')) {
      final l$callsAggregate = data['callsAggregate'];
      result$data['callsAggregate'] = l$callsAggregate == null
          ? null
          : Input$CallAggregateOrderBy.fromJson(
              (l$callsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('error')) {
      final l$error = data['error'];
      result$data['error'] =
          l$error == null ? null : fromJson$Enum$OrderBy((l$error as String));
    }
    if (data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = data['eventsAggregate'];
      result$data['eventsAggregate'] = l$eventsAggregate == null
          ? null
          : Input$EventAggregateOrderBy.fromJson(
              (l$eventsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('hash')) {
      final l$hash = data['hash'];
      result$data['hash'] =
          l$hash == null ? null : fromJson$Enum$OrderBy((l$hash as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('signature')) {
      final l$signature = data['signature'];
      result$data['signature'] = l$signature == null
          ? null
          : fromJson$Enum$OrderBy((l$signature as String));
    }
    if (data.containsKey('success')) {
      final l$success = data['success'];
      result$data['success'] = l$success == null
          ? null
          : fromJson$Enum$OrderBy((l$success as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BlockOrderBy? get block => (_$data['block'] as Input$BlockOrderBy?);

  Enum$OrderBy? get blockId => (_$data['blockId'] as Enum$OrderBy?);

  Input$CallOrderBy? get $call => (_$data['call'] as Input$CallOrderBy?);

  Enum$OrderBy? get callId => (_$data['callId'] as Enum$OrderBy?);

  Input$CallAggregateOrderBy? get callsAggregate =>
      (_$data['callsAggregate'] as Input$CallAggregateOrderBy?);

  Enum$OrderBy? get error => (_$data['error'] as Enum$OrderBy?);

  Input$EventAggregateOrderBy? get eventsAggregate =>
      (_$data['eventsAggregate'] as Input$EventAggregateOrderBy?);

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get hash => (_$data['hash'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get signature => (_$data['signature'] as Enum$OrderBy?);

  Enum$OrderBy? get success => (_$data['success'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block?.toJson();
    }
    if (_$data.containsKey('blockId')) {
      final l$blockId = blockId;
      result$data['blockId'] =
          l$blockId == null ? null : toJson$Enum$OrderBy(l$blockId);
    }
    if (_$data.containsKey('call')) {
      final l$$call = $call;
      result$data['call'] = l$$call?.toJson();
    }
    if (_$data.containsKey('callId')) {
      final l$callId = callId;
      result$data['callId'] =
          l$callId == null ? null : toJson$Enum$OrderBy(l$callId);
    }
    if (_$data.containsKey('callsAggregate')) {
      final l$callsAggregate = callsAggregate;
      result$data['callsAggregate'] = l$callsAggregate?.toJson();
    }
    if (_$data.containsKey('error')) {
      final l$error = error;
      result$data['error'] =
          l$error == null ? null : toJson$Enum$OrderBy(l$error);
    }
    if (_$data.containsKey('eventsAggregate')) {
      final l$eventsAggregate = eventsAggregate;
      result$data['eventsAggregate'] = l$eventsAggregate?.toJson();
    }
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('hash')) {
      final l$hash = hash;
      result$data['hash'] = l$hash == null ? null : toJson$Enum$OrderBy(l$hash);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('signature')) {
      final l$signature = signature;
      result$data['signature'] =
          l$signature == null ? null : toJson$Enum$OrderBy(l$signature);
    }
    if (_$data.containsKey('success')) {
      final l$success = success;
      result$data['success'] =
          l$success == null ? null : toJson$Enum$OrderBy(l$success);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicOrderBy<Input$ExtrinsicOrderBy> get copyWith =>
      CopyWith$Input$ExtrinsicOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    final l$blockId = blockId;
    final lOther$blockId = other.blockId;
    if (_$data.containsKey('blockId') != other._$data.containsKey('blockId')) {
      return false;
    }
    if (l$blockId != lOther$blockId) {
      return false;
    }
    final l$$call = $call;
    final lOther$$call = other.$call;
    if (_$data.containsKey('call') != other._$data.containsKey('call')) {
      return false;
    }
    if (l$$call != lOther$$call) {
      return false;
    }
    final l$callId = callId;
    final lOther$callId = other.callId;
    if (_$data.containsKey('callId') != other._$data.containsKey('callId')) {
      return false;
    }
    if (l$callId != lOther$callId) {
      return false;
    }
    final l$callsAggregate = callsAggregate;
    final lOther$callsAggregate = other.callsAggregate;
    if (_$data.containsKey('callsAggregate') !=
        other._$data.containsKey('callsAggregate')) {
      return false;
    }
    if (l$callsAggregate != lOther$callsAggregate) {
      return false;
    }
    final l$error = error;
    final lOther$error = other.error;
    if (_$data.containsKey('error') != other._$data.containsKey('error')) {
      return false;
    }
    if (l$error != lOther$error) {
      return false;
    }
    final l$eventsAggregate = eventsAggregate;
    final lOther$eventsAggregate = other.eventsAggregate;
    if (_$data.containsKey('eventsAggregate') !=
        other._$data.containsKey('eventsAggregate')) {
      return false;
    }
    if (l$eventsAggregate != lOther$eventsAggregate) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$hash = hash;
    final lOther$hash = other.hash;
    if (_$data.containsKey('hash') != other._$data.containsKey('hash')) {
      return false;
    }
    if (l$hash != lOther$hash) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$signature = signature;
    final lOther$signature = other.signature;
    if (_$data.containsKey('signature') !=
        other._$data.containsKey('signature')) {
      return false;
    }
    if (l$signature != lOther$signature) {
      return false;
    }
    final l$success = success;
    final lOther$success = other.success;
    if (_$data.containsKey('success') != other._$data.containsKey('success')) {
      return false;
    }
    if (l$success != lOther$success) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$block = block;
    final l$blockId = blockId;
    final l$$call = $call;
    final l$callId = callId;
    final l$callsAggregate = callsAggregate;
    final l$error = error;
    final l$eventsAggregate = eventsAggregate;
    final l$fee = fee;
    final l$hash = hash;
    final l$id = id;
    final l$index = index;
    final l$signature = signature;
    final l$success = success;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('block') ? l$block : const {},
      _$data.containsKey('blockId') ? l$blockId : const {},
      _$data.containsKey('call') ? l$$call : const {},
      _$data.containsKey('callId') ? l$callId : const {},
      _$data.containsKey('callsAggregate') ? l$callsAggregate : const {},
      _$data.containsKey('error') ? l$error : const {},
      _$data.containsKey('eventsAggregate') ? l$eventsAggregate : const {},
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('hash') ? l$hash : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('signature') ? l$signature : const {},
      _$data.containsKey('success') ? l$success : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicOrderBy(
    Input$ExtrinsicOrderBy instance,
    TRes Function(Input$ExtrinsicOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicOrderBy;

  factory CopyWith$Input$ExtrinsicOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicOrderBy;

  TRes call({
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? fee,
    Enum$OrderBy? hash,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? signature,
    Enum$OrderBy? success,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
  CopyWith$Input$BlockOrderBy<TRes> get block;
  CopyWith$Input$CallOrderBy<TRes> get $call;
  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate;
  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate;
}

class _CopyWithImpl$Input$ExtrinsicOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicOrderBy _instance;

  final TRes Function(Input$ExtrinsicOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? block = _undefined,
    Object? blockId = _undefined,
    Object? $call = _undefined,
    Object? callId = _undefined,
    Object? callsAggregate = _undefined,
    Object? error = _undefined,
    Object? eventsAggregate = _undefined,
    Object? fee = _undefined,
    Object? hash = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? signature = _undefined,
    Object? success = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicOrderBy._({
        ..._instance._$data,
        if (block != _undefined) 'block': (block as Input$BlockOrderBy?),
        if (blockId != _undefined) 'blockId': (blockId as Enum$OrderBy?),
        if ($call != _undefined) 'call': ($call as Input$CallOrderBy?),
        if (callId != _undefined) 'callId': (callId as Enum$OrderBy?),
        if (callsAggregate != _undefined)
          'callsAggregate': (callsAggregate as Input$CallAggregateOrderBy?),
        if (error != _undefined) 'error': (error as Enum$OrderBy?),
        if (eventsAggregate != _undefined)
          'eventsAggregate': (eventsAggregate as Input$EventAggregateOrderBy?),
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (hash != _undefined) 'hash': (hash as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (signature != _undefined) 'signature': (signature as Enum$OrderBy?),
        if (success != _undefined) 'success': (success as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));

  CopyWith$Input$BlockOrderBy<TRes> get block {
    final local$block = _instance.block;
    return local$block == null
        ? CopyWith$Input$BlockOrderBy.stub(_then(_instance))
        : CopyWith$Input$BlockOrderBy(local$block, (e) => call(block: e));
  }

  CopyWith$Input$CallOrderBy<TRes> get $call {
    final local$$call = _instance.$call;
    return local$$call == null
        ? CopyWith$Input$CallOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallOrderBy(local$$call, (e) => call($call: e));
  }

  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate {
    final local$callsAggregate = _instance.callsAggregate;
    return local$callsAggregate == null
        ? CopyWith$Input$CallAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CallAggregateOrderBy(
            local$callsAggregate, (e) => call(callsAggregate: e));
  }

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate {
    final local$eventsAggregate = _instance.eventsAggregate;
    return local$eventsAggregate == null
        ? CopyWith$Input$EventAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventAggregateOrderBy(
            local$eventsAggregate, (e) => call(eventsAggregate: e));
  }
}

class _CopyWithStubImpl$Input$ExtrinsicOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicOrderBy(this._res);

  TRes _res;

  call({
    Input$BlockOrderBy? block,
    Enum$OrderBy? blockId,
    Input$CallOrderBy? $call,
    Enum$OrderBy? callId,
    Input$CallAggregateOrderBy? callsAggregate,
    Enum$OrderBy? error,
    Input$EventAggregateOrderBy? eventsAggregate,
    Enum$OrderBy? fee,
    Enum$OrderBy? hash,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? signature,
    Enum$OrderBy? success,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;

  CopyWith$Input$BlockOrderBy<TRes> get block =>
      CopyWith$Input$BlockOrderBy.stub(_res);

  CopyWith$Input$CallOrderBy<TRes> get $call =>
      CopyWith$Input$CallOrderBy.stub(_res);

  CopyWith$Input$CallAggregateOrderBy<TRes> get callsAggregate =>
      CopyWith$Input$CallAggregateOrderBy.stub(_res);

  CopyWith$Input$EventAggregateOrderBy<TRes> get eventsAggregate =>
      CopyWith$Input$EventAggregateOrderBy.stub(_res);
}

class Input$ExtrinsicStddevOrderBy {
  factory Input$ExtrinsicStddevOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicStddevOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicStddevOrderBy._(this._$data);

  factory Input$ExtrinsicStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicStddevOrderBy<Input$ExtrinsicStddevOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicStddevOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicStddevOrderBy(
    Input$ExtrinsicStddevOrderBy instance,
    TRes Function(Input$ExtrinsicStddevOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicStddevOrderBy;

  factory CopyWith$Input$ExtrinsicStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicStddevOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicStddevOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicStddevOrderBy _instance;

  final TRes Function(Input$ExtrinsicStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicStddevOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicStddevOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicStddevOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicStddevPopOrderBy {
  factory Input$ExtrinsicStddevPopOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicStddevPopOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicStddevPopOrderBy._(this._$data);

  factory Input$ExtrinsicStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicStddevPopOrderBy<Input$ExtrinsicStddevPopOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicStddevPopOrderBy(
    Input$ExtrinsicStddevPopOrderBy instance,
    TRes Function(Input$ExtrinsicStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicStddevPopOrderBy;

  factory CopyWith$Input$ExtrinsicStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicStddevPopOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicStddevPopOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicStddevPopOrderBy _instance;

  final TRes Function(Input$ExtrinsicStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicStddevPopOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicStddevPopOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicStddevPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicStddevSampOrderBy {
  factory Input$ExtrinsicStddevSampOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicStddevSampOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicStddevSampOrderBy._(this._$data);

  factory Input$ExtrinsicStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicStddevSampOrderBy<Input$ExtrinsicStddevSampOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicStddevSampOrderBy(
    Input$ExtrinsicStddevSampOrderBy instance,
    TRes Function(Input$ExtrinsicStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicStddevSampOrderBy;

  factory CopyWith$Input$ExtrinsicStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicStddevSampOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicStddevSampOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicStddevSampOrderBy _instance;

  final TRes Function(Input$ExtrinsicStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicStddevSampOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicStddevSampOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicStddevSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicSumOrderBy {
  factory Input$ExtrinsicSumOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicSumOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicSumOrderBy._(this._$data);

  factory Input$ExtrinsicSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicSumOrderBy<Input$ExtrinsicSumOrderBy> get copyWith =>
      CopyWith$Input$ExtrinsicSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicSumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicSumOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicSumOrderBy(
    Input$ExtrinsicSumOrderBy instance,
    TRes Function(Input$ExtrinsicSumOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicSumOrderBy;

  factory CopyWith$Input$ExtrinsicSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicSumOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicSumOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicSumOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicSumOrderBy _instance;

  final TRes Function(Input$ExtrinsicSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicSumOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicSumOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicSumOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicVarianceOrderBy {
  factory Input$ExtrinsicVarianceOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicVarianceOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicVarianceOrderBy._(this._$data);

  factory Input$ExtrinsicVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicVarianceOrderBy<Input$ExtrinsicVarianceOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicVarianceOrderBy(
    Input$ExtrinsicVarianceOrderBy instance,
    TRes Function(Input$ExtrinsicVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicVarianceOrderBy;

  factory CopyWith$Input$ExtrinsicVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicVarianceOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicVarianceOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicVarianceOrderBy _instance;

  final TRes Function(Input$ExtrinsicVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicVarianceOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicVarianceOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicVarianceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicVarPopOrderBy {
  factory Input$ExtrinsicVarPopOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicVarPopOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicVarPopOrderBy._(this._$data);

  factory Input$ExtrinsicVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicVarPopOrderBy<Input$ExtrinsicVarPopOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicVarPopOrderBy(
    Input$ExtrinsicVarPopOrderBy instance,
    TRes Function(Input$ExtrinsicVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicVarPopOrderBy;

  factory CopyWith$Input$ExtrinsicVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicVarPopOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicVarPopOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicVarPopOrderBy _instance;

  final TRes Function(Input$ExtrinsicVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicVarPopOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicVarPopOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicVarPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$ExtrinsicVarSampOrderBy {
  factory Input$ExtrinsicVarSampOrderBy({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      Input$ExtrinsicVarSampOrderBy._({
        if (fee != null) r'fee': fee,
        if (index != null) r'index': index,
        if (tip != null) r'tip': tip,
        if (version != null) r'version': version,
      });

  Input$ExtrinsicVarSampOrderBy._(this._$data);

  factory Input$ExtrinsicVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fee')) {
      final l$fee = data['fee'];
      result$data['fee'] =
          l$fee == null ? null : fromJson$Enum$OrderBy((l$fee as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('tip')) {
      final l$tip = data['tip'];
      result$data['tip'] =
          l$tip == null ? null : fromJson$Enum$OrderBy((l$tip as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$OrderBy((l$version as String));
    }
    return Input$ExtrinsicVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get fee => (_$data['fee'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get tip => (_$data['tip'] as Enum$OrderBy?);

  Enum$OrderBy? get version => (_$data['version'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fee')) {
      final l$fee = fee;
      result$data['fee'] = l$fee == null ? null : toJson$Enum$OrderBy(l$fee);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('tip')) {
      final l$tip = tip;
      result$data['tip'] = l$tip == null ? null : toJson$Enum$OrderBy(l$tip);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] =
          l$version == null ? null : toJson$Enum$OrderBy(l$version);
    }
    return result$data;
  }

  CopyWith$Input$ExtrinsicVarSampOrderBy<Input$ExtrinsicVarSampOrderBy>
      get copyWith => CopyWith$Input$ExtrinsicVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExtrinsicVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fee = fee;
    final lOther$fee = other.fee;
    if (_$data.containsKey('fee') != other._$data.containsKey('fee')) {
      return false;
    }
    if (l$fee != lOther$fee) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$tip = tip;
    final lOther$tip = other.tip;
    if (_$data.containsKey('tip') != other._$data.containsKey('tip')) {
      return false;
    }
    if (l$tip != lOther$tip) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fee = fee;
    final l$index = index;
    final l$tip = tip;
    final l$version = version;
    return Object.hashAll([
      _$data.containsKey('fee') ? l$fee : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('tip') ? l$tip : const {},
      _$data.containsKey('version') ? l$version : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> {
  factory CopyWith$Input$ExtrinsicVarSampOrderBy(
    Input$ExtrinsicVarSampOrderBy instance,
    TRes Function(Input$ExtrinsicVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$ExtrinsicVarSampOrderBy;

  factory CopyWith$Input$ExtrinsicVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ExtrinsicVarSampOrderBy;

  TRes call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  });
}

class _CopyWithImpl$Input$ExtrinsicVarSampOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$ExtrinsicVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$ExtrinsicVarSampOrderBy _instance;

  final TRes Function(Input$ExtrinsicVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fee = _undefined,
    Object? index = _undefined,
    Object? tip = _undefined,
    Object? version = _undefined,
  }) =>
      _then(Input$ExtrinsicVarSampOrderBy._({
        ..._instance._$data,
        if (fee != _undefined) 'fee': (fee as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (tip != _undefined) 'tip': (tip as Enum$OrderBy?),
        if (version != _undefined) 'version': (version as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ExtrinsicVarSampOrderBy<TRes>
    implements CopyWith$Input$ExtrinsicVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$ExtrinsicVarSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? fee,
    Enum$OrderBy? index,
    Enum$OrderBy? tip,
    Enum$OrderBy? version,
  }) =>
      _res;
}

class Input$getUdHistoryArgs {
  factory Input$getUdHistoryArgs({String? identity_row}) =>
      Input$getUdHistoryArgs._({
        if (identity_row != null) r'identity_row': identity_row,
      });

  Input$getUdHistoryArgs._(this._$data);

  factory Input$getUdHistoryArgs.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('identity_row')) {
      final l$identity_row = data['identity_row'];
      result$data['identity_row'] = (l$identity_row as String?);
    }
    return Input$getUdHistoryArgs._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get identity_row => (_$data['identity_row'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('identity_row')) {
      final l$identity_row = identity_row;
      result$data['identity_row'] = l$identity_row;
    }
    return result$data;
  }

  CopyWith$Input$getUdHistoryArgs<Input$getUdHistoryArgs> get copyWith =>
      CopyWith$Input$getUdHistoryArgs(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getUdHistoryArgs) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$identity_row = identity_row;
    final lOther$identity_row = other.identity_row;
    if (_$data.containsKey('identity_row') !=
        other._$data.containsKey('identity_row')) {
      return false;
    }
    if (l$identity_row != lOther$identity_row) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$identity_row = identity_row;
    return Object.hashAll(
        [_$data.containsKey('identity_row') ? l$identity_row : const {}]);
  }
}

abstract class CopyWith$Input$getUdHistoryArgs<TRes> {
  factory CopyWith$Input$getUdHistoryArgs(
    Input$getUdHistoryArgs instance,
    TRes Function(Input$getUdHistoryArgs) then,
  ) = _CopyWithImpl$Input$getUdHistoryArgs;

  factory CopyWith$Input$getUdHistoryArgs.stub(TRes res) =
      _CopyWithStubImpl$Input$getUdHistoryArgs;

  TRes call({String? identity_row});
}

class _CopyWithImpl$Input$getUdHistoryArgs<TRes>
    implements CopyWith$Input$getUdHistoryArgs<TRes> {
  _CopyWithImpl$Input$getUdHistoryArgs(
    this._instance,
    this._then,
  );

  final Input$getUdHistoryArgs _instance;

  final TRes Function(Input$getUdHistoryArgs) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? identity_row = _undefined}) =>
      _then(Input$getUdHistoryArgs._({
        ..._instance._$data,
        if (identity_row != _undefined)
          'identity_row': (identity_row as String?),
      }));
}

class _CopyWithStubImpl$Input$getUdHistoryArgs<TRes>
    implements CopyWith$Input$getUdHistoryArgs<TRes> {
  _CopyWithStubImpl$Input$getUdHistoryArgs(this._res);

  TRes _res;

  call({String? identity_row}) => _res;
}

class Input$IdentityBoolExp {
  factory Input$IdentityBoolExp({
    List<Input$IdentityBoolExp>? $_and,
    Input$IdentityBoolExp? $_not,
    List<Input$IdentityBoolExp>? $_or,
    Input$AccountBoolExp? account,
    Input$StringComparisonExp? accountId,
    Input$CertBoolExp? certIssued,
    Input$CertAggregateBoolExp? certIssuedAggregate,
    Input$CertBoolExp? certReceived,
    Input$CertAggregateBoolExp? certReceivedAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$BooleanComparisonExp? isMember,
    Input$IntComparisonExp? lastChangeOn,
    Input$AccountBoolExp? linkedAccount,
    Input$AccountAggregateBoolExp? linkedAccountAggregate,
    Input$MembershipEventBoolExp? membershipHistory,
    Input$MembershipEventAggregateBoolExp? membershipHistoryAggregate,
    Input$StringComparisonExp? name,
    Input$ChangeOwnerKeyBoolExp? ownerKeyChange,
    Input$ChangeOwnerKeyAggregateBoolExp? ownerKeyChangeAggregate,
    Input$SmithCertBoolExp? smithCertIssued,
    Input$SmithCertAggregateBoolExp? smithCertIssuedAggregate,
    Input$SmithCertBoolExp? smithCertReceived,
    Input$SmithCertAggregateBoolExp? smithCertReceivedAggregate,
    Input$SmithStatusEnumComparisonExp? smithStatus,
    Input$IdentityStatusEnumComparisonExp? status,
    Input$UdHistoryBoolExp? udHistory,
  }) =>
      Input$IdentityBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (account != null) r'account': account,
        if (accountId != null) r'accountId': accountId,
        if (certIssued != null) r'certIssued': certIssued,
        if (certIssuedAggregate != null)
          r'certIssuedAggregate': certIssuedAggregate,
        if (certReceived != null) r'certReceived': certReceived,
        if (certReceivedAggregate != null)
          r'certReceivedAggregate': certReceivedAggregate,
        if (createdIn != null) r'createdIn': createdIn,
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (isMember != null) r'isMember': isMember,
        if (lastChangeOn != null) r'lastChangeOn': lastChangeOn,
        if (linkedAccount != null) r'linkedAccount': linkedAccount,
        if (linkedAccountAggregate != null)
          r'linkedAccountAggregate': linkedAccountAggregate,
        if (membershipHistory != null) r'membershipHistory': membershipHistory,
        if (membershipHistoryAggregate != null)
          r'membershipHistoryAggregate': membershipHistoryAggregate,
        if (name != null) r'name': name,
        if (ownerKeyChange != null) r'ownerKeyChange': ownerKeyChange,
        if (ownerKeyChangeAggregate != null)
          r'ownerKeyChangeAggregate': ownerKeyChangeAggregate,
        if (smithCertIssued != null) r'smithCertIssued': smithCertIssued,
        if (smithCertIssuedAggregate != null)
          r'smithCertIssuedAggregate': smithCertIssuedAggregate,
        if (smithCertReceived != null) r'smithCertReceived': smithCertReceived,
        if (smithCertReceivedAggregate != null)
          r'smithCertReceivedAggregate': smithCertReceivedAggregate,
        if (smithStatus != null) r'smithStatus': smithStatus,
        if (status != null) r'status': status,
        if (udHistory != null) r'udHistory': udHistory,
      });

  Input$IdentityBoolExp._(this._$data);

  factory Input$IdentityBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$IdentityBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$IdentityBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$IdentityBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('account')) {
      final l$account = data['account'];
      result$data['account'] = l$account == null
          ? null
          : Input$AccountBoolExp.fromJson((l$account as Map<String, dynamic>));
    }
    if (data.containsKey('accountId')) {
      final l$accountId = data['accountId'];
      result$data['accountId'] = l$accountId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$accountId as Map<String, dynamic>));
    }
    if (data.containsKey('certIssued')) {
      final l$certIssued = data['certIssued'];
      result$data['certIssued'] = l$certIssued == null
          ? null
          : Input$CertBoolExp.fromJson((l$certIssued as Map<String, dynamic>));
    }
    if (data.containsKey('certIssuedAggregate')) {
      final l$certIssuedAggregate = data['certIssuedAggregate'];
      result$data['certIssuedAggregate'] = l$certIssuedAggregate == null
          ? null
          : Input$CertAggregateBoolExp.fromJson(
              (l$certIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('certReceived')) {
      final l$certReceived = data['certReceived'];
      result$data['certReceived'] = l$certReceived == null
          ? null
          : Input$CertBoolExp.fromJson(
              (l$certReceived as Map<String, dynamic>));
    }
    if (data.containsKey('certReceivedAggregate')) {
      final l$certReceivedAggregate = data['certReceivedAggregate'];
      result$data['certReceivedAggregate'] = l$certReceivedAggregate == null
          ? null
          : Input$CertAggregateBoolExp.fromJson(
              (l$certReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('createdIn')) {
      final l$createdIn = data['createdIn'];
      result$data['createdIn'] = l$createdIn == null
          ? null
          : Input$EventBoolExp.fromJson((l$createdIn as Map<String, dynamic>));
    }
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$createdInId as Map<String, dynamic>));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$createdOn as Map<String, dynamic>));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$expireOn as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] = l$index == null
          ? null
          : Input$IntComparisonExp.fromJson((l$index as Map<String, dynamic>));
    }
    if (data.containsKey('isMember')) {
      final l$isMember = data['isMember'];
      result$data['isMember'] = l$isMember == null
          ? null
          : Input$BooleanComparisonExp.fromJson(
              (l$isMember as Map<String, dynamic>));
    }
    if (data.containsKey('lastChangeOn')) {
      final l$lastChangeOn = data['lastChangeOn'];
      result$data['lastChangeOn'] = l$lastChangeOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$lastChangeOn as Map<String, dynamic>));
    }
    if (data.containsKey('linkedAccount')) {
      final l$linkedAccount = data['linkedAccount'];
      result$data['linkedAccount'] = l$linkedAccount == null
          ? null
          : Input$AccountBoolExp.fromJson(
              (l$linkedAccount as Map<String, dynamic>));
    }
    if (data.containsKey('linkedAccountAggregate')) {
      final l$linkedAccountAggregate = data['linkedAccountAggregate'];
      result$data['linkedAccountAggregate'] = l$linkedAccountAggregate == null
          ? null
          : Input$AccountAggregateBoolExp.fromJson(
              (l$linkedAccountAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('membershipHistory')) {
      final l$membershipHistory = data['membershipHistory'];
      result$data['membershipHistory'] = l$membershipHistory == null
          ? null
          : Input$MembershipEventBoolExp.fromJson(
              (l$membershipHistory as Map<String, dynamic>));
    }
    if (data.containsKey('membershipHistoryAggregate')) {
      final l$membershipHistoryAggregate = data['membershipHistoryAggregate'];
      result$data['membershipHistoryAggregate'] =
          l$membershipHistoryAggregate == null
              ? null
              : Input$MembershipEventAggregateBoolExp.fromJson(
                  (l$membershipHistoryAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('ownerKeyChange')) {
      final l$ownerKeyChange = data['ownerKeyChange'];
      result$data['ownerKeyChange'] = l$ownerKeyChange == null
          ? null
          : Input$ChangeOwnerKeyBoolExp.fromJson(
              (l$ownerKeyChange as Map<String, dynamic>));
    }
    if (data.containsKey('ownerKeyChangeAggregate')) {
      final l$ownerKeyChangeAggregate = data['ownerKeyChangeAggregate'];
      result$data['ownerKeyChangeAggregate'] = l$ownerKeyChangeAggregate == null
          ? null
          : Input$ChangeOwnerKeyAggregateBoolExp.fromJson(
              (l$ownerKeyChangeAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertIssued')) {
      final l$smithCertIssued = data['smithCertIssued'];
      result$data['smithCertIssued'] = l$smithCertIssued == null
          ? null
          : Input$SmithCertBoolExp.fromJson(
              (l$smithCertIssued as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertIssuedAggregate')) {
      final l$smithCertIssuedAggregate = data['smithCertIssuedAggregate'];
      result$data['smithCertIssuedAggregate'] =
          l$smithCertIssuedAggregate == null
              ? null
              : Input$SmithCertAggregateBoolExp.fromJson(
                  (l$smithCertIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertReceived')) {
      final l$smithCertReceived = data['smithCertReceived'];
      result$data['smithCertReceived'] = l$smithCertReceived == null
          ? null
          : Input$SmithCertBoolExp.fromJson(
              (l$smithCertReceived as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertReceivedAggregate')) {
      final l$smithCertReceivedAggregate = data['smithCertReceivedAggregate'];
      result$data['smithCertReceivedAggregate'] =
          l$smithCertReceivedAggregate == null
              ? null
              : Input$SmithCertAggregateBoolExp.fromJson(
                  (l$smithCertReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithStatus')) {
      final l$smithStatus = data['smithStatus'];
      result$data['smithStatus'] = l$smithStatus == null
          ? null
          : Input$SmithStatusEnumComparisonExp.fromJson(
              (l$smithStatus as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$IdentityStatusEnumComparisonExp.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('udHistory')) {
      final l$udHistory = data['udHistory'];
      result$data['udHistory'] = l$udHistory == null
          ? null
          : Input$UdHistoryBoolExp.fromJson(
              (l$udHistory as Map<String, dynamic>));
    }
    return Input$IdentityBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$IdentityBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$IdentityBoolExp>?);

  Input$IdentityBoolExp? get $_not =>
      (_$data['_not'] as Input$IdentityBoolExp?);

  List<Input$IdentityBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$IdentityBoolExp>?);

  Input$AccountBoolExp? get account =>
      (_$data['account'] as Input$AccountBoolExp?);

  Input$StringComparisonExp? get accountId =>
      (_$data['accountId'] as Input$StringComparisonExp?);

  Input$CertBoolExp? get certIssued =>
      (_$data['certIssued'] as Input$CertBoolExp?);

  Input$CertAggregateBoolExp? get certIssuedAggregate =>
      (_$data['certIssuedAggregate'] as Input$CertAggregateBoolExp?);

  Input$CertBoolExp? get certReceived =>
      (_$data['certReceived'] as Input$CertBoolExp?);

  Input$CertAggregateBoolExp? get certReceivedAggregate =>
      (_$data['certReceivedAggregate'] as Input$CertAggregateBoolExp?);

  Input$EventBoolExp? get createdIn =>
      (_$data['createdIn'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get createdInId =>
      (_$data['createdInId'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get createdOn =>
      (_$data['createdOn'] as Input$IntComparisonExp?);

  Input$IntComparisonExp? get expireOn =>
      (_$data['expireOn'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get index =>
      (_$data['index'] as Input$IntComparisonExp?);

  Input$BooleanComparisonExp? get isMember =>
      (_$data['isMember'] as Input$BooleanComparisonExp?);

  Input$IntComparisonExp? get lastChangeOn =>
      (_$data['lastChangeOn'] as Input$IntComparisonExp?);

  Input$AccountBoolExp? get linkedAccount =>
      (_$data['linkedAccount'] as Input$AccountBoolExp?);

  Input$AccountAggregateBoolExp? get linkedAccountAggregate =>
      (_$data['linkedAccountAggregate'] as Input$AccountAggregateBoolExp?);

  Input$MembershipEventBoolExp? get membershipHistory =>
      (_$data['membershipHistory'] as Input$MembershipEventBoolExp?);

  Input$MembershipEventAggregateBoolExp? get membershipHistoryAggregate =>
      (_$data['membershipHistoryAggregate']
          as Input$MembershipEventAggregateBoolExp?);

  Input$StringComparisonExp? get name =>
      (_$data['name'] as Input$StringComparisonExp?);

  Input$ChangeOwnerKeyBoolExp? get ownerKeyChange =>
      (_$data['ownerKeyChange'] as Input$ChangeOwnerKeyBoolExp?);

  Input$ChangeOwnerKeyAggregateBoolExp? get ownerKeyChangeAggregate =>
      (_$data['ownerKeyChangeAggregate']
          as Input$ChangeOwnerKeyAggregateBoolExp?);

  Input$SmithCertBoolExp? get smithCertIssued =>
      (_$data['smithCertIssued'] as Input$SmithCertBoolExp?);

  Input$SmithCertAggregateBoolExp? get smithCertIssuedAggregate =>
      (_$data['smithCertIssuedAggregate'] as Input$SmithCertAggregateBoolExp?);

  Input$SmithCertBoolExp? get smithCertReceived =>
      (_$data['smithCertReceived'] as Input$SmithCertBoolExp?);

  Input$SmithCertAggregateBoolExp? get smithCertReceivedAggregate =>
      (_$data['smithCertReceivedAggregate']
          as Input$SmithCertAggregateBoolExp?);

  Input$SmithStatusEnumComparisonExp? get smithStatus =>
      (_$data['smithStatus'] as Input$SmithStatusEnumComparisonExp?);

  Input$IdentityStatusEnumComparisonExp? get status =>
      (_$data['status'] as Input$IdentityStatusEnumComparisonExp?);

  Input$UdHistoryBoolExp? get udHistory =>
      (_$data['udHistory'] as Input$UdHistoryBoolExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('account')) {
      final l$account = account;
      result$data['account'] = l$account?.toJson();
    }
    if (_$data.containsKey('accountId')) {
      final l$accountId = accountId;
      result$data['accountId'] = l$accountId?.toJson();
    }
    if (_$data.containsKey('certIssued')) {
      final l$certIssued = certIssued;
      result$data['certIssued'] = l$certIssued?.toJson();
    }
    if (_$data.containsKey('certIssuedAggregate')) {
      final l$certIssuedAggregate = certIssuedAggregate;
      result$data['certIssuedAggregate'] = l$certIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('certReceived')) {
      final l$certReceived = certReceived;
      result$data['certReceived'] = l$certReceived?.toJson();
    }
    if (_$data.containsKey('certReceivedAggregate')) {
      final l$certReceivedAggregate = certReceivedAggregate;
      result$data['certReceivedAggregate'] = l$certReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('createdIn')) {
      final l$createdIn = createdIn;
      result$data['createdIn'] = l$createdIn?.toJson();
    }
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] = l$createdInId?.toJson();
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] = l$createdOn?.toJson();
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] = l$expireOn?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] = l$index?.toJson();
    }
    if (_$data.containsKey('isMember')) {
      final l$isMember = isMember;
      result$data['isMember'] = l$isMember?.toJson();
    }
    if (_$data.containsKey('lastChangeOn')) {
      final l$lastChangeOn = lastChangeOn;
      result$data['lastChangeOn'] = l$lastChangeOn?.toJson();
    }
    if (_$data.containsKey('linkedAccount')) {
      final l$linkedAccount = linkedAccount;
      result$data['linkedAccount'] = l$linkedAccount?.toJson();
    }
    if (_$data.containsKey('linkedAccountAggregate')) {
      final l$linkedAccountAggregate = linkedAccountAggregate;
      result$data['linkedAccountAggregate'] =
          l$linkedAccountAggregate?.toJson();
    }
    if (_$data.containsKey('membershipHistory')) {
      final l$membershipHistory = membershipHistory;
      result$data['membershipHistory'] = l$membershipHistory?.toJson();
    }
    if (_$data.containsKey('membershipHistoryAggregate')) {
      final l$membershipHistoryAggregate = membershipHistoryAggregate;
      result$data['membershipHistoryAggregate'] =
          l$membershipHistoryAggregate?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('ownerKeyChange')) {
      final l$ownerKeyChange = ownerKeyChange;
      result$data['ownerKeyChange'] = l$ownerKeyChange?.toJson();
    }
    if (_$data.containsKey('ownerKeyChangeAggregate')) {
      final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
      result$data['ownerKeyChangeAggregate'] =
          l$ownerKeyChangeAggregate?.toJson();
    }
    if (_$data.containsKey('smithCertIssued')) {
      final l$smithCertIssued = smithCertIssued;
      result$data['smithCertIssued'] = l$smithCertIssued?.toJson();
    }
    if (_$data.containsKey('smithCertIssuedAggregate')) {
      final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
      result$data['smithCertIssuedAggregate'] =
          l$smithCertIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('smithCertReceived')) {
      final l$smithCertReceived = smithCertReceived;
      result$data['smithCertReceived'] = l$smithCertReceived?.toJson();
    }
    if (_$data.containsKey('smithCertReceivedAggregate')) {
      final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
      result$data['smithCertReceivedAggregate'] =
          l$smithCertReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('smithStatus')) {
      final l$smithStatus = smithStatus;
      result$data['smithStatus'] = l$smithStatus?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('udHistory')) {
      final l$udHistory = udHistory;
      result$data['udHistory'] = l$udHistory?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IdentityBoolExp<Input$IdentityBoolExp> get copyWith =>
      CopyWith$Input$IdentityBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IdentityBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$account = account;
    final lOther$account = other.account;
    if (_$data.containsKey('account') != other._$data.containsKey('account')) {
      return false;
    }
    if (l$account != lOther$account) {
      return false;
    }
    final l$accountId = accountId;
    final lOther$accountId = other.accountId;
    if (_$data.containsKey('accountId') !=
        other._$data.containsKey('accountId')) {
      return false;
    }
    if (l$accountId != lOther$accountId) {
      return false;
    }
    final l$certIssued = certIssued;
    final lOther$certIssued = other.certIssued;
    if (_$data.containsKey('certIssued') !=
        other._$data.containsKey('certIssued')) {
      return false;
    }
    if (l$certIssued != lOther$certIssued) {
      return false;
    }
    final l$certIssuedAggregate = certIssuedAggregate;
    final lOther$certIssuedAggregate = other.certIssuedAggregate;
    if (_$data.containsKey('certIssuedAggregate') !=
        other._$data.containsKey('certIssuedAggregate')) {
      return false;
    }
    if (l$certIssuedAggregate != lOther$certIssuedAggregate) {
      return false;
    }
    final l$certReceived = certReceived;
    final lOther$certReceived = other.certReceived;
    if (_$data.containsKey('certReceived') !=
        other._$data.containsKey('certReceived')) {
      return false;
    }
    if (l$certReceived != lOther$certReceived) {
      return false;
    }
    final l$certReceivedAggregate = certReceivedAggregate;
    final lOther$certReceivedAggregate = other.certReceivedAggregate;
    if (_$data.containsKey('certReceivedAggregate') !=
        other._$data.containsKey('certReceivedAggregate')) {
      return false;
    }
    if (l$certReceivedAggregate != lOther$certReceivedAggregate) {
      return false;
    }
    final l$createdIn = createdIn;
    final lOther$createdIn = other.createdIn;
    if (_$data.containsKey('createdIn') !=
        other._$data.containsKey('createdIn')) {
      return false;
    }
    if (l$createdIn != lOther$createdIn) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isMember = isMember;
    final lOther$isMember = other.isMember;
    if (_$data.containsKey('isMember') !=
        other._$data.containsKey('isMember')) {
      return false;
    }
    if (l$isMember != lOther$isMember) {
      return false;
    }
    final l$lastChangeOn = lastChangeOn;
    final lOther$lastChangeOn = other.lastChangeOn;
    if (_$data.containsKey('lastChangeOn') !=
        other._$data.containsKey('lastChangeOn')) {
      return false;
    }
    if (l$lastChangeOn != lOther$lastChangeOn) {
      return false;
    }
    final l$linkedAccount = linkedAccount;
    final lOther$linkedAccount = other.linkedAccount;
    if (_$data.containsKey('linkedAccount') !=
        other._$data.containsKey('linkedAccount')) {
      return false;
    }
    if (l$linkedAccount != lOther$linkedAccount) {
      return false;
    }
    final l$linkedAccountAggregate = linkedAccountAggregate;
    final lOther$linkedAccountAggregate = other.linkedAccountAggregate;
    if (_$data.containsKey('linkedAccountAggregate') !=
        other._$data.containsKey('linkedAccountAggregate')) {
      return false;
    }
    if (l$linkedAccountAggregate != lOther$linkedAccountAggregate) {
      return false;
    }
    final l$membershipHistory = membershipHistory;
    final lOther$membershipHistory = other.membershipHistory;
    if (_$data.containsKey('membershipHistory') !=
        other._$data.containsKey('membershipHistory')) {
      return false;
    }
    if (l$membershipHistory != lOther$membershipHistory) {
      return false;
    }
    final l$membershipHistoryAggregate = membershipHistoryAggregate;
    final lOther$membershipHistoryAggregate = other.membershipHistoryAggregate;
    if (_$data.containsKey('membershipHistoryAggregate') !=
        other._$data.containsKey('membershipHistoryAggregate')) {
      return false;
    }
    if (l$membershipHistoryAggregate != lOther$membershipHistoryAggregate) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerKeyChange = ownerKeyChange;
    final lOther$ownerKeyChange = other.ownerKeyChange;
    if (_$data.containsKey('ownerKeyChange') !=
        other._$data.containsKey('ownerKeyChange')) {
      return false;
    }
    if (l$ownerKeyChange != lOther$ownerKeyChange) {
      return false;
    }
    final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
    final lOther$ownerKeyChangeAggregate = other.ownerKeyChangeAggregate;
    if (_$data.containsKey('ownerKeyChangeAggregate') !=
        other._$data.containsKey('ownerKeyChangeAggregate')) {
      return false;
    }
    if (l$ownerKeyChangeAggregate != lOther$ownerKeyChangeAggregate) {
      return false;
    }
    final l$smithCertIssued = smithCertIssued;
    final lOther$smithCertIssued = other.smithCertIssued;
    if (_$data.containsKey('smithCertIssued') !=
        other._$data.containsKey('smithCertIssued')) {
      return false;
    }
    if (l$smithCertIssued != lOther$smithCertIssued) {
      return false;
    }
    final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
    final lOther$smithCertIssuedAggregate = other.smithCertIssuedAggregate;
    if (_$data.containsKey('smithCertIssuedAggregate') !=
        other._$data.containsKey('smithCertIssuedAggregate')) {
      return false;
    }
    if (l$smithCertIssuedAggregate != lOther$smithCertIssuedAggregate) {
      return false;
    }
    final l$smithCertReceived = smithCertReceived;
    final lOther$smithCertReceived = other.smithCertReceived;
    if (_$data.containsKey('smithCertReceived') !=
        other._$data.containsKey('smithCertReceived')) {
      return false;
    }
    if (l$smithCertReceived != lOther$smithCertReceived) {
      return false;
    }
    final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
    final lOther$smithCertReceivedAggregate = other.smithCertReceivedAggregate;
    if (_$data.containsKey('smithCertReceivedAggregate') !=
        other._$data.containsKey('smithCertReceivedAggregate')) {
      return false;
    }
    if (l$smithCertReceivedAggregate != lOther$smithCertReceivedAggregate) {
      return false;
    }
    final l$smithStatus = smithStatus;
    final lOther$smithStatus = other.smithStatus;
    if (_$data.containsKey('smithStatus') !=
        other._$data.containsKey('smithStatus')) {
      return false;
    }
    if (l$smithStatus != lOther$smithStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$udHistory = udHistory;
    final lOther$udHistory = other.udHistory;
    if (_$data.containsKey('udHistory') !=
        other._$data.containsKey('udHistory')) {
      return false;
    }
    if (l$udHistory != lOther$udHistory) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$account = account;
    final l$accountId = accountId;
    final l$certIssued = certIssued;
    final l$certIssuedAggregate = certIssuedAggregate;
    final l$certReceived = certReceived;
    final l$certReceivedAggregate = certReceivedAggregate;
    final l$createdIn = createdIn;
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$index = index;
    final l$isMember = isMember;
    final l$lastChangeOn = lastChangeOn;
    final l$linkedAccount = linkedAccount;
    final l$linkedAccountAggregate = linkedAccountAggregate;
    final l$membershipHistory = membershipHistory;
    final l$membershipHistoryAggregate = membershipHistoryAggregate;
    final l$name = name;
    final l$ownerKeyChange = ownerKeyChange;
    final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
    final l$smithCertIssued = smithCertIssued;
    final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
    final l$smithCertReceived = smithCertReceived;
    final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
    final l$smithStatus = smithStatus;
    final l$status = status;
    final l$udHistory = udHistory;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('account') ? l$account : const {},
      _$data.containsKey('accountId') ? l$accountId : const {},
      _$data.containsKey('certIssued') ? l$certIssued : const {},
      _$data.containsKey('certIssuedAggregate')
          ? l$certIssuedAggregate
          : const {},
      _$data.containsKey('certReceived') ? l$certReceived : const {},
      _$data.containsKey('certReceivedAggregate')
          ? l$certReceivedAggregate
          : const {},
      _$data.containsKey('createdIn') ? l$createdIn : const {},
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isMember') ? l$isMember : const {},
      _$data.containsKey('lastChangeOn') ? l$lastChangeOn : const {},
      _$data.containsKey('linkedAccount') ? l$linkedAccount : const {},
      _$data.containsKey('linkedAccountAggregate')
          ? l$linkedAccountAggregate
          : const {},
      _$data.containsKey('membershipHistory') ? l$membershipHistory : const {},
      _$data.containsKey('membershipHistoryAggregate')
          ? l$membershipHistoryAggregate
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('ownerKeyChange') ? l$ownerKeyChange : const {},
      _$data.containsKey('ownerKeyChangeAggregate')
          ? l$ownerKeyChangeAggregate
          : const {},
      _$data.containsKey('smithCertIssued') ? l$smithCertIssued : const {},
      _$data.containsKey('smithCertIssuedAggregate')
          ? l$smithCertIssuedAggregate
          : const {},
      _$data.containsKey('smithCertReceived') ? l$smithCertReceived : const {},
      _$data.containsKey('smithCertReceivedAggregate')
          ? l$smithCertReceivedAggregate
          : const {},
      _$data.containsKey('smithStatus') ? l$smithStatus : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('udHistory') ? l$udHistory : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityBoolExp<TRes> {
  factory CopyWith$Input$IdentityBoolExp(
    Input$IdentityBoolExp instance,
    TRes Function(Input$IdentityBoolExp) then,
  ) = _CopyWithImpl$Input$IdentityBoolExp;

  factory CopyWith$Input$IdentityBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityBoolExp;

  TRes call({
    List<Input$IdentityBoolExp>? $_and,
    Input$IdentityBoolExp? $_not,
    List<Input$IdentityBoolExp>? $_or,
    Input$AccountBoolExp? account,
    Input$StringComparisonExp? accountId,
    Input$CertBoolExp? certIssued,
    Input$CertAggregateBoolExp? certIssuedAggregate,
    Input$CertBoolExp? certReceived,
    Input$CertAggregateBoolExp? certReceivedAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$BooleanComparisonExp? isMember,
    Input$IntComparisonExp? lastChangeOn,
    Input$AccountBoolExp? linkedAccount,
    Input$AccountAggregateBoolExp? linkedAccountAggregate,
    Input$MembershipEventBoolExp? membershipHistory,
    Input$MembershipEventAggregateBoolExp? membershipHistoryAggregate,
    Input$StringComparisonExp? name,
    Input$ChangeOwnerKeyBoolExp? ownerKeyChange,
    Input$ChangeOwnerKeyAggregateBoolExp? ownerKeyChangeAggregate,
    Input$SmithCertBoolExp? smithCertIssued,
    Input$SmithCertAggregateBoolExp? smithCertIssuedAggregate,
    Input$SmithCertBoolExp? smithCertReceived,
    Input$SmithCertAggregateBoolExp? smithCertReceivedAggregate,
    Input$SmithStatusEnumComparisonExp? smithStatus,
    Input$IdentityStatusEnumComparisonExp? status,
    Input$UdHistoryBoolExp? udHistory,
  });
  TRes $_and(
      Iterable<Input$IdentityBoolExp>? Function(
              Iterable<CopyWith$Input$IdentityBoolExp<Input$IdentityBoolExp>>?)
          _fn);
  CopyWith$Input$IdentityBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$IdentityBoolExp>? Function(
              Iterable<CopyWith$Input$IdentityBoolExp<Input$IdentityBoolExp>>?)
          _fn);
  CopyWith$Input$AccountBoolExp<TRes> get account;
  CopyWith$Input$StringComparisonExp<TRes> get accountId;
  CopyWith$Input$CertBoolExp<TRes> get certIssued;
  CopyWith$Input$CertAggregateBoolExp<TRes> get certIssuedAggregate;
  CopyWith$Input$CertBoolExp<TRes> get certReceived;
  CopyWith$Input$CertAggregateBoolExp<TRes> get certReceivedAggregate;
  CopyWith$Input$EventBoolExp<TRes> get createdIn;
  CopyWith$Input$StringComparisonExp<TRes> get createdInId;
  CopyWith$Input$IntComparisonExp<TRes> get createdOn;
  CopyWith$Input$IntComparisonExp<TRes> get expireOn;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IntComparisonExp<TRes> get index;
  CopyWith$Input$BooleanComparisonExp<TRes> get isMember;
  CopyWith$Input$IntComparisonExp<TRes> get lastChangeOn;
  CopyWith$Input$AccountBoolExp<TRes> get linkedAccount;
  CopyWith$Input$AccountAggregateBoolExp<TRes> get linkedAccountAggregate;
  CopyWith$Input$MembershipEventBoolExp<TRes> get membershipHistory;
  CopyWith$Input$MembershipEventAggregateBoolExp<TRes>
      get membershipHistoryAggregate;
  CopyWith$Input$StringComparisonExp<TRes> get name;
  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get ownerKeyChange;
  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
      get ownerKeyChangeAggregate;
  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertIssued;
  CopyWith$Input$SmithCertAggregateBoolExp<TRes> get smithCertIssuedAggregate;
  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertReceived;
  CopyWith$Input$SmithCertAggregateBoolExp<TRes> get smithCertReceivedAggregate;
  CopyWith$Input$SmithStatusEnumComparisonExp<TRes> get smithStatus;
  CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> get status;
  CopyWith$Input$UdHistoryBoolExp<TRes> get udHistory;
}

class _CopyWithImpl$Input$IdentityBoolExp<TRes>
    implements CopyWith$Input$IdentityBoolExp<TRes> {
  _CopyWithImpl$Input$IdentityBoolExp(
    this._instance,
    this._then,
  );

  final Input$IdentityBoolExp _instance;

  final TRes Function(Input$IdentityBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? account = _undefined,
    Object? accountId = _undefined,
    Object? certIssued = _undefined,
    Object? certIssuedAggregate = _undefined,
    Object? certReceived = _undefined,
    Object? certReceivedAggregate = _undefined,
    Object? createdIn = _undefined,
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? isMember = _undefined,
    Object? lastChangeOn = _undefined,
    Object? linkedAccount = _undefined,
    Object? linkedAccountAggregate = _undefined,
    Object? membershipHistory = _undefined,
    Object? membershipHistoryAggregate = _undefined,
    Object? name = _undefined,
    Object? ownerKeyChange = _undefined,
    Object? ownerKeyChangeAggregate = _undefined,
    Object? smithCertIssued = _undefined,
    Object? smithCertIssuedAggregate = _undefined,
    Object? smithCertReceived = _undefined,
    Object? smithCertReceivedAggregate = _undefined,
    Object? smithStatus = _undefined,
    Object? status = _undefined,
    Object? udHistory = _undefined,
  }) =>
      _then(Input$IdentityBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$IdentityBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$IdentityBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$IdentityBoolExp>?),
        if (account != _undefined)
          'account': (account as Input$AccountBoolExp?),
        if (accountId != _undefined)
          'accountId': (accountId as Input$StringComparisonExp?),
        if (certIssued != _undefined)
          'certIssued': (certIssued as Input$CertBoolExp?),
        if (certIssuedAggregate != _undefined)
          'certIssuedAggregate':
              (certIssuedAggregate as Input$CertAggregateBoolExp?),
        if (certReceived != _undefined)
          'certReceived': (certReceived as Input$CertBoolExp?),
        if (certReceivedAggregate != _undefined)
          'certReceivedAggregate':
              (certReceivedAggregate as Input$CertAggregateBoolExp?),
        if (createdIn != _undefined)
          'createdIn': (createdIn as Input$EventBoolExp?),
        if (createdInId != _undefined)
          'createdInId': (createdInId as Input$StringComparisonExp?),
        if (createdOn != _undefined)
          'createdOn': (createdOn as Input$IntComparisonExp?),
        if (expireOn != _undefined)
          'expireOn': (expireOn as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (index != _undefined) 'index': (index as Input$IntComparisonExp?),
        if (isMember != _undefined)
          'isMember': (isMember as Input$BooleanComparisonExp?),
        if (lastChangeOn != _undefined)
          'lastChangeOn': (lastChangeOn as Input$IntComparisonExp?),
        if (linkedAccount != _undefined)
          'linkedAccount': (linkedAccount as Input$AccountBoolExp?),
        if (linkedAccountAggregate != _undefined)
          'linkedAccountAggregate':
              (linkedAccountAggregate as Input$AccountAggregateBoolExp?),
        if (membershipHistory != _undefined)
          'membershipHistory':
              (membershipHistory as Input$MembershipEventBoolExp?),
        if (membershipHistoryAggregate != _undefined)
          'membershipHistoryAggregate': (membershipHistoryAggregate
              as Input$MembershipEventAggregateBoolExp?),
        if (name != _undefined) 'name': (name as Input$StringComparisonExp?),
        if (ownerKeyChange != _undefined)
          'ownerKeyChange': (ownerKeyChange as Input$ChangeOwnerKeyBoolExp?),
        if (ownerKeyChangeAggregate != _undefined)
          'ownerKeyChangeAggregate': (ownerKeyChangeAggregate
              as Input$ChangeOwnerKeyAggregateBoolExp?),
        if (smithCertIssued != _undefined)
          'smithCertIssued': (smithCertIssued as Input$SmithCertBoolExp?),
        if (smithCertIssuedAggregate != _undefined)
          'smithCertIssuedAggregate':
              (smithCertIssuedAggregate as Input$SmithCertAggregateBoolExp?),
        if (smithCertReceived != _undefined)
          'smithCertReceived': (smithCertReceived as Input$SmithCertBoolExp?),
        if (smithCertReceivedAggregate != _undefined)
          'smithCertReceivedAggregate':
              (smithCertReceivedAggregate as Input$SmithCertAggregateBoolExp?),
        if (smithStatus != _undefined)
          'smithStatus': (smithStatus as Input$SmithStatusEnumComparisonExp?),
        if (status != _undefined)
          'status': (status as Input$IdentityStatusEnumComparisonExp?),
        if (udHistory != _undefined)
          'udHistory': (udHistory as Input$UdHistoryBoolExp?),
      }));

  TRes $_and(
          Iterable<Input$IdentityBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$IdentityBoolExp<Input$IdentityBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$IdentityBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IdentityBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$IdentityBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$IdentityBoolExp<Input$IdentityBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$IdentityBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$AccountBoolExp<TRes> get account {
    final local$account = _instance.account;
    return local$account == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$account, (e) => call(account: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get accountId {
    final local$accountId = _instance.accountId;
    return local$accountId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$accountId, (e) => call(accountId: e));
  }

  CopyWith$Input$CertBoolExp<TRes> get certIssued {
    final local$certIssued = _instance.certIssued;
    return local$certIssued == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(
            local$certIssued, (e) => call(certIssued: e));
  }

  CopyWith$Input$CertAggregateBoolExp<TRes> get certIssuedAggregate {
    final local$certIssuedAggregate = _instance.certIssuedAggregate;
    return local$certIssuedAggregate == null
        ? CopyWith$Input$CertAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertAggregateBoolExp(
            local$certIssuedAggregate, (e) => call(certIssuedAggregate: e));
  }

  CopyWith$Input$CertBoolExp<TRes> get certReceived {
    final local$certReceived = _instance.certReceived;
    return local$certReceived == null
        ? CopyWith$Input$CertBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertBoolExp(
            local$certReceived, (e) => call(certReceived: e));
  }

  CopyWith$Input$CertAggregateBoolExp<TRes> get certReceivedAggregate {
    final local$certReceivedAggregate = _instance.certReceivedAggregate;
    return local$certReceivedAggregate == null
        ? CopyWith$Input$CertAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$CertAggregateBoolExp(
            local$certReceivedAggregate, (e) => call(certReceivedAggregate: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get createdIn {
    final local$createdIn = _instance.createdIn;
    return local$createdIn == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(
            local$createdIn, (e) => call(createdIn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get createdInId {
    final local$createdInId = _instance.createdInId;
    return local$createdInId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$createdInId, (e) => call(createdInId: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get createdOn {
    final local$createdOn = _instance.createdOn;
    return local$createdOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$createdOn, (e) => call(createdOn: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get expireOn {
    final local$expireOn = _instance.expireOn;
    return local$expireOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$expireOn, (e) => call(expireOn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get index {
    final local$index = _instance.index;
    return local$index == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$index, (e) => call(index: e));
  }

  CopyWith$Input$BooleanComparisonExp<TRes> get isMember {
    final local$isMember = _instance.isMember;
    return local$isMember == null
        ? CopyWith$Input$BooleanComparisonExp.stub(_then(_instance))
        : CopyWith$Input$BooleanComparisonExp(
            local$isMember, (e) => call(isMember: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get lastChangeOn {
    final local$lastChangeOn = _instance.lastChangeOn;
    return local$lastChangeOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$lastChangeOn, (e) => call(lastChangeOn: e));
  }

  CopyWith$Input$AccountBoolExp<TRes> get linkedAccount {
    final local$linkedAccount = _instance.linkedAccount;
    return local$linkedAccount == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(
            local$linkedAccount, (e) => call(linkedAccount: e));
  }

  CopyWith$Input$AccountAggregateBoolExp<TRes> get linkedAccountAggregate {
    final local$linkedAccountAggregate = _instance.linkedAccountAggregate;
    return local$linkedAccountAggregate == null
        ? CopyWith$Input$AccountAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountAggregateBoolExp(local$linkedAccountAggregate,
            (e) => call(linkedAccountAggregate: e));
  }

  CopyWith$Input$MembershipEventBoolExp<TRes> get membershipHistory {
    final local$membershipHistory = _instance.membershipHistory;
    return local$membershipHistory == null
        ? CopyWith$Input$MembershipEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$MembershipEventBoolExp(
            local$membershipHistory, (e) => call(membershipHistory: e));
  }

  CopyWith$Input$MembershipEventAggregateBoolExp<TRes>
      get membershipHistoryAggregate {
    final local$membershipHistoryAggregate =
        _instance.membershipHistoryAggregate;
    return local$membershipHistoryAggregate == null
        ? CopyWith$Input$MembershipEventAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$MembershipEventAggregateBoolExp(
            local$membershipHistoryAggregate,
            (e) => call(membershipHistoryAggregate: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$name, (e) => call(name: e));
  }

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get ownerKeyChange {
    final local$ownerKeyChange = _instance.ownerKeyChange;
    return local$ownerKeyChange == null
        ? CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyBoolExp(
            local$ownerKeyChange, (e) => call(ownerKeyChange: e));
  }

  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
      get ownerKeyChangeAggregate {
    final local$ownerKeyChangeAggregate = _instance.ownerKeyChangeAggregate;
    return local$ownerKeyChangeAggregate == null
        ? CopyWith$Input$ChangeOwnerKeyAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyAggregateBoolExp(
            local$ownerKeyChangeAggregate,
            (e) => call(ownerKeyChangeAggregate: e));
  }

  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertIssued {
    final local$smithCertIssued = _instance.smithCertIssued;
    return local$smithCertIssued == null
        ? CopyWith$Input$SmithCertBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertBoolExp(
            local$smithCertIssued, (e) => call(smithCertIssued: e));
  }

  CopyWith$Input$SmithCertAggregateBoolExp<TRes> get smithCertIssuedAggregate {
    final local$smithCertIssuedAggregate = _instance.smithCertIssuedAggregate;
    return local$smithCertIssuedAggregate == null
        ? CopyWith$Input$SmithCertAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertAggregateBoolExp(
            local$smithCertIssuedAggregate,
            (e) => call(smithCertIssuedAggregate: e));
  }

  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertReceived {
    final local$smithCertReceived = _instance.smithCertReceived;
    return local$smithCertReceived == null
        ? CopyWith$Input$SmithCertBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertBoolExp(
            local$smithCertReceived, (e) => call(smithCertReceived: e));
  }

  CopyWith$Input$SmithCertAggregateBoolExp<TRes>
      get smithCertReceivedAggregate {
    final local$smithCertReceivedAggregate =
        _instance.smithCertReceivedAggregate;
    return local$smithCertReceivedAggregate == null
        ? CopyWith$Input$SmithCertAggregateBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertAggregateBoolExp(
            local$smithCertReceivedAggregate,
            (e) => call(smithCertReceivedAggregate: e));
  }

  CopyWith$Input$SmithStatusEnumComparisonExp<TRes> get smithStatus {
    final local$smithStatus = _instance.smithStatus;
    return local$smithStatus == null
        ? CopyWith$Input$SmithStatusEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$SmithStatusEnumComparisonExp(
            local$smithStatus, (e) => call(smithStatus: e));
  }

  CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$IdentityStatusEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IdentityStatusEnumComparisonExp(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$UdHistoryBoolExp<TRes> get udHistory {
    final local$udHistory = _instance.udHistory;
    return local$udHistory == null
        ? CopyWith$Input$UdHistoryBoolExp.stub(_then(_instance))
        : CopyWith$Input$UdHistoryBoolExp(
            local$udHistory, (e) => call(udHistory: e));
  }
}

class _CopyWithStubImpl$Input$IdentityBoolExp<TRes>
    implements CopyWith$Input$IdentityBoolExp<TRes> {
  _CopyWithStubImpl$Input$IdentityBoolExp(this._res);

  TRes _res;

  call({
    List<Input$IdentityBoolExp>? $_and,
    Input$IdentityBoolExp? $_not,
    List<Input$IdentityBoolExp>? $_or,
    Input$AccountBoolExp? account,
    Input$StringComparisonExp? accountId,
    Input$CertBoolExp? certIssued,
    Input$CertAggregateBoolExp? certIssuedAggregate,
    Input$CertBoolExp? certReceived,
    Input$CertAggregateBoolExp? certReceivedAggregate,
    Input$EventBoolExp? createdIn,
    Input$StringComparisonExp? createdInId,
    Input$IntComparisonExp? createdOn,
    Input$IntComparisonExp? expireOn,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? index,
    Input$BooleanComparisonExp? isMember,
    Input$IntComparisonExp? lastChangeOn,
    Input$AccountBoolExp? linkedAccount,
    Input$AccountAggregateBoolExp? linkedAccountAggregate,
    Input$MembershipEventBoolExp? membershipHistory,
    Input$MembershipEventAggregateBoolExp? membershipHistoryAggregate,
    Input$StringComparisonExp? name,
    Input$ChangeOwnerKeyBoolExp? ownerKeyChange,
    Input$ChangeOwnerKeyAggregateBoolExp? ownerKeyChangeAggregate,
    Input$SmithCertBoolExp? smithCertIssued,
    Input$SmithCertAggregateBoolExp? smithCertIssuedAggregate,
    Input$SmithCertBoolExp? smithCertReceived,
    Input$SmithCertAggregateBoolExp? smithCertReceivedAggregate,
    Input$SmithStatusEnumComparisonExp? smithStatus,
    Input$IdentityStatusEnumComparisonExp? status,
    Input$UdHistoryBoolExp? udHistory,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$IdentityBoolExp<TRes> get $_not =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$AccountBoolExp<TRes> get account =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get accountId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CertBoolExp<TRes> get certIssued =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$CertAggregateBoolExp<TRes> get certIssuedAggregate =>
      CopyWith$Input$CertAggregateBoolExp.stub(_res);

  CopyWith$Input$CertBoolExp<TRes> get certReceived =>
      CopyWith$Input$CertBoolExp.stub(_res);

  CopyWith$Input$CertAggregateBoolExp<TRes> get certReceivedAggregate =>
      CopyWith$Input$CertAggregateBoolExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get createdIn =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get createdInId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get createdOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get expireOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get index =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$BooleanComparisonExp<TRes> get isMember =>
      CopyWith$Input$BooleanComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get lastChangeOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$AccountBoolExp<TRes> get linkedAccount =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$AccountAggregateBoolExp<TRes> get linkedAccountAggregate =>
      CopyWith$Input$AccountAggregateBoolExp.stub(_res);

  CopyWith$Input$MembershipEventBoolExp<TRes> get membershipHistory =>
      CopyWith$Input$MembershipEventBoolExp.stub(_res);

  CopyWith$Input$MembershipEventAggregateBoolExp<TRes>
      get membershipHistoryAggregate =>
          CopyWith$Input$MembershipEventAggregateBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get name =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$ChangeOwnerKeyBoolExp<TRes> get ownerKeyChange =>
      CopyWith$Input$ChangeOwnerKeyBoolExp.stub(_res);

  CopyWith$Input$ChangeOwnerKeyAggregateBoolExp<TRes>
      get ownerKeyChangeAggregate =>
          CopyWith$Input$ChangeOwnerKeyAggregateBoolExp.stub(_res);

  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertIssued =>
      CopyWith$Input$SmithCertBoolExp.stub(_res);

  CopyWith$Input$SmithCertAggregateBoolExp<TRes> get smithCertIssuedAggregate =>
      CopyWith$Input$SmithCertAggregateBoolExp.stub(_res);

  CopyWith$Input$SmithCertBoolExp<TRes> get smithCertReceived =>
      CopyWith$Input$SmithCertBoolExp.stub(_res);

  CopyWith$Input$SmithCertAggregateBoolExp<TRes>
      get smithCertReceivedAggregate =>
          CopyWith$Input$SmithCertAggregateBoolExp.stub(_res);

  CopyWith$Input$SmithStatusEnumComparisonExp<TRes> get smithStatus =>
      CopyWith$Input$SmithStatusEnumComparisonExp.stub(_res);

  CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> get status =>
      CopyWith$Input$IdentityStatusEnumComparisonExp.stub(_res);

  CopyWith$Input$UdHistoryBoolExp<TRes> get udHistory =>
      CopyWith$Input$UdHistoryBoolExp.stub(_res);
}

class Input$IdentityOrderBy {
  factory Input$IdentityOrderBy({
    Input$AccountOrderBy? account,
    Enum$OrderBy? accountId,
    Input$CertAggregateOrderBy? certIssuedAggregate,
    Input$CertAggregateOrderBy? certReceivedAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? isMember,
    Enum$OrderBy? lastChangeOn,
    Input$AccountAggregateOrderBy? linkedAccountAggregate,
    Input$MembershipEventAggregateOrderBy? membershipHistoryAggregate,
    Enum$OrderBy? name,
    Input$ChangeOwnerKeyAggregateOrderBy? ownerKeyChangeAggregate,
    Input$SmithCertAggregateOrderBy? smithCertIssuedAggregate,
    Input$SmithCertAggregateOrderBy? smithCertReceivedAggregate,
    Enum$OrderBy? smithStatus,
    Enum$OrderBy? status,
    Input$UdHistoryAggregateOrderBy? udHistoryAggregate,
  }) =>
      Input$IdentityOrderBy._({
        if (account != null) r'account': account,
        if (accountId != null) r'accountId': accountId,
        if (certIssuedAggregate != null)
          r'certIssuedAggregate': certIssuedAggregate,
        if (certReceivedAggregate != null)
          r'certReceivedAggregate': certReceivedAggregate,
        if (createdIn != null) r'createdIn': createdIn,
        if (createdInId != null) r'createdInId': createdInId,
        if (createdOn != null) r'createdOn': createdOn,
        if (expireOn != null) r'expireOn': expireOn,
        if (id != null) r'id': id,
        if (index != null) r'index': index,
        if (isMember != null) r'isMember': isMember,
        if (lastChangeOn != null) r'lastChangeOn': lastChangeOn,
        if (linkedAccountAggregate != null)
          r'linkedAccountAggregate': linkedAccountAggregate,
        if (membershipHistoryAggregate != null)
          r'membershipHistoryAggregate': membershipHistoryAggregate,
        if (name != null) r'name': name,
        if (ownerKeyChangeAggregate != null)
          r'ownerKeyChangeAggregate': ownerKeyChangeAggregate,
        if (smithCertIssuedAggregate != null)
          r'smithCertIssuedAggregate': smithCertIssuedAggregate,
        if (smithCertReceivedAggregate != null)
          r'smithCertReceivedAggregate': smithCertReceivedAggregate,
        if (smithStatus != null) r'smithStatus': smithStatus,
        if (status != null) r'status': status,
        if (udHistoryAggregate != null)
          r'udHistoryAggregate': udHistoryAggregate,
      });

  Input$IdentityOrderBy._(this._$data);

  factory Input$IdentityOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('account')) {
      final l$account = data['account'];
      result$data['account'] = l$account == null
          ? null
          : Input$AccountOrderBy.fromJson((l$account as Map<String, dynamic>));
    }
    if (data.containsKey('accountId')) {
      final l$accountId = data['accountId'];
      result$data['accountId'] = l$accountId == null
          ? null
          : fromJson$Enum$OrderBy((l$accountId as String));
    }
    if (data.containsKey('certIssuedAggregate')) {
      final l$certIssuedAggregate = data['certIssuedAggregate'];
      result$data['certIssuedAggregate'] = l$certIssuedAggregate == null
          ? null
          : Input$CertAggregateOrderBy.fromJson(
              (l$certIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('certReceivedAggregate')) {
      final l$certReceivedAggregate = data['certReceivedAggregate'];
      result$data['certReceivedAggregate'] = l$certReceivedAggregate == null
          ? null
          : Input$CertAggregateOrderBy.fromJson(
              (l$certReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('createdIn')) {
      final l$createdIn = data['createdIn'];
      result$data['createdIn'] = l$createdIn == null
          ? null
          : Input$EventOrderBy.fromJson((l$createdIn as Map<String, dynamic>));
    }
    if (data.containsKey('createdInId')) {
      final l$createdInId = data['createdInId'];
      result$data['createdInId'] = l$createdInId == null
          ? null
          : fromJson$Enum$OrderBy((l$createdInId as String));
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('expireOn')) {
      final l$expireOn = data['expireOn'];
      result$data['expireOn'] = l$expireOn == null
          ? null
          : fromJson$Enum$OrderBy((l$expireOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('index')) {
      final l$index = data['index'];
      result$data['index'] =
          l$index == null ? null : fromJson$Enum$OrderBy((l$index as String));
    }
    if (data.containsKey('isMember')) {
      final l$isMember = data['isMember'];
      result$data['isMember'] = l$isMember == null
          ? null
          : fromJson$Enum$OrderBy((l$isMember as String));
    }
    if (data.containsKey('lastChangeOn')) {
      final l$lastChangeOn = data['lastChangeOn'];
      result$data['lastChangeOn'] = l$lastChangeOn == null
          ? null
          : fromJson$Enum$OrderBy((l$lastChangeOn as String));
    }
    if (data.containsKey('linkedAccountAggregate')) {
      final l$linkedAccountAggregate = data['linkedAccountAggregate'];
      result$data['linkedAccountAggregate'] = l$linkedAccountAggregate == null
          ? null
          : Input$AccountAggregateOrderBy.fromJson(
              (l$linkedAccountAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('membershipHistoryAggregate')) {
      final l$membershipHistoryAggregate = data['membershipHistoryAggregate'];
      result$data['membershipHistoryAggregate'] =
          l$membershipHistoryAggregate == null
              ? null
              : Input$MembershipEventAggregateOrderBy.fromJson(
                  (l$membershipHistoryAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$OrderBy((l$name as String));
    }
    if (data.containsKey('ownerKeyChangeAggregate')) {
      final l$ownerKeyChangeAggregate = data['ownerKeyChangeAggregate'];
      result$data['ownerKeyChangeAggregate'] = l$ownerKeyChangeAggregate == null
          ? null
          : Input$ChangeOwnerKeyAggregateOrderBy.fromJson(
              (l$ownerKeyChangeAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertIssuedAggregate')) {
      final l$smithCertIssuedAggregate = data['smithCertIssuedAggregate'];
      result$data['smithCertIssuedAggregate'] =
          l$smithCertIssuedAggregate == null
              ? null
              : Input$SmithCertAggregateOrderBy.fromJson(
                  (l$smithCertIssuedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithCertReceivedAggregate')) {
      final l$smithCertReceivedAggregate = data['smithCertReceivedAggregate'];
      result$data['smithCertReceivedAggregate'] =
          l$smithCertReceivedAggregate == null
              ? null
              : Input$SmithCertAggregateOrderBy.fromJson(
                  (l$smithCertReceivedAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('smithStatus')) {
      final l$smithStatus = data['smithStatus'];
      result$data['smithStatus'] = l$smithStatus == null
          ? null
          : fromJson$Enum$OrderBy((l$smithStatus as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] =
          l$status == null ? null : fromJson$Enum$OrderBy((l$status as String));
    }
    if (data.containsKey('udHistoryAggregate')) {
      final l$udHistoryAggregate = data['udHistoryAggregate'];
      result$data['udHistoryAggregate'] = l$udHistoryAggregate == null
          ? null
          : Input$UdHistoryAggregateOrderBy.fromJson(
              (l$udHistoryAggregate as Map<String, dynamic>));
    }
    return Input$IdentityOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$AccountOrderBy? get account =>
      (_$data['account'] as Input$AccountOrderBy?);

  Enum$OrderBy? get accountId => (_$data['accountId'] as Enum$OrderBy?);

  Input$CertAggregateOrderBy? get certIssuedAggregate =>
      (_$data['certIssuedAggregate'] as Input$CertAggregateOrderBy?);

  Input$CertAggregateOrderBy? get certReceivedAggregate =>
      (_$data['certReceivedAggregate'] as Input$CertAggregateOrderBy?);

  Input$EventOrderBy? get createdIn =>
      (_$data['createdIn'] as Input$EventOrderBy?);

  Enum$OrderBy? get createdInId => (_$data['createdInId'] as Enum$OrderBy?);

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get expireOn => (_$data['expireOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get index => (_$data['index'] as Enum$OrderBy?);

  Enum$OrderBy? get isMember => (_$data['isMember'] as Enum$OrderBy?);

  Enum$OrderBy? get lastChangeOn => (_$data['lastChangeOn'] as Enum$OrderBy?);

  Input$AccountAggregateOrderBy? get linkedAccountAggregate =>
      (_$data['linkedAccountAggregate'] as Input$AccountAggregateOrderBy?);

  Input$MembershipEventAggregateOrderBy? get membershipHistoryAggregate =>
      (_$data['membershipHistoryAggregate']
          as Input$MembershipEventAggregateOrderBy?);

  Enum$OrderBy? get name => (_$data['name'] as Enum$OrderBy?);

  Input$ChangeOwnerKeyAggregateOrderBy? get ownerKeyChangeAggregate =>
      (_$data['ownerKeyChangeAggregate']
          as Input$ChangeOwnerKeyAggregateOrderBy?);

  Input$SmithCertAggregateOrderBy? get smithCertIssuedAggregate =>
      (_$data['smithCertIssuedAggregate'] as Input$SmithCertAggregateOrderBy?);

  Input$SmithCertAggregateOrderBy? get smithCertReceivedAggregate =>
      (_$data['smithCertReceivedAggregate']
          as Input$SmithCertAggregateOrderBy?);

  Enum$OrderBy? get smithStatus => (_$data['smithStatus'] as Enum$OrderBy?);

  Enum$OrderBy? get status => (_$data['status'] as Enum$OrderBy?);

  Input$UdHistoryAggregateOrderBy? get udHistoryAggregate =>
      (_$data['udHistoryAggregate'] as Input$UdHistoryAggregateOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('account')) {
      final l$account = account;
      result$data['account'] = l$account?.toJson();
    }
    if (_$data.containsKey('accountId')) {
      final l$accountId = accountId;
      result$data['accountId'] =
          l$accountId == null ? null : toJson$Enum$OrderBy(l$accountId);
    }
    if (_$data.containsKey('certIssuedAggregate')) {
      final l$certIssuedAggregate = certIssuedAggregate;
      result$data['certIssuedAggregate'] = l$certIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('certReceivedAggregate')) {
      final l$certReceivedAggregate = certReceivedAggregate;
      result$data['certReceivedAggregate'] = l$certReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('createdIn')) {
      final l$createdIn = createdIn;
      result$data['createdIn'] = l$createdIn?.toJson();
    }
    if (_$data.containsKey('createdInId')) {
      final l$createdInId = createdInId;
      result$data['createdInId'] =
          l$createdInId == null ? null : toJson$Enum$OrderBy(l$createdInId);
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('expireOn')) {
      final l$expireOn = expireOn;
      result$data['expireOn'] =
          l$expireOn == null ? null : toJson$Enum$OrderBy(l$expireOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('index')) {
      final l$index = index;
      result$data['index'] =
          l$index == null ? null : toJson$Enum$OrderBy(l$index);
    }
    if (_$data.containsKey('isMember')) {
      final l$isMember = isMember;
      result$data['isMember'] =
          l$isMember == null ? null : toJson$Enum$OrderBy(l$isMember);
    }
    if (_$data.containsKey('lastChangeOn')) {
      final l$lastChangeOn = lastChangeOn;
      result$data['lastChangeOn'] =
          l$lastChangeOn == null ? null : toJson$Enum$OrderBy(l$lastChangeOn);
    }
    if (_$data.containsKey('linkedAccountAggregate')) {
      final l$linkedAccountAggregate = linkedAccountAggregate;
      result$data['linkedAccountAggregate'] =
          l$linkedAccountAggregate?.toJson();
    }
    if (_$data.containsKey('membershipHistoryAggregate')) {
      final l$membershipHistoryAggregate = membershipHistoryAggregate;
      result$data['membershipHistoryAggregate'] =
          l$membershipHistoryAggregate?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$Enum$OrderBy(l$name);
    }
    if (_$data.containsKey('ownerKeyChangeAggregate')) {
      final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
      result$data['ownerKeyChangeAggregate'] =
          l$ownerKeyChangeAggregate?.toJson();
    }
    if (_$data.containsKey('smithCertIssuedAggregate')) {
      final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
      result$data['smithCertIssuedAggregate'] =
          l$smithCertIssuedAggregate?.toJson();
    }
    if (_$data.containsKey('smithCertReceivedAggregate')) {
      final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
      result$data['smithCertReceivedAggregate'] =
          l$smithCertReceivedAggregate?.toJson();
    }
    if (_$data.containsKey('smithStatus')) {
      final l$smithStatus = smithStatus;
      result$data['smithStatus'] =
          l$smithStatus == null ? null : toJson$Enum$OrderBy(l$smithStatus);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$OrderBy(l$status);
    }
    if (_$data.containsKey('udHistoryAggregate')) {
      final l$udHistoryAggregate = udHistoryAggregate;
      result$data['udHistoryAggregate'] = l$udHistoryAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IdentityOrderBy<Input$IdentityOrderBy> get copyWith =>
      CopyWith$Input$IdentityOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IdentityOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$account = account;
    final lOther$account = other.account;
    if (_$data.containsKey('account') != other._$data.containsKey('account')) {
      return false;
    }
    if (l$account != lOther$account) {
      return false;
    }
    final l$accountId = accountId;
    final lOther$accountId = other.accountId;
    if (_$data.containsKey('accountId') !=
        other._$data.containsKey('accountId')) {
      return false;
    }
    if (l$accountId != lOther$accountId) {
      return false;
    }
    final l$certIssuedAggregate = certIssuedAggregate;
    final lOther$certIssuedAggregate = other.certIssuedAggregate;
    if (_$data.containsKey('certIssuedAggregate') !=
        other._$data.containsKey('certIssuedAggregate')) {
      return false;
    }
    if (l$certIssuedAggregate != lOther$certIssuedAggregate) {
      return false;
    }
    final l$certReceivedAggregate = certReceivedAggregate;
    final lOther$certReceivedAggregate = other.certReceivedAggregate;
    if (_$data.containsKey('certReceivedAggregate') !=
        other._$data.containsKey('certReceivedAggregate')) {
      return false;
    }
    if (l$certReceivedAggregate != lOther$certReceivedAggregate) {
      return false;
    }
    final l$createdIn = createdIn;
    final lOther$createdIn = other.createdIn;
    if (_$data.containsKey('createdIn') !=
        other._$data.containsKey('createdIn')) {
      return false;
    }
    if (l$createdIn != lOther$createdIn) {
      return false;
    }
    final l$createdInId = createdInId;
    final lOther$createdInId = other.createdInId;
    if (_$data.containsKey('createdInId') !=
        other._$data.containsKey('createdInId')) {
      return false;
    }
    if (l$createdInId != lOther$createdInId) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$expireOn = expireOn;
    final lOther$expireOn = other.expireOn;
    if (_$data.containsKey('expireOn') !=
        other._$data.containsKey('expireOn')) {
      return false;
    }
    if (l$expireOn != lOther$expireOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$index = index;
    final lOther$index = other.index;
    if (_$data.containsKey('index') != other._$data.containsKey('index')) {
      return false;
    }
    if (l$index != lOther$index) {
      return false;
    }
    final l$isMember = isMember;
    final lOther$isMember = other.isMember;
    if (_$data.containsKey('isMember') !=
        other._$data.containsKey('isMember')) {
      return false;
    }
    if (l$isMember != lOther$isMember) {
      return false;
    }
    final l$lastChangeOn = lastChangeOn;
    final lOther$lastChangeOn = other.lastChangeOn;
    if (_$data.containsKey('lastChangeOn') !=
        other._$data.containsKey('lastChangeOn')) {
      return false;
    }
    if (l$lastChangeOn != lOther$lastChangeOn) {
      return false;
    }
    final l$linkedAccountAggregate = linkedAccountAggregate;
    final lOther$linkedAccountAggregate = other.linkedAccountAggregate;
    if (_$data.containsKey('linkedAccountAggregate') !=
        other._$data.containsKey('linkedAccountAggregate')) {
      return false;
    }
    if (l$linkedAccountAggregate != lOther$linkedAccountAggregate) {
      return false;
    }
    final l$membershipHistoryAggregate = membershipHistoryAggregate;
    final lOther$membershipHistoryAggregate = other.membershipHistoryAggregate;
    if (_$data.containsKey('membershipHistoryAggregate') !=
        other._$data.containsKey('membershipHistoryAggregate')) {
      return false;
    }
    if (l$membershipHistoryAggregate != lOther$membershipHistoryAggregate) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
    final lOther$ownerKeyChangeAggregate = other.ownerKeyChangeAggregate;
    if (_$data.containsKey('ownerKeyChangeAggregate') !=
        other._$data.containsKey('ownerKeyChangeAggregate')) {
      return false;
    }
    if (l$ownerKeyChangeAggregate != lOther$ownerKeyChangeAggregate) {
      return false;
    }
    final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
    final lOther$smithCertIssuedAggregate = other.smithCertIssuedAggregate;
    if (_$data.containsKey('smithCertIssuedAggregate') !=
        other._$data.containsKey('smithCertIssuedAggregate')) {
      return false;
    }
    if (l$smithCertIssuedAggregate != lOther$smithCertIssuedAggregate) {
      return false;
    }
    final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
    final lOther$smithCertReceivedAggregate = other.smithCertReceivedAggregate;
    if (_$data.containsKey('smithCertReceivedAggregate') !=
        other._$data.containsKey('smithCertReceivedAggregate')) {
      return false;
    }
    if (l$smithCertReceivedAggregate != lOther$smithCertReceivedAggregate) {
      return false;
    }
    final l$smithStatus = smithStatus;
    final lOther$smithStatus = other.smithStatus;
    if (_$data.containsKey('smithStatus') !=
        other._$data.containsKey('smithStatus')) {
      return false;
    }
    if (l$smithStatus != lOther$smithStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$udHistoryAggregate = udHistoryAggregate;
    final lOther$udHistoryAggregate = other.udHistoryAggregate;
    if (_$data.containsKey('udHistoryAggregate') !=
        other._$data.containsKey('udHistoryAggregate')) {
      return false;
    }
    if (l$udHistoryAggregate != lOther$udHistoryAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$account = account;
    final l$accountId = accountId;
    final l$certIssuedAggregate = certIssuedAggregate;
    final l$certReceivedAggregate = certReceivedAggregate;
    final l$createdIn = createdIn;
    final l$createdInId = createdInId;
    final l$createdOn = createdOn;
    final l$expireOn = expireOn;
    final l$id = id;
    final l$index = index;
    final l$isMember = isMember;
    final l$lastChangeOn = lastChangeOn;
    final l$linkedAccountAggregate = linkedAccountAggregate;
    final l$membershipHistoryAggregate = membershipHistoryAggregate;
    final l$name = name;
    final l$ownerKeyChangeAggregate = ownerKeyChangeAggregate;
    final l$smithCertIssuedAggregate = smithCertIssuedAggregate;
    final l$smithCertReceivedAggregate = smithCertReceivedAggregate;
    final l$smithStatus = smithStatus;
    final l$status = status;
    final l$udHistoryAggregate = udHistoryAggregate;
    return Object.hashAll([
      _$data.containsKey('account') ? l$account : const {},
      _$data.containsKey('accountId') ? l$accountId : const {},
      _$data.containsKey('certIssuedAggregate')
          ? l$certIssuedAggregate
          : const {},
      _$data.containsKey('certReceivedAggregate')
          ? l$certReceivedAggregate
          : const {},
      _$data.containsKey('createdIn') ? l$createdIn : const {},
      _$data.containsKey('createdInId') ? l$createdInId : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('expireOn') ? l$expireOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('index') ? l$index : const {},
      _$data.containsKey('isMember') ? l$isMember : const {},
      _$data.containsKey('lastChangeOn') ? l$lastChangeOn : const {},
      _$data.containsKey('linkedAccountAggregate')
          ? l$linkedAccountAggregate
          : const {},
      _$data.containsKey('membershipHistoryAggregate')
          ? l$membershipHistoryAggregate
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('ownerKeyChangeAggregate')
          ? l$ownerKeyChangeAggregate
          : const {},
      _$data.containsKey('smithCertIssuedAggregate')
          ? l$smithCertIssuedAggregate
          : const {},
      _$data.containsKey('smithCertReceivedAggregate')
          ? l$smithCertReceivedAggregate
          : const {},
      _$data.containsKey('smithStatus') ? l$smithStatus : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('udHistoryAggregate')
          ? l$udHistoryAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityOrderBy<TRes> {
  factory CopyWith$Input$IdentityOrderBy(
    Input$IdentityOrderBy instance,
    TRes Function(Input$IdentityOrderBy) then,
  ) = _CopyWithImpl$Input$IdentityOrderBy;

  factory CopyWith$Input$IdentityOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityOrderBy;

  TRes call({
    Input$AccountOrderBy? account,
    Enum$OrderBy? accountId,
    Input$CertAggregateOrderBy? certIssuedAggregate,
    Input$CertAggregateOrderBy? certReceivedAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? isMember,
    Enum$OrderBy? lastChangeOn,
    Input$AccountAggregateOrderBy? linkedAccountAggregate,
    Input$MembershipEventAggregateOrderBy? membershipHistoryAggregate,
    Enum$OrderBy? name,
    Input$ChangeOwnerKeyAggregateOrderBy? ownerKeyChangeAggregate,
    Input$SmithCertAggregateOrderBy? smithCertIssuedAggregate,
    Input$SmithCertAggregateOrderBy? smithCertReceivedAggregate,
    Enum$OrderBy? smithStatus,
    Enum$OrderBy? status,
    Input$UdHistoryAggregateOrderBy? udHistoryAggregate,
  });
  CopyWith$Input$AccountOrderBy<TRes> get account;
  CopyWith$Input$CertAggregateOrderBy<TRes> get certIssuedAggregate;
  CopyWith$Input$CertAggregateOrderBy<TRes> get certReceivedAggregate;
  CopyWith$Input$EventOrderBy<TRes> get createdIn;
  CopyWith$Input$AccountAggregateOrderBy<TRes> get linkedAccountAggregate;
  CopyWith$Input$MembershipEventAggregateOrderBy<TRes>
      get membershipHistoryAggregate;
  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
      get ownerKeyChangeAggregate;
  CopyWith$Input$SmithCertAggregateOrderBy<TRes> get smithCertIssuedAggregate;
  CopyWith$Input$SmithCertAggregateOrderBy<TRes> get smithCertReceivedAggregate;
  CopyWith$Input$UdHistoryAggregateOrderBy<TRes> get udHistoryAggregate;
}

class _CopyWithImpl$Input$IdentityOrderBy<TRes>
    implements CopyWith$Input$IdentityOrderBy<TRes> {
  _CopyWithImpl$Input$IdentityOrderBy(
    this._instance,
    this._then,
  );

  final Input$IdentityOrderBy _instance;

  final TRes Function(Input$IdentityOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? account = _undefined,
    Object? accountId = _undefined,
    Object? certIssuedAggregate = _undefined,
    Object? certReceivedAggregate = _undefined,
    Object? createdIn = _undefined,
    Object? createdInId = _undefined,
    Object? createdOn = _undefined,
    Object? expireOn = _undefined,
    Object? id = _undefined,
    Object? index = _undefined,
    Object? isMember = _undefined,
    Object? lastChangeOn = _undefined,
    Object? linkedAccountAggregate = _undefined,
    Object? membershipHistoryAggregate = _undefined,
    Object? name = _undefined,
    Object? ownerKeyChangeAggregate = _undefined,
    Object? smithCertIssuedAggregate = _undefined,
    Object? smithCertReceivedAggregate = _undefined,
    Object? smithStatus = _undefined,
    Object? status = _undefined,
    Object? udHistoryAggregate = _undefined,
  }) =>
      _then(Input$IdentityOrderBy._({
        ..._instance._$data,
        if (account != _undefined)
          'account': (account as Input$AccountOrderBy?),
        if (accountId != _undefined) 'accountId': (accountId as Enum$OrderBy?),
        if (certIssuedAggregate != _undefined)
          'certIssuedAggregate':
              (certIssuedAggregate as Input$CertAggregateOrderBy?),
        if (certReceivedAggregate != _undefined)
          'certReceivedAggregate':
              (certReceivedAggregate as Input$CertAggregateOrderBy?),
        if (createdIn != _undefined)
          'createdIn': (createdIn as Input$EventOrderBy?),
        if (createdInId != _undefined)
          'createdInId': (createdInId as Enum$OrderBy?),
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (expireOn != _undefined) 'expireOn': (expireOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (index != _undefined) 'index': (index as Enum$OrderBy?),
        if (isMember != _undefined) 'isMember': (isMember as Enum$OrderBy?),
        if (lastChangeOn != _undefined)
          'lastChangeOn': (lastChangeOn as Enum$OrderBy?),
        if (linkedAccountAggregate != _undefined)
          'linkedAccountAggregate':
              (linkedAccountAggregate as Input$AccountAggregateOrderBy?),
        if (membershipHistoryAggregate != _undefined)
          'membershipHistoryAggregate': (membershipHistoryAggregate
              as Input$MembershipEventAggregateOrderBy?),
        if (name != _undefined) 'name': (name as Enum$OrderBy?),
        if (ownerKeyChangeAggregate != _undefined)
          'ownerKeyChangeAggregate': (ownerKeyChangeAggregate
              as Input$ChangeOwnerKeyAggregateOrderBy?),
        if (smithCertIssuedAggregate != _undefined)
          'smithCertIssuedAggregate':
              (smithCertIssuedAggregate as Input$SmithCertAggregateOrderBy?),
        if (smithCertReceivedAggregate != _undefined)
          'smithCertReceivedAggregate':
              (smithCertReceivedAggregate as Input$SmithCertAggregateOrderBy?),
        if (smithStatus != _undefined)
          'smithStatus': (smithStatus as Enum$OrderBy?),
        if (status != _undefined) 'status': (status as Enum$OrderBy?),
        if (udHistoryAggregate != _undefined)
          'udHistoryAggregate':
              (udHistoryAggregate as Input$UdHistoryAggregateOrderBy?),
      }));

  CopyWith$Input$AccountOrderBy<TRes> get account {
    final local$account = _instance.account;
    return local$account == null
        ? CopyWith$Input$AccountOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountOrderBy(local$account, (e) => call(account: e));
  }

  CopyWith$Input$CertAggregateOrderBy<TRes> get certIssuedAggregate {
    final local$certIssuedAggregate = _instance.certIssuedAggregate;
    return local$certIssuedAggregate == null
        ? CopyWith$Input$CertAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertAggregateOrderBy(
            local$certIssuedAggregate, (e) => call(certIssuedAggregate: e));
  }

  CopyWith$Input$CertAggregateOrderBy<TRes> get certReceivedAggregate {
    final local$certReceivedAggregate = _instance.certReceivedAggregate;
    return local$certReceivedAggregate == null
        ? CopyWith$Input$CertAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$CertAggregateOrderBy(
            local$certReceivedAggregate, (e) => call(certReceivedAggregate: e));
  }

  CopyWith$Input$EventOrderBy<TRes> get createdIn {
    final local$createdIn = _instance.createdIn;
    return local$createdIn == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(
            local$createdIn, (e) => call(createdIn: e));
  }

  CopyWith$Input$AccountAggregateOrderBy<TRes> get linkedAccountAggregate {
    final local$linkedAccountAggregate = _instance.linkedAccountAggregate;
    return local$linkedAccountAggregate == null
        ? CopyWith$Input$AccountAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountAggregateOrderBy(local$linkedAccountAggregate,
            (e) => call(linkedAccountAggregate: e));
  }

  CopyWith$Input$MembershipEventAggregateOrderBy<TRes>
      get membershipHistoryAggregate {
    final local$membershipHistoryAggregate =
        _instance.membershipHistoryAggregate;
    return local$membershipHistoryAggregate == null
        ? CopyWith$Input$MembershipEventAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventAggregateOrderBy(
            local$membershipHistoryAggregate,
            (e) => call(membershipHistoryAggregate: e));
  }

  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
      get ownerKeyChangeAggregate {
    final local$ownerKeyChangeAggregate = _instance.ownerKeyChangeAggregate;
    return local$ownerKeyChangeAggregate == null
        ? CopyWith$Input$ChangeOwnerKeyAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$ChangeOwnerKeyAggregateOrderBy(
            local$ownerKeyChangeAggregate,
            (e) => call(ownerKeyChangeAggregate: e));
  }

  CopyWith$Input$SmithCertAggregateOrderBy<TRes> get smithCertIssuedAggregate {
    final local$smithCertIssuedAggregate = _instance.smithCertIssuedAggregate;
    return local$smithCertIssuedAggregate == null
        ? CopyWith$Input$SmithCertAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertAggregateOrderBy(
            local$smithCertIssuedAggregate,
            (e) => call(smithCertIssuedAggregate: e));
  }

  CopyWith$Input$SmithCertAggregateOrderBy<TRes>
      get smithCertReceivedAggregate {
    final local$smithCertReceivedAggregate =
        _instance.smithCertReceivedAggregate;
    return local$smithCertReceivedAggregate == null
        ? CopyWith$Input$SmithCertAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertAggregateOrderBy(
            local$smithCertReceivedAggregate,
            (e) => call(smithCertReceivedAggregate: e));
  }

  CopyWith$Input$UdHistoryAggregateOrderBy<TRes> get udHistoryAggregate {
    final local$udHistoryAggregate = _instance.udHistoryAggregate;
    return local$udHistoryAggregate == null
        ? CopyWith$Input$UdHistoryAggregateOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryAggregateOrderBy(
            local$udHistoryAggregate, (e) => call(udHistoryAggregate: e));
  }
}

class _CopyWithStubImpl$Input$IdentityOrderBy<TRes>
    implements CopyWith$Input$IdentityOrderBy<TRes> {
  _CopyWithStubImpl$Input$IdentityOrderBy(this._res);

  TRes _res;

  call({
    Input$AccountOrderBy? account,
    Enum$OrderBy? accountId,
    Input$CertAggregateOrderBy? certIssuedAggregate,
    Input$CertAggregateOrderBy? certReceivedAggregate,
    Input$EventOrderBy? createdIn,
    Enum$OrderBy? createdInId,
    Enum$OrderBy? createdOn,
    Enum$OrderBy? expireOn,
    Enum$OrderBy? id,
    Enum$OrderBy? index,
    Enum$OrderBy? isMember,
    Enum$OrderBy? lastChangeOn,
    Input$AccountAggregateOrderBy? linkedAccountAggregate,
    Input$MembershipEventAggregateOrderBy? membershipHistoryAggregate,
    Enum$OrderBy? name,
    Input$ChangeOwnerKeyAggregateOrderBy? ownerKeyChangeAggregate,
    Input$SmithCertAggregateOrderBy? smithCertIssuedAggregate,
    Input$SmithCertAggregateOrderBy? smithCertReceivedAggregate,
    Enum$OrderBy? smithStatus,
    Enum$OrderBy? status,
    Input$UdHistoryAggregateOrderBy? udHistoryAggregate,
  }) =>
      _res;

  CopyWith$Input$AccountOrderBy<TRes> get account =>
      CopyWith$Input$AccountOrderBy.stub(_res);

  CopyWith$Input$CertAggregateOrderBy<TRes> get certIssuedAggregate =>
      CopyWith$Input$CertAggregateOrderBy.stub(_res);

  CopyWith$Input$CertAggregateOrderBy<TRes> get certReceivedAggregate =>
      CopyWith$Input$CertAggregateOrderBy.stub(_res);

  CopyWith$Input$EventOrderBy<TRes> get createdIn =>
      CopyWith$Input$EventOrderBy.stub(_res);

  CopyWith$Input$AccountAggregateOrderBy<TRes> get linkedAccountAggregate =>
      CopyWith$Input$AccountAggregateOrderBy.stub(_res);

  CopyWith$Input$MembershipEventAggregateOrderBy<TRes>
      get membershipHistoryAggregate =>
          CopyWith$Input$MembershipEventAggregateOrderBy.stub(_res);

  CopyWith$Input$ChangeOwnerKeyAggregateOrderBy<TRes>
      get ownerKeyChangeAggregate =>
          CopyWith$Input$ChangeOwnerKeyAggregateOrderBy.stub(_res);

  CopyWith$Input$SmithCertAggregateOrderBy<TRes> get smithCertIssuedAggregate =>
      CopyWith$Input$SmithCertAggregateOrderBy.stub(_res);

  CopyWith$Input$SmithCertAggregateOrderBy<TRes>
      get smithCertReceivedAggregate =>
          CopyWith$Input$SmithCertAggregateOrderBy.stub(_res);

  CopyWith$Input$UdHistoryAggregateOrderBy<TRes> get udHistoryAggregate =>
      CopyWith$Input$UdHistoryAggregateOrderBy.stub(_res);
}

class Input$IdentityStatusEnumComparisonExp {
  factory Input$IdentityStatusEnumComparisonExp({
    Enum$IdentityStatusEnum? $_eq,
    List<Enum$IdentityStatusEnum>? $_in,
    bool? $_isNull,
    Enum$IdentityStatusEnum? $_neq,
    List<Enum$IdentityStatusEnum>? $_nin,
  }) =>
      Input$IdentityStatusEnumComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$IdentityStatusEnumComparisonExp._(this._$data);

  factory Input$IdentityStatusEnumComparisonExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = l$$_eq == null
          ? null
          : fromJson$Enum$IdentityStatusEnum((l$$_eq as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IdentityStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromJson$Enum$IdentityStatusEnum((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IdentityStatusEnum((e as String)))
          .toList();
    }
    return Input$IdentityStatusEnumComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IdentityStatusEnum? get $_eq =>
      (_$data['_eq'] as Enum$IdentityStatusEnum?);

  List<Enum$IdentityStatusEnum>? get $_in =>
      (_$data['_in'] as List<Enum$IdentityStatusEnum>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Enum$IdentityStatusEnum? get $_neq =>
      (_$data['_neq'] as Enum$IdentityStatusEnum?);

  List<Enum$IdentityStatusEnum>? get $_nin =>
      (_$data['_nin'] as List<Enum$IdentityStatusEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : toJson$Enum$IdentityStatusEnum(l$$_eq);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => toJson$Enum$IdentityStatusEnum(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] =
          l$$_neq == null ? null : toJson$Enum$IdentityStatusEnum(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => toJson$Enum$IdentityStatusEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$IdentityStatusEnumComparisonExp<
          Input$IdentityStatusEnumComparisonExp>
      get copyWith => CopyWith$Input$IdentityStatusEnumComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IdentityStatusEnumComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> {
  factory CopyWith$Input$IdentityStatusEnumComparisonExp(
    Input$IdentityStatusEnumComparisonExp instance,
    TRes Function(Input$IdentityStatusEnumComparisonExp) then,
  ) = _CopyWithImpl$Input$IdentityStatusEnumComparisonExp;

  factory CopyWith$Input$IdentityStatusEnumComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityStatusEnumComparisonExp;

  TRes call({
    Enum$IdentityStatusEnum? $_eq,
    List<Enum$IdentityStatusEnum>? $_in,
    bool? $_isNull,
    Enum$IdentityStatusEnum? $_neq,
    List<Enum$IdentityStatusEnum>? $_nin,
  });
}

class _CopyWithImpl$Input$IdentityStatusEnumComparisonExp<TRes>
    implements CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> {
  _CopyWithImpl$Input$IdentityStatusEnumComparisonExp(
    this._instance,
    this._then,
  );

  final Input$IdentityStatusEnumComparisonExp _instance;

  final TRes Function(Input$IdentityStatusEnumComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$IdentityStatusEnumComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Enum$IdentityStatusEnum?),
        if ($_in != _undefined) '_in': ($_in as List<Enum$IdentityStatusEnum>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as Enum$IdentityStatusEnum?),
        if ($_nin != _undefined)
          '_nin': ($_nin as List<Enum$IdentityStatusEnum>?),
      }));
}

class _CopyWithStubImpl$Input$IdentityStatusEnumComparisonExp<TRes>
    implements CopyWith$Input$IdentityStatusEnumComparisonExp<TRes> {
  _CopyWithStubImpl$Input$IdentityStatusEnumComparisonExp(this._res);

  TRes _res;

  call({
    Enum$IdentityStatusEnum? $_eq,
    List<Enum$IdentityStatusEnum>? $_in,
    bool? $_isNull,
    Enum$IdentityStatusEnum? $_neq,
    List<Enum$IdentityStatusEnum>? $_nin,
  }) =>
      _res;
}

class Input$IntArrayComparisonExp {
  factory Input$IntArrayComparisonExp({
    List<int>? $_containedIn,
    List<int>? $_contains,
    List<int>? $_eq,
    List<int>? $_gt,
    List<int>? $_gte,
    List<List<int>>? $_in,
    bool? $_isNull,
    List<int>? $_lt,
    List<int>? $_lte,
    List<int>? $_neq,
    List<List<int>>? $_nin,
  }) =>
      Input$IntArrayComparisonExp._({
        if ($_containedIn != null) r'_containedIn': $_containedIn,
        if ($_contains != null) r'_contains': $_contains,
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$IntArrayComparisonExp._(this._$data);

  factory Input$IntArrayComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_containedIn')) {
      final l$$_containedIn = data['_containedIn'];
      result$data['_containedIn'] =
          (l$$_containedIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_contains')) {
      final l$$_contains = data['_contains'];
      result$data['_contains'] =
          (l$$_contains as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] =
          (l$$_eq as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] =
          (l$$_gt as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] =
          (l$$_gte as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => (e as List<dynamic>).map((e) => (e as int)).toList())
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] =
          (l$$_lt as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] =
          (l$$_lte as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] =
          (l$$_neq as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => (e as List<dynamic>).map((e) => (e as int)).toList())
          .toList();
    }
    return Input$IntArrayComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<int>? get $_containedIn => (_$data['_containedIn'] as List<int>?);

  List<int>? get $_contains => (_$data['_contains'] as List<int>?);

  List<int>? get $_eq => (_$data['_eq'] as List<int>?);

  List<int>? get $_gt => (_$data['_gt'] as List<int>?);

  List<int>? get $_gte => (_$data['_gte'] as List<int>?);

  List<List<int>>? get $_in => (_$data['_in'] as List<List<int>>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  List<int>? get $_lt => (_$data['_lt'] as List<int>?);

  List<int>? get $_lte => (_$data['_lte'] as List<int>?);

  List<int>? get $_neq => (_$data['_neq'] as List<int>?);

  List<List<int>>? get $_nin => (_$data['_nin'] as List<List<int>>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_containedIn')) {
      final l$$_containedIn = $_containedIn;
      result$data['_containedIn'] = l$$_containedIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('_contains')) {
      final l$$_contains = $_contains;
      result$data['_contains'] = l$$_contains?.map((e) => e).toList();
    }
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq?.map((e) => e).toList();
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt?.map((e) => e).toList();
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte?.map((e) => e).toList();
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => e.map((e) => e).toList()).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt?.map((e) => e).toList();
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte?.map((e) => e).toList();
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq?.map((e) => e).toList();
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => e.map((e) => e).toList()).toList();
    }
    return result$data;
  }

  CopyWith$Input$IntArrayComparisonExp<Input$IntArrayComparisonExp>
      get copyWith => CopyWith$Input$IntArrayComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntArrayComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_containedIn = $_containedIn;
    final lOther$$_containedIn = other.$_containedIn;
    if (_$data.containsKey('_containedIn') !=
        other._$data.containsKey('_containedIn')) {
      return false;
    }
    if (l$$_containedIn != null && lOther$$_containedIn != null) {
      if (l$$_containedIn.length != lOther$$_containedIn.length) {
        return false;
      }
      for (int i = 0; i < l$$_containedIn.length; i++) {
        final l$$_containedIn$entry = l$$_containedIn[i];
        final lOther$$_containedIn$entry = lOther$$_containedIn[i];
        if (l$$_containedIn$entry != lOther$$_containedIn$entry) {
          return false;
        }
      }
    } else if (l$$_containedIn != lOther$$_containedIn) {
      return false;
    }
    final l$$_contains = $_contains;
    final lOther$$_contains = other.$_contains;
    if (_$data.containsKey('_contains') !=
        other._$data.containsKey('_contains')) {
      return false;
    }
    if (l$$_contains != null && lOther$$_contains != null) {
      if (l$$_contains.length != lOther$$_contains.length) {
        return false;
      }
      for (int i = 0; i < l$$_contains.length; i++) {
        final l$$_contains$entry = l$$_contains[i];
        final lOther$$_contains$entry = lOther$$_contains[i];
        if (l$$_contains$entry != lOther$$_contains$entry) {
          return false;
        }
      }
    } else if (l$$_contains != lOther$$_contains) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != null && lOther$$_eq != null) {
      if (l$$_eq.length != lOther$$_eq.length) {
        return false;
      }
      for (int i = 0; i < l$$_eq.length; i++) {
        final l$$_eq$entry = l$$_eq[i];
        final lOther$$_eq$entry = lOther$$_eq[i];
        if (l$$_eq$entry != lOther$$_eq$entry) {
          return false;
        }
      }
    } else if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != null && lOther$$_gt != null) {
      if (l$$_gt.length != lOther$$_gt.length) {
        return false;
      }
      for (int i = 0; i < l$$_gt.length; i++) {
        final l$$_gt$entry = l$$_gt[i];
        final lOther$$_gt$entry = lOther$$_gt[i];
        if (l$$_gt$entry != lOther$$_gt$entry) {
          return false;
        }
      }
    } else if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != null && lOther$$_gte != null) {
      if (l$$_gte.length != lOther$$_gte.length) {
        return false;
      }
      for (int i = 0; i < l$$_gte.length; i++) {
        final l$$_gte$entry = l$$_gte[i];
        final lOther$$_gte$entry = lOther$$_gte[i];
        if (l$$_gte$entry != lOther$$_gte$entry) {
          return false;
        }
      }
    } else if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry.length != lOther$$_in$entry.length) {
          return false;
        }
        for (int i = 0; i < l$$_in$entry.length; i++) {
          final l$$_in$entry$entry = l$$_in$entry[i];
          final lOther$$_in$entry$entry = lOther$$_in$entry[i];
          if (l$$_in$entry$entry != lOther$$_in$entry$entry) {
            return false;
          }
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != null && lOther$$_lt != null) {
      if (l$$_lt.length != lOther$$_lt.length) {
        return false;
      }
      for (int i = 0; i < l$$_lt.length; i++) {
        final l$$_lt$entry = l$$_lt[i];
        final lOther$$_lt$entry = lOther$$_lt[i];
        if (l$$_lt$entry != lOther$$_lt$entry) {
          return false;
        }
      }
    } else if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != null && lOther$$_lte != null) {
      if (l$$_lte.length != lOther$$_lte.length) {
        return false;
      }
      for (int i = 0; i < l$$_lte.length; i++) {
        final l$$_lte$entry = l$$_lte[i];
        final lOther$$_lte$entry = lOther$$_lte[i];
        if (l$$_lte$entry != lOther$$_lte$entry) {
          return false;
        }
      }
    } else if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != null && lOther$$_neq != null) {
      if (l$$_neq.length != lOther$$_neq.length) {
        return false;
      }
      for (int i = 0; i < l$$_neq.length; i++) {
        final l$$_neq$entry = l$$_neq[i];
        final lOther$$_neq$entry = lOther$$_neq[i];
        if (l$$_neq$entry != lOther$$_neq$entry) {
          return false;
        }
      }
    } else if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry.length != lOther$$_nin$entry.length) {
          return false;
        }
        for (int i = 0; i < l$$_nin$entry.length; i++) {
          final l$$_nin$entry$entry = l$$_nin$entry[i];
          final lOther$$_nin$entry$entry = lOther$$_nin$entry[i];
          if (l$$_nin$entry$entry != lOther$$_nin$entry$entry) {
            return false;
          }
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_containedIn = $_containedIn;
    final l$$_contains = $_contains;
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_containedIn')
          ? l$$_containedIn == null
              ? null
              : Object.hashAll(l$$_containedIn.map((v) => v))
          : const {},
      _$data.containsKey('_contains')
          ? l$$_contains == null
              ? null
              : Object.hashAll(l$$_contains.map((v) => v))
          : const {},
      _$data.containsKey('_eq')
          ? l$$_eq == null
              ? null
              : Object.hashAll(l$$_eq.map((v) => v))
          : const {},
      _$data.containsKey('_gt')
          ? l$$_gt == null
              ? null
              : Object.hashAll(l$$_gt.map((v) => v))
          : const {},
      _$data.containsKey('_gte')
          ? l$$_gte == null
              ? null
              : Object.hashAll(l$$_gte.map((v) => v))
          : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(
                  l$$_in.map((v) => Object.hashAll(v.map((v) => v))))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt')
          ? l$$_lt == null
              ? null
              : Object.hashAll(l$$_lt.map((v) => v))
          : const {},
      _$data.containsKey('_lte')
          ? l$$_lte == null
              ? null
              : Object.hashAll(l$$_lte.map((v) => v))
          : const {},
      _$data.containsKey('_neq')
          ? l$$_neq == null
              ? null
              : Object.hashAll(l$$_neq.map((v) => v))
          : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(
                  l$$_nin.map((v) => Object.hashAll(v.map((v) => v))))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntArrayComparisonExp<TRes> {
  factory CopyWith$Input$IntArrayComparisonExp(
    Input$IntArrayComparisonExp instance,
    TRes Function(Input$IntArrayComparisonExp) then,
  ) = _CopyWithImpl$Input$IntArrayComparisonExp;

  factory CopyWith$Input$IntArrayComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$IntArrayComparisonExp;

  TRes call({
    List<int>? $_containedIn,
    List<int>? $_contains,
    List<int>? $_eq,
    List<int>? $_gt,
    List<int>? $_gte,
    List<List<int>>? $_in,
    bool? $_isNull,
    List<int>? $_lt,
    List<int>? $_lte,
    List<int>? $_neq,
    List<List<int>>? $_nin,
  });
}

class _CopyWithImpl$Input$IntArrayComparisonExp<TRes>
    implements CopyWith$Input$IntArrayComparisonExp<TRes> {
  _CopyWithImpl$Input$IntArrayComparisonExp(
    this._instance,
    this._then,
  );

  final Input$IntArrayComparisonExp _instance;

  final TRes Function(Input$IntArrayComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_containedIn = _undefined,
    Object? $_contains = _undefined,
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$IntArrayComparisonExp._({
        ..._instance._$data,
        if ($_containedIn != _undefined)
          '_containedIn': ($_containedIn as List<int>?),
        if ($_contains != _undefined) '_contains': ($_contains as List<int>?),
        if ($_eq != _undefined) '_eq': ($_eq as List<int>?),
        if ($_gt != _undefined) '_gt': ($_gt as List<int>?),
        if ($_gte != _undefined) '_gte': ($_gte as List<int>?),
        if ($_in != _undefined) '_in': ($_in as List<List<int>>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as List<int>?),
        if ($_lte != _undefined) '_lte': ($_lte as List<int>?),
        if ($_neq != _undefined) '_neq': ($_neq as List<int>?),
        if ($_nin != _undefined) '_nin': ($_nin as List<List<int>>?),
      }));
}

class _CopyWithStubImpl$Input$IntArrayComparisonExp<TRes>
    implements CopyWith$Input$IntArrayComparisonExp<TRes> {
  _CopyWithStubImpl$Input$IntArrayComparisonExp(this._res);

  TRes _res;

  call({
    List<int>? $_containedIn,
    List<int>? $_contains,
    List<int>? $_eq,
    List<int>? $_gt,
    List<int>? $_gte,
    List<List<int>>? $_in,
    bool? $_isNull,
    List<int>? $_lt,
    List<int>? $_lte,
    List<int>? $_neq,
    List<List<int>>? $_nin,
  }) =>
      _res;
}

class Input$IntComparisonExp {
  factory Input$IntComparisonExp({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      Input$IntComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$IntComparisonExp._(this._$data);

  factory Input$IntComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as int?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as int?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as int?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as int?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as int?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as int?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$IntComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $_eq => (_$data['_eq'] as int?);

  int? get $_gt => (_$data['_gt'] as int?);

  int? get $_gte => (_$data['_gte'] as int?);

  List<int>? get $_in => (_$data['_in'] as List<int>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  int? get $_lt => (_$data['_lt'] as int?);

  int? get $_lte => (_$data['_lte'] as int?);

  int? get $_neq => (_$data['_neq'] as int?);

  List<int>? get $_nin => (_$data['_nin'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$IntComparisonExp<Input$IntComparisonExp> get copyWith =>
      CopyWith$Input$IntComparisonExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntComparisonExp<TRes> {
  factory CopyWith$Input$IntComparisonExp(
    Input$IntComparisonExp instance,
    TRes Function(Input$IntComparisonExp) then,
  ) = _CopyWithImpl$Input$IntComparisonExp;

  factory CopyWith$Input$IntComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$IntComparisonExp;

  TRes call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  });
}

class _CopyWithImpl$Input$IntComparisonExp<TRes>
    implements CopyWith$Input$IntComparisonExp<TRes> {
  _CopyWithImpl$Input$IntComparisonExp(
    this._instance,
    this._then,
  );

  final Input$IntComparisonExp _instance;

  final TRes Function(Input$IntComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$IntComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as int?),
        if ($_gt != _undefined) '_gt': ($_gt as int?),
        if ($_gte != _undefined) '_gte': ($_gte as int?),
        if ($_in != _undefined) '_in': ($_in as List<int>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as int?),
        if ($_lte != _undefined) '_lte': ($_lte as int?),
        if ($_neq != _undefined) '_neq': ($_neq as int?),
        if ($_nin != _undefined) '_nin': ($_nin as List<int>?),
      }));
}

class _CopyWithStubImpl$Input$IntComparisonExp<TRes>
    implements CopyWith$Input$IntComparisonExp<TRes> {
  _CopyWithStubImpl$Input$IntComparisonExp(this._res);

  TRes _res;

  call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      _res;
}

class Input$ItemsCounterBoolExp {
  factory Input$ItemsCounterBoolExp({
    List<Input$ItemsCounterBoolExp>? $_and,
    Input$ItemsCounterBoolExp? $_not,
    List<Input$ItemsCounterBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$CounterLevelEnumComparisonExp? level,
    Input$IntComparisonExp? total,
    Input$ItemTypeEnumComparisonExp? type,
  }) =>
      Input$ItemsCounterBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (id != null) r'id': id,
        if (level != null) r'level': level,
        if (total != null) r'total': total,
        if (type != null) r'type': type,
      });

  Input$ItemsCounterBoolExp._(this._$data);

  factory Input$ItemsCounterBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$ItemsCounterBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$ItemsCounterBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$ItemsCounterBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('level')) {
      final l$level = data['level'];
      result$data['level'] = l$level == null
          ? null
          : Input$CounterLevelEnumComparisonExp.fromJson(
              (l$level as Map<String, dynamic>));
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] = l$total == null
          ? null
          : Input$IntComparisonExp.fromJson((l$total as Map<String, dynamic>));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$ItemTypeEnumComparisonExp.fromJson(
              (l$type as Map<String, dynamic>));
    }
    return Input$ItemsCounterBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ItemsCounterBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$ItemsCounterBoolExp>?);

  Input$ItemsCounterBoolExp? get $_not =>
      (_$data['_not'] as Input$ItemsCounterBoolExp?);

  List<Input$ItemsCounterBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$ItemsCounterBoolExp>?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$CounterLevelEnumComparisonExp? get level =>
      (_$data['level'] as Input$CounterLevelEnumComparisonExp?);

  Input$IntComparisonExp? get total =>
      (_$data['total'] as Input$IntComparisonExp?);

  Input$ItemTypeEnumComparisonExp? get type =>
      (_$data['type'] as Input$ItemTypeEnumComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('level')) {
      final l$level = level;
      result$data['level'] = l$level?.toJson();
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] = l$total?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ItemsCounterBoolExp<Input$ItemsCounterBoolExp> get copyWith =>
      CopyWith$Input$ItemsCounterBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ItemsCounterBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$level = level;
    final lOther$level = other.level;
    if (_$data.containsKey('level') != other._$data.containsKey('level')) {
      return false;
    }
    if (l$level != lOther$level) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$id = id;
    final l$level = level;
    final l$total = total;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('level') ? l$level : const {},
      _$data.containsKey('total') ? l$total : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$ItemsCounterBoolExp<TRes> {
  factory CopyWith$Input$ItemsCounterBoolExp(
    Input$ItemsCounterBoolExp instance,
    TRes Function(Input$ItemsCounterBoolExp) then,
  ) = _CopyWithImpl$Input$ItemsCounterBoolExp;

  factory CopyWith$Input$ItemsCounterBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ItemsCounterBoolExp;

  TRes call({
    List<Input$ItemsCounterBoolExp>? $_and,
    Input$ItemsCounterBoolExp? $_not,
    List<Input$ItemsCounterBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$CounterLevelEnumComparisonExp? level,
    Input$IntComparisonExp? total,
    Input$ItemTypeEnumComparisonExp? type,
  });
  TRes $_and(
      Iterable<Input$ItemsCounterBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ItemsCounterBoolExp<
                      Input$ItemsCounterBoolExp>>?)
          _fn);
  CopyWith$Input$ItemsCounterBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$ItemsCounterBoolExp>? Function(
              Iterable<
                  CopyWith$Input$ItemsCounterBoolExp<
                      Input$ItemsCounterBoolExp>>?)
          _fn);
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$CounterLevelEnumComparisonExp<TRes> get level;
  CopyWith$Input$IntComparisonExp<TRes> get total;
  CopyWith$Input$ItemTypeEnumComparisonExp<TRes> get type;
}

class _CopyWithImpl$Input$ItemsCounterBoolExp<TRes>
    implements CopyWith$Input$ItemsCounterBoolExp<TRes> {
  _CopyWithImpl$Input$ItemsCounterBoolExp(
    this._instance,
    this._then,
  );

  final Input$ItemsCounterBoolExp _instance;

  final TRes Function(Input$ItemsCounterBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? id = _undefined,
    Object? level = _undefined,
    Object? total = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$ItemsCounterBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$ItemsCounterBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$ItemsCounterBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<Input$ItemsCounterBoolExp>?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (level != _undefined)
          'level': (level as Input$CounterLevelEnumComparisonExp?),
        if (total != _undefined) 'total': (total as Input$IntComparisonExp?),
        if (type != _undefined)
          'type': (type as Input$ItemTypeEnumComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$ItemsCounterBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ItemsCounterBoolExp<
                          Input$ItemsCounterBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(
              _instance.$_and?.map((e) => CopyWith$Input$ItemsCounterBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ItemsCounterBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$ItemsCounterBoolExp.stub(_then(_instance))
        : CopyWith$Input$ItemsCounterBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$ItemsCounterBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$ItemsCounterBoolExp<
                          Input$ItemsCounterBoolExp>>?)
              _fn) =>
      call(
          $_or:
              _fn(_instance.$_or?.map((e) => CopyWith$Input$ItemsCounterBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$CounterLevelEnumComparisonExp<TRes> get level {
    final local$level = _instance.level;
    return local$level == null
        ? CopyWith$Input$CounterLevelEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$CounterLevelEnumComparisonExp(
            local$level, (e) => call(level: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get total {
    final local$total = _instance.total;
    return local$total == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$total, (e) => call(total: e));
  }

  CopyWith$Input$ItemTypeEnumComparisonExp<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$ItemTypeEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$ItemTypeEnumComparisonExp(
            local$type, (e) => call(type: e));
  }
}

class _CopyWithStubImpl$Input$ItemsCounterBoolExp<TRes>
    implements CopyWith$Input$ItemsCounterBoolExp<TRes> {
  _CopyWithStubImpl$Input$ItemsCounterBoolExp(this._res);

  TRes _res;

  call({
    List<Input$ItemsCounterBoolExp>? $_and,
    Input$ItemsCounterBoolExp? $_not,
    List<Input$ItemsCounterBoolExp>? $_or,
    Input$StringComparisonExp? id,
    Input$CounterLevelEnumComparisonExp? level,
    Input$IntComparisonExp? total,
    Input$ItemTypeEnumComparisonExp? type,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$ItemsCounterBoolExp<TRes> get $_not =>
      CopyWith$Input$ItemsCounterBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$CounterLevelEnumComparisonExp<TRes> get level =>
      CopyWith$Input$CounterLevelEnumComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get total =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$ItemTypeEnumComparisonExp<TRes> get type =>
      CopyWith$Input$ItemTypeEnumComparisonExp.stub(_res);
}

class Input$ItemsCounterOrderBy {
  factory Input$ItemsCounterOrderBy({
    Enum$OrderBy? id,
    Enum$OrderBy? level,
    Enum$OrderBy? total,
    Enum$OrderBy? type,
  }) =>
      Input$ItemsCounterOrderBy._({
        if (id != null) r'id': id,
        if (level != null) r'level': level,
        if (total != null) r'total': total,
        if (type != null) r'type': type,
      });

  Input$ItemsCounterOrderBy._(this._$data);

  factory Input$ItemsCounterOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('level')) {
      final l$level = data['level'];
      result$data['level'] =
          l$level == null ? null : fromJson$Enum$OrderBy((l$level as String));
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] =
          l$total == null ? null : fromJson$Enum$OrderBy((l$total as String));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          l$type == null ? null : fromJson$Enum$OrderBy((l$type as String));
    }
    return Input$ItemsCounterOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get level => (_$data['level'] as Enum$OrderBy?);

  Enum$OrderBy? get total => (_$data['total'] as Enum$OrderBy?);

  Enum$OrderBy? get type => (_$data['type'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('level')) {
      final l$level = level;
      result$data['level'] =
          l$level == null ? null : toJson$Enum$OrderBy(l$level);
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] =
          l$total == null ? null : toJson$Enum$OrderBy(l$total);
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null ? null : toJson$Enum$OrderBy(l$type);
    }
    return result$data;
  }

  CopyWith$Input$ItemsCounterOrderBy<Input$ItemsCounterOrderBy> get copyWith =>
      CopyWith$Input$ItemsCounterOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ItemsCounterOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$level = level;
    final lOther$level = other.level;
    if (_$data.containsKey('level') != other._$data.containsKey('level')) {
      return false;
    }
    if (l$level != lOther$level) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$level = level;
    final l$total = total;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('level') ? l$level : const {},
      _$data.containsKey('total') ? l$total : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$ItemsCounterOrderBy<TRes> {
  factory CopyWith$Input$ItemsCounterOrderBy(
    Input$ItemsCounterOrderBy instance,
    TRes Function(Input$ItemsCounterOrderBy) then,
  ) = _CopyWithImpl$Input$ItemsCounterOrderBy;

  factory CopyWith$Input$ItemsCounterOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$ItemsCounterOrderBy;

  TRes call({
    Enum$OrderBy? id,
    Enum$OrderBy? level,
    Enum$OrderBy? total,
    Enum$OrderBy? type,
  });
}

class _CopyWithImpl$Input$ItemsCounterOrderBy<TRes>
    implements CopyWith$Input$ItemsCounterOrderBy<TRes> {
  _CopyWithImpl$Input$ItemsCounterOrderBy(
    this._instance,
    this._then,
  );

  final Input$ItemsCounterOrderBy _instance;

  final TRes Function(Input$ItemsCounterOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? level = _undefined,
    Object? total = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$ItemsCounterOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (level != _undefined) 'level': (level as Enum$OrderBy?),
        if (total != _undefined) 'total': (total as Enum$OrderBy?),
        if (type != _undefined) 'type': (type as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$ItemsCounterOrderBy<TRes>
    implements CopyWith$Input$ItemsCounterOrderBy<TRes> {
  _CopyWithStubImpl$Input$ItemsCounterOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? id,
    Enum$OrderBy? level,
    Enum$OrderBy? total,
    Enum$OrderBy? type,
  }) =>
      _res;
}

class Input$ItemTypeEnumComparisonExp {
  factory Input$ItemTypeEnumComparisonExp({
    Enum$ItemTypeEnum? $_eq,
    List<Enum$ItemTypeEnum>? $_in,
    bool? $_isNull,
    Enum$ItemTypeEnum? $_neq,
    List<Enum$ItemTypeEnum>? $_nin,
  }) =>
      Input$ItemTypeEnumComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$ItemTypeEnumComparisonExp._(this._$data);

  factory Input$ItemTypeEnumComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = l$$_eq == null
          ? null
          : fromJson$Enum$ItemTypeEnum((l$$_eq as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ItemTypeEnum((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromJson$Enum$ItemTypeEnum((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ItemTypeEnum((e as String)))
          .toList();
    }
    return Input$ItemTypeEnumComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ItemTypeEnum? get $_eq => (_$data['_eq'] as Enum$ItemTypeEnum?);

  List<Enum$ItemTypeEnum>? get $_in =>
      (_$data['_in'] as List<Enum$ItemTypeEnum>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Enum$ItemTypeEnum? get $_neq => (_$data['_neq'] as Enum$ItemTypeEnum?);

  List<Enum$ItemTypeEnum>? get $_nin =>
      (_$data['_nin'] as List<Enum$ItemTypeEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : toJson$Enum$ItemTypeEnum(l$$_eq);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => toJson$Enum$ItemTypeEnum(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] =
          l$$_neq == null ? null : toJson$Enum$ItemTypeEnum(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => toJson$Enum$ItemTypeEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$ItemTypeEnumComparisonExp<Input$ItemTypeEnumComparisonExp>
      get copyWith => CopyWith$Input$ItemTypeEnumComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ItemTypeEnumComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ItemTypeEnumComparisonExp<TRes> {
  factory CopyWith$Input$ItemTypeEnumComparisonExp(
    Input$ItemTypeEnumComparisonExp instance,
    TRes Function(Input$ItemTypeEnumComparisonExp) then,
  ) = _CopyWithImpl$Input$ItemTypeEnumComparisonExp;

  factory CopyWith$Input$ItemTypeEnumComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$ItemTypeEnumComparisonExp;

  TRes call({
    Enum$ItemTypeEnum? $_eq,
    List<Enum$ItemTypeEnum>? $_in,
    bool? $_isNull,
    Enum$ItemTypeEnum? $_neq,
    List<Enum$ItemTypeEnum>? $_nin,
  });
}

class _CopyWithImpl$Input$ItemTypeEnumComparisonExp<TRes>
    implements CopyWith$Input$ItemTypeEnumComparisonExp<TRes> {
  _CopyWithImpl$Input$ItemTypeEnumComparisonExp(
    this._instance,
    this._then,
  );

  final Input$ItemTypeEnumComparisonExp _instance;

  final TRes Function(Input$ItemTypeEnumComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$ItemTypeEnumComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Enum$ItemTypeEnum?),
        if ($_in != _undefined) '_in': ($_in as List<Enum$ItemTypeEnum>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as Enum$ItemTypeEnum?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Enum$ItemTypeEnum>?),
      }));
}

class _CopyWithStubImpl$Input$ItemTypeEnumComparisonExp<TRes>
    implements CopyWith$Input$ItemTypeEnumComparisonExp<TRes> {
  _CopyWithStubImpl$Input$ItemTypeEnumComparisonExp(this._res);

  TRes _res;

  call({
    Enum$ItemTypeEnum? $_eq,
    List<Enum$ItemTypeEnum>? $_in,
    bool? $_isNull,
    Enum$ItemTypeEnum? $_neq,
    List<Enum$ItemTypeEnum>? $_nin,
  }) =>
      _res;
}

class Input$JsonbCastExp {
  factory Input$JsonbCastExp({Input$StringComparisonExp? $String}) =>
      Input$JsonbCastExp._({
        if ($String != null) r'String': $String,
      });

  Input$JsonbCastExp._(this._$data);

  factory Input$JsonbCastExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('String')) {
      final l$$String = data['String'];
      result$data['String'] = l$$String == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$$String as Map<String, dynamic>));
    }
    return Input$JsonbCastExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringComparisonExp? get $String =>
      (_$data['String'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('String')) {
      final l$$String = $String;
      result$data['String'] = l$$String?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$JsonbCastExp<Input$JsonbCastExp> get copyWith =>
      CopyWith$Input$JsonbCastExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JsonbCastExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$String = $String;
    final lOther$$String = other.$String;
    if (_$data.containsKey('String') != other._$data.containsKey('String')) {
      return false;
    }
    if (l$$String != lOther$$String) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$String = $String;
    return Object.hashAll(
        [_$data.containsKey('String') ? l$$String : const {}]);
  }
}

abstract class CopyWith$Input$JsonbCastExp<TRes> {
  factory CopyWith$Input$JsonbCastExp(
    Input$JsonbCastExp instance,
    TRes Function(Input$JsonbCastExp) then,
  ) = _CopyWithImpl$Input$JsonbCastExp;

  factory CopyWith$Input$JsonbCastExp.stub(TRes res) =
      _CopyWithStubImpl$Input$JsonbCastExp;

  TRes call({Input$StringComparisonExp? $String});
  CopyWith$Input$StringComparisonExp<TRes> get $String;
}

class _CopyWithImpl$Input$JsonbCastExp<TRes>
    implements CopyWith$Input$JsonbCastExp<TRes> {
  _CopyWithImpl$Input$JsonbCastExp(
    this._instance,
    this._then,
  );

  final Input$JsonbCastExp _instance;

  final TRes Function(Input$JsonbCastExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $String = _undefined}) => _then(Input$JsonbCastExp._({
        ..._instance._$data,
        if ($String != _undefined)
          'String': ($String as Input$StringComparisonExp?),
      }));

  CopyWith$Input$StringComparisonExp<TRes> get $String {
    final local$$String = _instance.$String;
    return local$$String == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$$String, (e) => call($String: e));
  }
}

class _CopyWithStubImpl$Input$JsonbCastExp<TRes>
    implements CopyWith$Input$JsonbCastExp<TRes> {
  _CopyWithStubImpl$Input$JsonbCastExp(this._res);

  TRes _res;

  call({Input$StringComparisonExp? $String}) => _res;

  CopyWith$Input$StringComparisonExp<TRes> get $String =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$JsonbComparisonExp {
  factory Input$JsonbComparisonExp({
    Input$JsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  }) =>
      Input$JsonbComparisonExp._({
        if ($_cast != null) r'_cast': $_cast,
        if ($_containedIn != null) r'_containedIn': $_containedIn,
        if ($_contains != null) r'_contains': $_contains,
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_hasKey != null) r'_hasKey': $_hasKey,
        if ($_hasKeysAll != null) r'_hasKeysAll': $_hasKeysAll,
        if ($_hasKeysAny != null) r'_hasKeysAny': $_hasKeysAny,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$JsonbComparisonExp._(this._$data);

  factory Input$JsonbComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_cast')) {
      final l$$_cast = data['_cast'];
      result$data['_cast'] = l$$_cast == null
          ? null
          : Input$JsonbCastExp.fromJson((l$$_cast as Map<String, dynamic>));
    }
    if (data.containsKey('_containedIn')) {
      final l$$_containedIn = data['_containedIn'];
      result$data['_containedIn'] = (l$$_containedIn as Map<String, dynamic>?);
    }
    if (data.containsKey('_contains')) {
      final l$$_contains = data['_contains'];
      result$data['_contains'] = (l$$_contains as Map<String, dynamic>?);
    }
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as Map<String, dynamic>?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as Map<String, dynamic>?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as Map<String, dynamic>?);
    }
    if (data.containsKey('_hasKey')) {
      final l$$_hasKey = data['_hasKey'];
      result$data['_hasKey'] = (l$$_hasKey as String?);
    }
    if (data.containsKey('_hasKeysAll')) {
      final l$$_hasKeysAll = data['_hasKeysAll'];
      result$data['_hasKeysAll'] = (l$$_hasKeysAll as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('_hasKeysAny')) {
      final l$$_hasKeysAny = data['_hasKeysAny'];
      result$data['_hasKeysAny'] = (l$$_hasKeysAny as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => (e as Map<String, dynamic>))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as Map<String, dynamic>?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as Map<String, dynamic>?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as Map<String, dynamic>?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => (e as Map<String, dynamic>))
          .toList();
    }
    return Input$JsonbComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$JsonbCastExp? get $_cast => (_$data['_cast'] as Input$JsonbCastExp?);

  Map<String, dynamic>? get $_containedIn =>
      (_$data['_containedIn'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_contains =>
      (_$data['_contains'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_eq => (_$data['_eq'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_gt => (_$data['_gt'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_gte => (_$data['_gte'] as Map<String, dynamic>?);

  String? get $_hasKey => (_$data['_hasKey'] as String?);

  List<String>? get $_hasKeysAll => (_$data['_hasKeysAll'] as List<String>?);

  List<String>? get $_hasKeysAny => (_$data['_hasKeysAny'] as List<String>?);

  List<Map<String, dynamic>>? get $_in =>
      (_$data['_in'] as List<Map<String, dynamic>>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Map<String, dynamic>? get $_lt => (_$data['_lt'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_lte => (_$data['_lte'] as Map<String, dynamic>?);

  Map<String, dynamic>? get $_neq => (_$data['_neq'] as Map<String, dynamic>?);

  List<Map<String, dynamic>>? get $_nin =>
      (_$data['_nin'] as List<Map<String, dynamic>>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_cast')) {
      final l$$_cast = $_cast;
      result$data['_cast'] = l$$_cast?.toJson();
    }
    if (_$data.containsKey('_containedIn')) {
      final l$$_containedIn = $_containedIn;
      result$data['_containedIn'] = l$$_containedIn;
    }
    if (_$data.containsKey('_contains')) {
      final l$$_contains = $_contains;
      result$data['_contains'] = l$$_contains;
    }
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_hasKey')) {
      final l$$_hasKey = $_hasKey;
      result$data['_hasKey'] = l$$_hasKey;
    }
    if (_$data.containsKey('_hasKeysAll')) {
      final l$$_hasKeysAll = $_hasKeysAll;
      result$data['_hasKeysAll'] = l$$_hasKeysAll?.map((e) => e).toList();
    }
    if (_$data.containsKey('_hasKeysAny')) {
      final l$$_hasKeysAny = $_hasKeysAny;
      result$data['_hasKeysAny'] = l$$_hasKeysAny?.map((e) => e).toList();
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$JsonbComparisonExp<Input$JsonbComparisonExp> get copyWith =>
      CopyWith$Input$JsonbComparisonExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$JsonbComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_cast = $_cast;
    final lOther$$_cast = other.$_cast;
    if (_$data.containsKey('_cast') != other._$data.containsKey('_cast')) {
      return false;
    }
    if (l$$_cast != lOther$$_cast) {
      return false;
    }
    final l$$_containedIn = $_containedIn;
    final lOther$$_containedIn = other.$_containedIn;
    if (_$data.containsKey('_containedIn') !=
        other._$data.containsKey('_containedIn')) {
      return false;
    }
    if (l$$_containedIn != lOther$$_containedIn) {
      return false;
    }
    final l$$_contains = $_contains;
    final lOther$$_contains = other.$_contains;
    if (_$data.containsKey('_contains') !=
        other._$data.containsKey('_contains')) {
      return false;
    }
    if (l$$_contains != lOther$$_contains) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_hasKey = $_hasKey;
    final lOther$$_hasKey = other.$_hasKey;
    if (_$data.containsKey('_hasKey') != other._$data.containsKey('_hasKey')) {
      return false;
    }
    if (l$$_hasKey != lOther$$_hasKey) {
      return false;
    }
    final l$$_hasKeysAll = $_hasKeysAll;
    final lOther$$_hasKeysAll = other.$_hasKeysAll;
    if (_$data.containsKey('_hasKeysAll') !=
        other._$data.containsKey('_hasKeysAll')) {
      return false;
    }
    if (l$$_hasKeysAll != null && lOther$$_hasKeysAll != null) {
      if (l$$_hasKeysAll.length != lOther$$_hasKeysAll.length) {
        return false;
      }
      for (int i = 0; i < l$$_hasKeysAll.length; i++) {
        final l$$_hasKeysAll$entry = l$$_hasKeysAll[i];
        final lOther$$_hasKeysAll$entry = lOther$$_hasKeysAll[i];
        if (l$$_hasKeysAll$entry != lOther$$_hasKeysAll$entry) {
          return false;
        }
      }
    } else if (l$$_hasKeysAll != lOther$$_hasKeysAll) {
      return false;
    }
    final l$$_hasKeysAny = $_hasKeysAny;
    final lOther$$_hasKeysAny = other.$_hasKeysAny;
    if (_$data.containsKey('_hasKeysAny') !=
        other._$data.containsKey('_hasKeysAny')) {
      return false;
    }
    if (l$$_hasKeysAny != null && lOther$$_hasKeysAny != null) {
      if (l$$_hasKeysAny.length != lOther$$_hasKeysAny.length) {
        return false;
      }
      for (int i = 0; i < l$$_hasKeysAny.length; i++) {
        final l$$_hasKeysAny$entry = l$$_hasKeysAny[i];
        final lOther$$_hasKeysAny$entry = lOther$$_hasKeysAny[i];
        if (l$$_hasKeysAny$entry != lOther$$_hasKeysAny$entry) {
          return false;
        }
      }
    } else if (l$$_hasKeysAny != lOther$$_hasKeysAny) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_cast = $_cast;
    final l$$_containedIn = $_containedIn;
    final l$$_contains = $_contains;
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_hasKey = $_hasKey;
    final l$$_hasKeysAll = $_hasKeysAll;
    final l$$_hasKeysAny = $_hasKeysAny;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_cast') ? l$$_cast : const {},
      _$data.containsKey('_containedIn') ? l$$_containedIn : const {},
      _$data.containsKey('_contains') ? l$$_contains : const {},
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_hasKey') ? l$$_hasKey : const {},
      _$data.containsKey('_hasKeysAll')
          ? l$$_hasKeysAll == null
              ? null
              : Object.hashAll(l$$_hasKeysAll.map((v) => v))
          : const {},
      _$data.containsKey('_hasKeysAny')
          ? l$$_hasKeysAny == null
              ? null
              : Object.hashAll(l$$_hasKeysAny.map((v) => v))
          : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$JsonbComparisonExp<TRes> {
  factory CopyWith$Input$JsonbComparisonExp(
    Input$JsonbComparisonExp instance,
    TRes Function(Input$JsonbComparisonExp) then,
  ) = _CopyWithImpl$Input$JsonbComparisonExp;

  factory CopyWith$Input$JsonbComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$JsonbComparisonExp;

  TRes call({
    Input$JsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  });
  CopyWith$Input$JsonbCastExp<TRes> get $_cast;
}

class _CopyWithImpl$Input$JsonbComparisonExp<TRes>
    implements CopyWith$Input$JsonbComparisonExp<TRes> {
  _CopyWithImpl$Input$JsonbComparisonExp(
    this._instance,
    this._then,
  );

  final Input$JsonbComparisonExp _instance;

  final TRes Function(Input$JsonbComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_cast = _undefined,
    Object? $_containedIn = _undefined,
    Object? $_contains = _undefined,
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_hasKey = _undefined,
    Object? $_hasKeysAll = _undefined,
    Object? $_hasKeysAny = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$JsonbComparisonExp._({
        ..._instance._$data,
        if ($_cast != _undefined) '_cast': ($_cast as Input$JsonbCastExp?),
        if ($_containedIn != _undefined)
          '_containedIn': ($_containedIn as Map<String, dynamic>?),
        if ($_contains != _undefined)
          '_contains': ($_contains as Map<String, dynamic>?),
        if ($_eq != _undefined) '_eq': ($_eq as Map<String, dynamic>?),
        if ($_gt != _undefined) '_gt': ($_gt as Map<String, dynamic>?),
        if ($_gte != _undefined) '_gte': ($_gte as Map<String, dynamic>?),
        if ($_hasKey != _undefined) '_hasKey': ($_hasKey as String?),
        if ($_hasKeysAll != _undefined)
          '_hasKeysAll': ($_hasKeysAll as List<String>?),
        if ($_hasKeysAny != _undefined)
          '_hasKeysAny': ($_hasKeysAny as List<String>?),
        if ($_in != _undefined) '_in': ($_in as List<Map<String, dynamic>>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as Map<String, dynamic>?),
        if ($_lte != _undefined) '_lte': ($_lte as Map<String, dynamic>?),
        if ($_neq != _undefined) '_neq': ($_neq as Map<String, dynamic>?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Map<String, dynamic>>?),
      }));

  CopyWith$Input$JsonbCastExp<TRes> get $_cast {
    final local$$_cast = _instance.$_cast;
    return local$$_cast == null
        ? CopyWith$Input$JsonbCastExp.stub(_then(_instance))
        : CopyWith$Input$JsonbCastExp(local$$_cast, (e) => call($_cast: e));
  }
}

class _CopyWithStubImpl$Input$JsonbComparisonExp<TRes>
    implements CopyWith$Input$JsonbComparisonExp<TRes> {
  _CopyWithStubImpl$Input$JsonbComparisonExp(this._res);

  TRes _res;

  call({
    Input$JsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  }) =>
      _res;

  CopyWith$Input$JsonbCastExp<TRes> get $_cast =>
      CopyWith$Input$JsonbCastExp.stub(_res);
}

class Input$MembershipEventAggregateBoolExp {
  factory Input$MembershipEventAggregateBoolExp(
          {Input$membershipEventAggregateBoolExpCount? count}) =>
      Input$MembershipEventAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$MembershipEventAggregateBoolExp._(this._$data);

  factory Input$MembershipEventAggregateBoolExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$membershipEventAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$MembershipEventAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$membershipEventAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$membershipEventAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventAggregateBoolExp<
          Input$MembershipEventAggregateBoolExp>
      get copyWith => CopyWith$Input$MembershipEventAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventAggregateBoolExp<TRes> {
  factory CopyWith$Input$MembershipEventAggregateBoolExp(
    Input$MembershipEventAggregateBoolExp instance,
    TRes Function(Input$MembershipEventAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$MembershipEventAggregateBoolExp;

  factory CopyWith$Input$MembershipEventAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventAggregateBoolExp;

  TRes call({Input$membershipEventAggregateBoolExpCount? count});
  CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$MembershipEventAggregateBoolExp<TRes>
    implements CopyWith$Input$MembershipEventAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$MembershipEventAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$MembershipEventAggregateBoolExp _instance;

  final TRes Function(Input$MembershipEventAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$MembershipEventAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$membershipEventAggregateBoolExpCount?),
      }));

  CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$membershipEventAggregateBoolExpCount.stub(
            _then(_instance))
        : CopyWith$Input$membershipEventAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$MembershipEventAggregateBoolExp<TRes>
    implements CopyWith$Input$MembershipEventAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$MembershipEventAggregateBoolExp(this._res);

  TRes _res;

  call({Input$membershipEventAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$membershipEventAggregateBoolExpCount.stub(_res);
}

class Input$membershipEventAggregateBoolExpCount {
  factory Input$membershipEventAggregateBoolExpCount({
    List<Enum$MembershipEventSelectColumn>? arguments,
    bool? distinct,
    Input$MembershipEventBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$membershipEventAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$membershipEventAggregateBoolExpCount._(this._$data);

  factory Input$membershipEventAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$MembershipEventSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$MembershipEventBoolExp.fromJson(
              (l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$membershipEventAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$MembershipEventSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$MembershipEventSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$MembershipEventBoolExp? get filter =>
      (_$data['filter'] as Input$MembershipEventBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] = l$arguments
          ?.map((e) => toJson$Enum$MembershipEventSelectColumn(e))
          .toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$membershipEventAggregateBoolExpCount<
          Input$membershipEventAggregateBoolExpCount>
      get copyWith => CopyWith$Input$membershipEventAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$membershipEventAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$membershipEventAggregateBoolExpCount(
    Input$membershipEventAggregateBoolExpCount instance,
    TRes Function(Input$membershipEventAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$membershipEventAggregateBoolExpCount;

  factory CopyWith$Input$membershipEventAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$membershipEventAggregateBoolExpCount;

  TRes call({
    List<Enum$MembershipEventSelectColumn>? arguments,
    bool? distinct,
    Input$MembershipEventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$MembershipEventBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$membershipEventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$membershipEventAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$membershipEventAggregateBoolExpCount _instance;

  final TRes Function(Input$membershipEventAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$membershipEventAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$MembershipEventSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined)
          'filter': (filter as Input$MembershipEventBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$MembershipEventBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$MembershipEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$MembershipEventBoolExp(
            local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$membershipEventAggregateBoolExpCount<TRes>
    implements CopyWith$Input$membershipEventAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$membershipEventAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$MembershipEventSelectColumn>? arguments,
    bool? distinct,
    Input$MembershipEventBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$MembershipEventBoolExp<TRes> get filter =>
      CopyWith$Input$MembershipEventBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$MembershipEventAggregateOrderBy {
  factory Input$MembershipEventAggregateOrderBy({
    Input$MembershipEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$MembershipEventMaxOrderBy? max,
    Input$MembershipEventMinOrderBy? min,
    Input$MembershipEventStddevOrderBy? stddev,
    Input$MembershipEventStddevPopOrderBy? stddevPop,
    Input$MembershipEventStddevSampOrderBy? stddevSamp,
    Input$MembershipEventSumOrderBy? sum,
    Input$MembershipEventVarPopOrderBy? varPop,
    Input$MembershipEventVarSampOrderBy? varSamp,
    Input$MembershipEventVarianceOrderBy? variance,
  }) =>
      Input$MembershipEventAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$MembershipEventAggregateOrderBy._(this._$data);

  factory Input$MembershipEventAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$MembershipEventAvgOrderBy.fromJson(
              (l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$MembershipEventMaxOrderBy.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$MembershipEventMinOrderBy.fromJson(
              (l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$MembershipEventStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$MembershipEventStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$MembershipEventStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$MembershipEventSumOrderBy.fromJson(
              (l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$MembershipEventVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$MembershipEventVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$MembershipEventVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$MembershipEventAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$MembershipEventAvgOrderBy? get avg =>
      (_$data['avg'] as Input$MembershipEventAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$MembershipEventMaxOrderBy? get max =>
      (_$data['max'] as Input$MembershipEventMaxOrderBy?);

  Input$MembershipEventMinOrderBy? get min =>
      (_$data['min'] as Input$MembershipEventMinOrderBy?);

  Input$MembershipEventStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$MembershipEventStddevOrderBy?);

  Input$MembershipEventStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$MembershipEventStddevPopOrderBy?);

  Input$MembershipEventStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$MembershipEventStddevSampOrderBy?);

  Input$MembershipEventSumOrderBy? get sum =>
      (_$data['sum'] as Input$MembershipEventSumOrderBy?);

  Input$MembershipEventVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$MembershipEventVarPopOrderBy?);

  Input$MembershipEventVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$MembershipEventVarSampOrderBy?);

  Input$MembershipEventVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$MembershipEventVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventAggregateOrderBy<
          Input$MembershipEventAggregateOrderBy>
      get copyWith => CopyWith$Input$MembershipEventAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$MembershipEventAggregateOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventAggregateOrderBy(
    Input$MembershipEventAggregateOrderBy instance,
    TRes Function(Input$MembershipEventAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventAggregateOrderBy;

  factory CopyWith$Input$MembershipEventAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventAggregateOrderBy;

  TRes call({
    Input$MembershipEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$MembershipEventMaxOrderBy? max,
    Input$MembershipEventMinOrderBy? min,
    Input$MembershipEventStddevOrderBy? stddev,
    Input$MembershipEventStddevPopOrderBy? stddevPop,
    Input$MembershipEventStddevSampOrderBy? stddevSamp,
    Input$MembershipEventSumOrderBy? sum,
    Input$MembershipEventVarPopOrderBy? varPop,
    Input$MembershipEventVarSampOrderBy? varSamp,
    Input$MembershipEventVarianceOrderBy? variance,
  });
  CopyWith$Input$MembershipEventAvgOrderBy<TRes> get avg;
  CopyWith$Input$MembershipEventMaxOrderBy<TRes> get max;
  CopyWith$Input$MembershipEventMinOrderBy<TRes> get min;
  CopyWith$Input$MembershipEventStddevOrderBy<TRes> get stddev;
  CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$MembershipEventSumOrderBy<TRes> get sum;
  CopyWith$Input$MembershipEventVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$MembershipEventVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$MembershipEventVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$MembershipEventAggregateOrderBy<TRes>
    implements CopyWith$Input$MembershipEventAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventAggregateOrderBy _instance;

  final TRes Function(Input$MembershipEventAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$MembershipEventAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$MembershipEventAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$MembershipEventMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$MembershipEventMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$MembershipEventStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$MembershipEventStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$MembershipEventStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$MembershipEventSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$MembershipEventVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$MembershipEventVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$MembershipEventVarianceOrderBy?),
      }));

  CopyWith$Input$MembershipEventAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$MembershipEventAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventAvgOrderBy(
            local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$MembershipEventMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$MembershipEventMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventMaxOrderBy(
            local$max, (e) => call(max: e));
  }

  CopyWith$Input$MembershipEventMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$MembershipEventMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventMinOrderBy(
            local$min, (e) => call(min: e));
  }

  CopyWith$Input$MembershipEventStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$MembershipEventStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$MembershipEventStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$MembershipEventStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$MembershipEventSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$MembershipEventSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventSumOrderBy(
            local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$MembershipEventVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$MembershipEventVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$MembershipEventVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$MembershipEventVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$MembershipEventVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$MembershipEventVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$MembershipEventVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$MembershipEventAggregateOrderBy<TRes>
    implements CopyWith$Input$MembershipEventAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$MembershipEventAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$MembershipEventMaxOrderBy? max,
    Input$MembershipEventMinOrderBy? min,
    Input$MembershipEventStddevOrderBy? stddev,
    Input$MembershipEventStddevPopOrderBy? stddevPop,
    Input$MembershipEventStddevSampOrderBy? stddevSamp,
    Input$MembershipEventSumOrderBy? sum,
    Input$MembershipEventVarPopOrderBy? varPop,
    Input$MembershipEventVarSampOrderBy? varSamp,
    Input$MembershipEventVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$MembershipEventAvgOrderBy<TRes> get avg =>
      CopyWith$Input$MembershipEventAvgOrderBy.stub(_res);

  CopyWith$Input$MembershipEventMaxOrderBy<TRes> get max =>
      CopyWith$Input$MembershipEventMaxOrderBy.stub(_res);

  CopyWith$Input$MembershipEventMinOrderBy<TRes> get min =>
      CopyWith$Input$MembershipEventMinOrderBy.stub(_res);

  CopyWith$Input$MembershipEventStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$MembershipEventStddevOrderBy.stub(_res);

  CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$MembershipEventStddevPopOrderBy.stub(_res);

  CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$MembershipEventStddevSampOrderBy.stub(_res);

  CopyWith$Input$MembershipEventSumOrderBy<TRes> get sum =>
      CopyWith$Input$MembershipEventSumOrderBy.stub(_res);

  CopyWith$Input$MembershipEventVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$MembershipEventVarPopOrderBy.stub(_res);

  CopyWith$Input$MembershipEventVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$MembershipEventVarSampOrderBy.stub(_res);

  CopyWith$Input$MembershipEventVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$MembershipEventVarianceOrderBy.stub(_res);
}

class Input$MembershipEventAvgOrderBy {
  factory Input$MembershipEventAvgOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventAvgOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventAvgOrderBy._(this._$data);

  factory Input$MembershipEventAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventAvgOrderBy<Input$MembershipEventAvgOrderBy>
      get copyWith => CopyWith$Input$MembershipEventAvgOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventAvgOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventAvgOrderBy(
    Input$MembershipEventAvgOrderBy instance,
    TRes Function(Input$MembershipEventAvgOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventAvgOrderBy;

  factory CopyWith$Input$MembershipEventAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventAvgOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventAvgOrderBy<TRes>
    implements CopyWith$Input$MembershipEventAvgOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventAvgOrderBy _instance;

  final TRes Function(Input$MembershipEventAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventAvgOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventAvgOrderBy<TRes>
    implements CopyWith$Input$MembershipEventAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventAvgOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventBoolExp {
  factory Input$MembershipEventBoolExp({
    List<Input$MembershipEventBoolExp>? $_and,
    Input$MembershipEventBoolExp? $_not,
    List<Input$MembershipEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
  }) =>
      Input$MembershipEventBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (eventType != null) r'eventType': eventType,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
      });

  Input$MembershipEventBoolExp._(this._$data);

  factory Input$MembershipEventBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$MembershipEventBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$MembershipEventBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$MembershipEventBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventBoolExp.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$eventId as Map<String, dynamic>));
    }
    if (data.containsKey('eventType')) {
      final l$eventType = data['eventType'];
      result$data['eventType'] = l$eventType == null
          ? null
          : Input$EventTypeEnumComparisonExp.fromJson(
              (l$eventType as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$identityId as Map<String, dynamic>));
    }
    return Input$MembershipEventBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MembershipEventBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$MembershipEventBoolExp>?);

  Input$MembershipEventBoolExp? get $_not =>
      (_$data['_not'] as Input$MembershipEventBoolExp?);

  List<Input$MembershipEventBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$MembershipEventBoolExp>?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$EventBoolExp? get event => (_$data['event'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get eventId =>
      (_$data['eventId'] as Input$StringComparisonExp?);

  Input$EventTypeEnumComparisonExp? get eventType =>
      (_$data['eventType'] as Input$EventTypeEnumComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get identity =>
      (_$data['identity'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get identityId =>
      (_$data['identityId'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] = l$eventId?.toJson();
    }
    if (_$data.containsKey('eventType')) {
      final l$eventType = eventType;
      result$data['eventType'] = l$eventType?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] = l$identityId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventBoolExp<Input$MembershipEventBoolExp>
      get copyWith => CopyWith$Input$MembershipEventBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$eventType = eventType;
    final lOther$eventType = other.eventType;
    if (_$data.containsKey('eventType') !=
        other._$data.containsKey('eventType')) {
      return false;
    }
    if (l$eventType != lOther$eventType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$eventType = eventType;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('eventType') ? l$eventType : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MembershipEventBoolExp<TRes> {
  factory CopyWith$Input$MembershipEventBoolExp(
    Input$MembershipEventBoolExp instance,
    TRes Function(Input$MembershipEventBoolExp) then,
  ) = _CopyWithImpl$Input$MembershipEventBoolExp;

  factory CopyWith$Input$MembershipEventBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventBoolExp;

  TRes call({
    List<Input$MembershipEventBoolExp>? $_and,
    Input$MembershipEventBoolExp? $_not,
    List<Input$MembershipEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
  });
  TRes $_and(
      Iterable<Input$MembershipEventBoolExp>? Function(
              Iterable<
                  CopyWith$Input$MembershipEventBoolExp<
                      Input$MembershipEventBoolExp>>?)
          _fn);
  CopyWith$Input$MembershipEventBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$MembershipEventBoolExp>? Function(
              Iterable<
                  CopyWith$Input$MembershipEventBoolExp<
                      Input$MembershipEventBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$EventBoolExp<TRes> get event;
  CopyWith$Input$StringComparisonExp<TRes> get eventId;
  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IdentityBoolExp<TRes> get identity;
  CopyWith$Input$StringComparisonExp<TRes> get identityId;
}

class _CopyWithImpl$Input$MembershipEventBoolExp<TRes>
    implements CopyWith$Input$MembershipEventBoolExp<TRes> {
  _CopyWithImpl$Input$MembershipEventBoolExp(
    this._instance,
    this._then,
  );

  final Input$MembershipEventBoolExp _instance;

  final TRes Function(Input$MembershipEventBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? eventType = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
  }) =>
      _then(Input$MembershipEventBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$MembershipEventBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as Input$MembershipEventBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<Input$MembershipEventBoolExp>?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (event != _undefined) 'event': (event as Input$EventBoolExp?),
        if (eventId != _undefined)
          'eventId': (eventId as Input$StringComparisonExp?),
        if (eventType != _undefined)
          'eventType': (eventType as Input$EventTypeEnumComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityBoolExp?),
        if (identityId != _undefined)
          'identityId': (identityId as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$MembershipEventBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$MembershipEventBoolExp<
                          Input$MembershipEventBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(
              _instance.$_and?.map((e) => CopyWith$Input$MembershipEventBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$MembershipEventBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$MembershipEventBoolExp.stub(_then(_instance))
        : CopyWith$Input$MembershipEventBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$MembershipEventBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$MembershipEventBoolExp<
                          Input$MembershipEventBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(
              _instance.$_or?.map((e) => CopyWith$Input$MembershipEventBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$event, (e) => call(event: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get eventId {
    final local$eventId = _instance.eventId;
    return local$eventId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$eventId, (e) => call(eventId: e));
  }

  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType {
    final local$eventType = _instance.eventType;
    return local$eventType == null
        ? CopyWith$Input$EventTypeEnumComparisonExp.stub(_then(_instance))
        : CopyWith$Input$EventTypeEnumComparisonExp(
            local$eventType, (e) => call(eventType: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get identityId {
    final local$identityId = _instance.identityId;
    return local$identityId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$identityId, (e) => call(identityId: e));
  }
}

class _CopyWithStubImpl$Input$MembershipEventBoolExp<TRes>
    implements CopyWith$Input$MembershipEventBoolExp<TRes> {
  _CopyWithStubImpl$Input$MembershipEventBoolExp(this._res);

  TRes _res;

  call({
    List<Input$MembershipEventBoolExp>? $_and,
    Input$MembershipEventBoolExp? $_not,
    List<Input$MembershipEventBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$EventTypeEnumComparisonExp? eventType,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$MembershipEventBoolExp<TRes> get $_not =>
      CopyWith$Input$MembershipEventBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get event =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get eventId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$EventTypeEnumComparisonExp<TRes> get eventType =>
      CopyWith$Input$EventTypeEnumComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get identity =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get identityId =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$MembershipEventMaxOrderBy {
  factory Input$MembershipEventMaxOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  }) =>
      Input$MembershipEventMaxOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
      });

  Input$MembershipEventMaxOrderBy._(this._$data);

  factory Input$MembershipEventMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    return Input$MembershipEventMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventMaxOrderBy<Input$MembershipEventMaxOrderBy>
      get copyWith => CopyWith$Input$MembershipEventMaxOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$eventId = eventId;
    final l$id = id;
    final l$identityId = identityId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MembershipEventMaxOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventMaxOrderBy(
    Input$MembershipEventMaxOrderBy instance,
    TRes Function(Input$MembershipEventMaxOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventMaxOrderBy;

  factory CopyWith$Input$MembershipEventMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventMaxOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  });
}

class _CopyWithImpl$Input$MembershipEventMaxOrderBy<TRes>
    implements CopyWith$Input$MembershipEventMaxOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventMaxOrderBy _instance;

  final TRes Function(Input$MembershipEventMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
  }) =>
      _then(Input$MembershipEventMaxOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventMaxOrderBy<TRes>
    implements CopyWith$Input$MembershipEventMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  }) =>
      _res;
}

class Input$MembershipEventMinOrderBy {
  factory Input$MembershipEventMinOrderBy({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  }) =>
      Input$MembershipEventMinOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
      });

  Input$MembershipEventMinOrderBy._(this._$data);

  factory Input$MembershipEventMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    return Input$MembershipEventMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventMinOrderBy<Input$MembershipEventMinOrderBy>
      get copyWith => CopyWith$Input$MembershipEventMinOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$eventId = eventId;
    final l$id = id;
    final l$identityId = identityId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MembershipEventMinOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventMinOrderBy(
    Input$MembershipEventMinOrderBy instance,
    TRes Function(Input$MembershipEventMinOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventMinOrderBy;

  factory CopyWith$Input$MembershipEventMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventMinOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  });
}

class _CopyWithImpl$Input$MembershipEventMinOrderBy<TRes>
    implements CopyWith$Input$MembershipEventMinOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventMinOrderBy _instance;

  final TRes Function(Input$MembershipEventMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
  }) =>
      _then(Input$MembershipEventMinOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventMinOrderBy<TRes>
    implements CopyWith$Input$MembershipEventMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
  }) =>
      _res;
}

class Input$MembershipEventOrderBy {
  factory Input$MembershipEventOrderBy({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
  }) =>
      Input$MembershipEventOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (eventType != null) r'eventType': eventType,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
      });

  Input$MembershipEventOrderBy._(this._$data);

  factory Input$MembershipEventOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventOrderBy.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('eventType')) {
      final l$eventType = data['eventType'];
      result$data['eventType'] = l$eventType == null
          ? null
          : fromJson$Enum$OrderBy((l$eventType as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    return Input$MembershipEventOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Input$EventOrderBy? get event => (_$data['event'] as Input$EventOrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get eventType => (_$data['eventType'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get identity =>
      (_$data['identity'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('eventType')) {
      final l$eventType = eventType;
      result$data['eventType'] =
          l$eventType == null ? null : toJson$Enum$OrderBy(l$eventType);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventOrderBy<Input$MembershipEventOrderBy>
      get copyWith => CopyWith$Input$MembershipEventOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$eventType = eventType;
    final lOther$eventType = other.eventType;
    if (_$data.containsKey('eventType') !=
        other._$data.containsKey('eventType')) {
      return false;
    }
    if (l$eventType != lOther$eventType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$eventType = eventType;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('eventType') ? l$eventType : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MembershipEventOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventOrderBy(
    Input$MembershipEventOrderBy instance,
    TRes Function(Input$MembershipEventOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventOrderBy;

  factory CopyWith$Input$MembershipEventOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
  });
  CopyWith$Input$EventOrderBy<TRes> get event;
  CopyWith$Input$IdentityOrderBy<TRes> get identity;
}

class _CopyWithImpl$Input$MembershipEventOrderBy<TRes>
    implements CopyWith$Input$MembershipEventOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventOrderBy _instance;

  final TRes Function(Input$MembershipEventOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? eventType = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
  }) =>
      _then(Input$MembershipEventOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (event != _undefined) 'event': (event as Input$EventOrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (eventType != _undefined) 'eventType': (eventType as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityOrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
      }));

  CopyWith$Input$EventOrderBy<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(local$event, (e) => call(event: e));
  }

  CopyWith$Input$IdentityOrderBy<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$identity, (e) => call(identity: e));
  }
}

class _CopyWithStubImpl$Input$MembershipEventOrderBy<TRes>
    implements CopyWith$Input$MembershipEventOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? eventType,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
  }) =>
      _res;

  CopyWith$Input$EventOrderBy<TRes> get event =>
      CopyWith$Input$EventOrderBy.stub(_res);

  CopyWith$Input$IdentityOrderBy<TRes> get identity =>
      CopyWith$Input$IdentityOrderBy.stub(_res);
}

class Input$MembershipEventStddevOrderBy {
  factory Input$MembershipEventStddevOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventStddevOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventStddevOrderBy._(this._$data);

  factory Input$MembershipEventStddevOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventStddevOrderBy<
          Input$MembershipEventStddevOrderBy>
      get copyWith => CopyWith$Input$MembershipEventStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventStddevOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventStddevOrderBy(
    Input$MembershipEventStddevOrderBy instance,
    TRes Function(Input$MembershipEventStddevOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventStddevOrderBy;

  factory CopyWith$Input$MembershipEventStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventStddevOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventStddevOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventStddevOrderBy _instance;

  final TRes Function(Input$MembershipEventStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventStddevOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventStddevOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventStddevOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventStddevPopOrderBy {
  factory Input$MembershipEventStddevPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventStddevPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventStddevPopOrderBy._(this._$data);

  factory Input$MembershipEventStddevPopOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventStddevPopOrderBy<
          Input$MembershipEventStddevPopOrderBy>
      get copyWith => CopyWith$Input$MembershipEventStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventStddevPopOrderBy(
    Input$MembershipEventStddevPopOrderBy instance,
    TRes Function(Input$MembershipEventStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventStddevPopOrderBy;

  factory CopyWith$Input$MembershipEventStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventStddevPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventStddevPopOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventStddevPopOrderBy _instance;

  final TRes Function(Input$MembershipEventStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventStddevPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventStddevPopOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventStddevPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventStddevSampOrderBy {
  factory Input$MembershipEventStddevSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventStddevSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventStddevSampOrderBy._(this._$data);

  factory Input$MembershipEventStddevSampOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventStddevSampOrderBy<
          Input$MembershipEventStddevSampOrderBy>
      get copyWith => CopyWith$Input$MembershipEventStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventStddevSampOrderBy(
    Input$MembershipEventStddevSampOrderBy instance,
    TRes Function(Input$MembershipEventStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventStddevSampOrderBy;

  factory CopyWith$Input$MembershipEventStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventStddevSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventStddevSampOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventStddevSampOrderBy _instance;

  final TRes Function(Input$MembershipEventStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventStddevSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventStddevSampOrderBy<TRes>
    implements CopyWith$Input$MembershipEventStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventStddevSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventSumOrderBy {
  factory Input$MembershipEventSumOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventSumOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventSumOrderBy._(this._$data);

  factory Input$MembershipEventSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventSumOrderBy<Input$MembershipEventSumOrderBy>
      get copyWith => CopyWith$Input$MembershipEventSumOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventSumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventSumOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventSumOrderBy(
    Input$MembershipEventSumOrderBy instance,
    TRes Function(Input$MembershipEventSumOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventSumOrderBy;

  factory CopyWith$Input$MembershipEventSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventSumOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventSumOrderBy<TRes>
    implements CopyWith$Input$MembershipEventSumOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventSumOrderBy _instance;

  final TRes Function(Input$MembershipEventSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventSumOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventSumOrderBy<TRes>
    implements CopyWith$Input$MembershipEventSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventSumOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventVarianceOrderBy {
  factory Input$MembershipEventVarianceOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventVarianceOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventVarianceOrderBy._(this._$data);

  factory Input$MembershipEventVarianceOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventVarianceOrderBy<
          Input$MembershipEventVarianceOrderBy>
      get copyWith => CopyWith$Input$MembershipEventVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventVarianceOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventVarianceOrderBy(
    Input$MembershipEventVarianceOrderBy instance,
    TRes Function(Input$MembershipEventVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventVarianceOrderBy;

  factory CopyWith$Input$MembershipEventVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventVarianceOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventVarianceOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventVarianceOrderBy _instance;

  final TRes Function(Input$MembershipEventVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventVarianceOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventVarianceOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventVarianceOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventVarPopOrderBy {
  factory Input$MembershipEventVarPopOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventVarPopOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventVarPopOrderBy._(this._$data);

  factory Input$MembershipEventVarPopOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventVarPopOrderBy<
          Input$MembershipEventVarPopOrderBy>
      get copyWith => CopyWith$Input$MembershipEventVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventVarPopOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventVarPopOrderBy(
    Input$MembershipEventVarPopOrderBy instance,
    TRes Function(Input$MembershipEventVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventVarPopOrderBy;

  factory CopyWith$Input$MembershipEventVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventVarPopOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventVarPopOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventVarPopOrderBy _instance;

  final TRes Function(Input$MembershipEventVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventVarPopOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventVarPopOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventVarPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$MembershipEventVarSampOrderBy {
  factory Input$MembershipEventVarSampOrderBy({Enum$OrderBy? blockNumber}) =>
      Input$MembershipEventVarSampOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$MembershipEventVarSampOrderBy._(this._$data);

  factory Input$MembershipEventVarSampOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$MembershipEventVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$MembershipEventVarSampOrderBy<
          Input$MembershipEventVarSampOrderBy>
      get copyWith => CopyWith$Input$MembershipEventVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MembershipEventVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    return Object.hashAll(
        [_$data.containsKey('blockNumber') ? l$blockNumber : const {}]);
  }
}

abstract class CopyWith$Input$MembershipEventVarSampOrderBy<TRes> {
  factory CopyWith$Input$MembershipEventVarSampOrderBy(
    Input$MembershipEventVarSampOrderBy instance,
    TRes Function(Input$MembershipEventVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$MembershipEventVarSampOrderBy;

  factory CopyWith$Input$MembershipEventVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$MembershipEventVarSampOrderBy;

  TRes call({Enum$OrderBy? blockNumber});
}

class _CopyWithImpl$Input$MembershipEventVarSampOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$MembershipEventVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$MembershipEventVarSampOrderBy _instance;

  final TRes Function(Input$MembershipEventVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? blockNumber = _undefined}) =>
      _then(Input$MembershipEventVarSampOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$MembershipEventVarSampOrderBy<TRes>
    implements CopyWith$Input$MembershipEventVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$MembershipEventVarSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? blockNumber}) => _res;
}

class Input$NumericComparisonExp {
  factory Input$NumericComparisonExp({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      Input$NumericComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$NumericComparisonExp._(this._$data);

  factory Input$NumericComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as int?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as int?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as int?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as int?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as int?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as int?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$NumericComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $_eq => (_$data['_eq'] as int?);

  int? get $_gt => (_$data['_gt'] as int?);

  int? get $_gte => (_$data['_gte'] as int?);

  List<int>? get $_in => (_$data['_in'] as List<int>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  int? get $_lt => (_$data['_lt'] as int?);

  int? get $_lte => (_$data['_lte'] as int?);

  int? get $_neq => (_$data['_neq'] as int?);

  List<int>? get $_nin => (_$data['_nin'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NumericComparisonExp<Input$NumericComparisonExp>
      get copyWith => CopyWith$Input$NumericComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NumericComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NumericComparisonExp<TRes> {
  factory CopyWith$Input$NumericComparisonExp(
    Input$NumericComparisonExp instance,
    TRes Function(Input$NumericComparisonExp) then,
  ) = _CopyWithImpl$Input$NumericComparisonExp;

  factory CopyWith$Input$NumericComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$NumericComparisonExp;

  TRes call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  });
}

class _CopyWithImpl$Input$NumericComparisonExp<TRes>
    implements CopyWith$Input$NumericComparisonExp<TRes> {
  _CopyWithImpl$Input$NumericComparisonExp(
    this._instance,
    this._then,
  );

  final Input$NumericComparisonExp _instance;

  final TRes Function(Input$NumericComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$NumericComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as int?),
        if ($_gt != _undefined) '_gt': ($_gt as int?),
        if ($_gte != _undefined) '_gte': ($_gte as int?),
        if ($_in != _undefined) '_in': ($_in as List<int>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as int?),
        if ($_lte != _undefined) '_lte': ($_lte as int?),
        if ($_neq != _undefined) '_neq': ($_neq as int?),
        if ($_nin != _undefined) '_nin': ($_nin as List<int>?),
      }));
}

class _CopyWithStubImpl$Input$NumericComparisonExp<TRes>
    implements CopyWith$Input$NumericComparisonExp<TRes> {
  _CopyWithStubImpl$Input$NumericComparisonExp(this._res);

  TRes _res;

  call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      _res;
}

class Input$SmithCertAggregateBoolExp {
  factory Input$SmithCertAggregateBoolExp(
          {Input$smithCertAggregateBoolExpCount? count}) =>
      Input$SmithCertAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$SmithCertAggregateBoolExp._(this._$data);

  factory Input$SmithCertAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$smithCertAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$SmithCertAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$smithCertAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$smithCertAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SmithCertAggregateBoolExp<Input$SmithCertAggregateBoolExp>
      get copyWith => CopyWith$Input$SmithCertAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertAggregateBoolExp<TRes> {
  factory CopyWith$Input$SmithCertAggregateBoolExp(
    Input$SmithCertAggregateBoolExp instance,
    TRes Function(Input$SmithCertAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$SmithCertAggregateBoolExp;

  factory CopyWith$Input$SmithCertAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertAggregateBoolExp;

  TRes call({Input$smithCertAggregateBoolExpCount? count});
  CopyWith$Input$smithCertAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$SmithCertAggregateBoolExp<TRes>
    implements CopyWith$Input$SmithCertAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$SmithCertAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$SmithCertAggregateBoolExp _instance;

  final TRes Function(Input$SmithCertAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$SmithCertAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$smithCertAggregateBoolExpCount?),
      }));

  CopyWith$Input$smithCertAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$smithCertAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$smithCertAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$SmithCertAggregateBoolExp<TRes>
    implements CopyWith$Input$SmithCertAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$SmithCertAggregateBoolExp(this._res);

  TRes _res;

  call({Input$smithCertAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$smithCertAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$smithCertAggregateBoolExpCount.stub(_res);
}

class Input$smithCertAggregateBoolExpCount {
  factory Input$smithCertAggregateBoolExpCount({
    List<Enum$SmithCertSelectColumn>? arguments,
    bool? distinct,
    Input$SmithCertBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$smithCertAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$smithCertAggregateBoolExpCount._(this._$data);

  factory Input$smithCertAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SmithCertSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$SmithCertBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$smithCertAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$SmithCertSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$SmithCertSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$SmithCertBoolExp? get filter =>
      (_$data['filter'] as Input$SmithCertBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] = l$arguments
          ?.map((e) => toJson$Enum$SmithCertSelectColumn(e))
          .toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$smithCertAggregateBoolExpCount<
          Input$smithCertAggregateBoolExpCount>
      get copyWith => CopyWith$Input$smithCertAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$smithCertAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$smithCertAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$smithCertAggregateBoolExpCount(
    Input$smithCertAggregateBoolExpCount instance,
    TRes Function(Input$smithCertAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$smithCertAggregateBoolExpCount;

  factory CopyWith$Input$smithCertAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$smithCertAggregateBoolExpCount;

  TRes call({
    List<Enum$SmithCertSelectColumn>? arguments,
    bool? distinct,
    Input$SmithCertBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$SmithCertBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$smithCertAggregateBoolExpCount<TRes>
    implements CopyWith$Input$smithCertAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$smithCertAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$smithCertAggregateBoolExpCount _instance;

  final TRes Function(Input$smithCertAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$smithCertAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$SmithCertSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$SmithCertBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$SmithCertBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$SmithCertBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$smithCertAggregateBoolExpCount<TRes>
    implements CopyWith$Input$smithCertAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$smithCertAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$SmithCertSelectColumn>? arguments,
    bool? distinct,
    Input$SmithCertBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$SmithCertBoolExp<TRes> get filter =>
      CopyWith$Input$SmithCertBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$SmithCertAggregateOrderBy {
  factory Input$SmithCertAggregateOrderBy({
    Input$SmithCertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$SmithCertMaxOrderBy? max,
    Input$SmithCertMinOrderBy? min,
    Input$SmithCertStddevOrderBy? stddev,
    Input$SmithCertStddevPopOrderBy? stddevPop,
    Input$SmithCertStddevSampOrderBy? stddevSamp,
    Input$SmithCertSumOrderBy? sum,
    Input$SmithCertVarPopOrderBy? varPop,
    Input$SmithCertVarSampOrderBy? varSamp,
    Input$SmithCertVarianceOrderBy? variance,
  }) =>
      Input$SmithCertAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$SmithCertAggregateOrderBy._(this._$data);

  factory Input$SmithCertAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$SmithCertAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$SmithCertMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$SmithCertMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$SmithCertStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$SmithCertStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$SmithCertStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$SmithCertSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$SmithCertVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$SmithCertVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$SmithCertVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$SmithCertAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SmithCertAvgOrderBy? get avg =>
      (_$data['avg'] as Input$SmithCertAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$SmithCertMaxOrderBy? get max =>
      (_$data['max'] as Input$SmithCertMaxOrderBy?);

  Input$SmithCertMinOrderBy? get min =>
      (_$data['min'] as Input$SmithCertMinOrderBy?);

  Input$SmithCertStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$SmithCertStddevOrderBy?);

  Input$SmithCertStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$SmithCertStddevPopOrderBy?);

  Input$SmithCertStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$SmithCertStddevSampOrderBy?);

  Input$SmithCertSumOrderBy? get sum =>
      (_$data['sum'] as Input$SmithCertSumOrderBy?);

  Input$SmithCertVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$SmithCertVarPopOrderBy?);

  Input$SmithCertVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$SmithCertVarSampOrderBy?);

  Input$SmithCertVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$SmithCertVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SmithCertAggregateOrderBy<Input$SmithCertAggregateOrderBy>
      get copyWith => CopyWith$Input$SmithCertAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithCertAggregateOrderBy<TRes> {
  factory CopyWith$Input$SmithCertAggregateOrderBy(
    Input$SmithCertAggregateOrderBy instance,
    TRes Function(Input$SmithCertAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertAggregateOrderBy;

  factory CopyWith$Input$SmithCertAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertAggregateOrderBy;

  TRes call({
    Input$SmithCertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$SmithCertMaxOrderBy? max,
    Input$SmithCertMinOrderBy? min,
    Input$SmithCertStddevOrderBy? stddev,
    Input$SmithCertStddevPopOrderBy? stddevPop,
    Input$SmithCertStddevSampOrderBy? stddevSamp,
    Input$SmithCertSumOrderBy? sum,
    Input$SmithCertVarPopOrderBy? varPop,
    Input$SmithCertVarSampOrderBy? varSamp,
    Input$SmithCertVarianceOrderBy? variance,
  });
  CopyWith$Input$SmithCertAvgOrderBy<TRes> get avg;
  CopyWith$Input$SmithCertMaxOrderBy<TRes> get max;
  CopyWith$Input$SmithCertMinOrderBy<TRes> get min;
  CopyWith$Input$SmithCertStddevOrderBy<TRes> get stddev;
  CopyWith$Input$SmithCertStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$SmithCertStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$SmithCertSumOrderBy<TRes> get sum;
  CopyWith$Input$SmithCertVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$SmithCertVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$SmithCertVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$SmithCertAggregateOrderBy<TRes>
    implements CopyWith$Input$SmithCertAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertAggregateOrderBy _instance;

  final TRes Function(Input$SmithCertAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$SmithCertAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$SmithCertAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$SmithCertMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$SmithCertMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$SmithCertStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$SmithCertStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$SmithCertStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$SmithCertSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$SmithCertVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$SmithCertVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$SmithCertVarianceOrderBy?),
      }));

  CopyWith$Input$SmithCertAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$SmithCertAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$SmithCertMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$SmithCertMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$SmithCertMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$SmithCertMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$SmithCertStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$SmithCertStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$SmithCertStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$SmithCertStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$SmithCertStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$SmithCertStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$SmithCertSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$SmithCertSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$SmithCertVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$SmithCertVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$SmithCertVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$SmithCertVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$SmithCertVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$SmithCertVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$SmithCertVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$SmithCertAggregateOrderBy<TRes>
    implements CopyWith$Input$SmithCertAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$SmithCertAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$SmithCertMaxOrderBy? max,
    Input$SmithCertMinOrderBy? min,
    Input$SmithCertStddevOrderBy? stddev,
    Input$SmithCertStddevPopOrderBy? stddevPop,
    Input$SmithCertStddevSampOrderBy? stddevSamp,
    Input$SmithCertSumOrderBy? sum,
    Input$SmithCertVarPopOrderBy? varPop,
    Input$SmithCertVarSampOrderBy? varSamp,
    Input$SmithCertVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$SmithCertAvgOrderBy<TRes> get avg =>
      CopyWith$Input$SmithCertAvgOrderBy.stub(_res);

  CopyWith$Input$SmithCertMaxOrderBy<TRes> get max =>
      CopyWith$Input$SmithCertMaxOrderBy.stub(_res);

  CopyWith$Input$SmithCertMinOrderBy<TRes> get min =>
      CopyWith$Input$SmithCertMinOrderBy.stub(_res);

  CopyWith$Input$SmithCertStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$SmithCertStddevOrderBy.stub(_res);

  CopyWith$Input$SmithCertStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$SmithCertStddevPopOrderBy.stub(_res);

  CopyWith$Input$SmithCertStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$SmithCertStddevSampOrderBy.stub(_res);

  CopyWith$Input$SmithCertSumOrderBy<TRes> get sum =>
      CopyWith$Input$SmithCertSumOrderBy.stub(_res);

  CopyWith$Input$SmithCertVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$SmithCertVarPopOrderBy.stub(_res);

  CopyWith$Input$SmithCertVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$SmithCertVarSampOrderBy.stub(_res);

  CopyWith$Input$SmithCertVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$SmithCertVarianceOrderBy.stub(_res);
}

class Input$SmithCertAvgOrderBy {
  factory Input$SmithCertAvgOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertAvgOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertAvgOrderBy._(this._$data);

  factory Input$SmithCertAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertAvgOrderBy<Input$SmithCertAvgOrderBy> get copyWith =>
      CopyWith$Input$SmithCertAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertAvgOrderBy<TRes> {
  factory CopyWith$Input$SmithCertAvgOrderBy(
    Input$SmithCertAvgOrderBy instance,
    TRes Function(Input$SmithCertAvgOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertAvgOrderBy;

  factory CopyWith$Input$SmithCertAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertAvgOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertAvgOrderBy<TRes>
    implements CopyWith$Input$SmithCertAvgOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertAvgOrderBy _instance;

  final TRes Function(Input$SmithCertAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertAvgOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertAvgOrderBy<TRes>
    implements CopyWith$Input$SmithCertAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertAvgOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertBoolExp {
  factory Input$SmithCertBoolExp({
    List<Input$SmithCertBoolExp>? $_and,
    Input$SmithCertBoolExp? $_not,
    List<Input$SmithCertBoolExp>? $_or,
    Input$IntComparisonExp? createdOn,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
  }) =>
      Input$SmithCertBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (createdOn != null) r'createdOn': createdOn,
        if (id != null) r'id': id,
        if (issuer != null) r'issuer': issuer,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiver != null) r'receiver': receiver,
        if (receiverId != null) r'receiverId': receiverId,
      });

  Input$SmithCertBoolExp._(this._$data);

  factory Input$SmithCertBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$SmithCertBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$SmithCertBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$SmithCertBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$createdOn as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = l$issuer == null
          ? null
          : Input$IdentityBoolExp.fromJson((l$issuer as Map<String, dynamic>));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$issuerId as Map<String, dynamic>));
    }
    if (data.containsKey('receiver')) {
      final l$receiver = data['receiver'];
      result$data['receiver'] = l$receiver == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$receiver as Map<String, dynamic>));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$receiverId as Map<String, dynamic>));
    }
    return Input$SmithCertBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SmithCertBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$SmithCertBoolExp>?);

  Input$SmithCertBoolExp? get $_not =>
      (_$data['_not'] as Input$SmithCertBoolExp?);

  List<Input$SmithCertBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$SmithCertBoolExp>?);

  Input$IntComparisonExp? get createdOn =>
      (_$data['createdOn'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get issuer =>
      (_$data['issuer'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get issuerId =>
      (_$data['issuerId'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get receiver =>
      (_$data['receiver'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get receiverId =>
      (_$data['receiverId'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] = l$createdOn?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer?.toJson();
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] = l$issuerId?.toJson();
    }
    if (_$data.containsKey('receiver')) {
      final l$receiver = receiver;
      result$data['receiver'] = l$receiver?.toJson();
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] = l$receiverId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SmithCertBoolExp<Input$SmithCertBoolExp> get copyWith =>
      CopyWith$Input$SmithCertBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiver = receiver;
    final lOther$receiver = other.receiver;
    if (_$data.containsKey('receiver') !=
        other._$data.containsKey('receiver')) {
      return false;
    }
    if (l$receiver != lOther$receiver) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$createdOn = createdOn;
    final l$id = id;
    final l$issuer = issuer;
    final l$issuerId = issuerId;
    final l$receiver = receiver;
    final l$receiverId = receiverId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuer') ? l$issuer : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiver') ? l$receiver : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithCertBoolExp<TRes> {
  factory CopyWith$Input$SmithCertBoolExp(
    Input$SmithCertBoolExp instance,
    TRes Function(Input$SmithCertBoolExp) then,
  ) = _CopyWithImpl$Input$SmithCertBoolExp;

  factory CopyWith$Input$SmithCertBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertBoolExp;

  TRes call({
    List<Input$SmithCertBoolExp>? $_and,
    Input$SmithCertBoolExp? $_not,
    List<Input$SmithCertBoolExp>? $_or,
    Input$IntComparisonExp? createdOn,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
  });
  TRes $_and(
      Iterable<Input$SmithCertBoolExp>? Function(
              Iterable<
                  CopyWith$Input$SmithCertBoolExp<Input$SmithCertBoolExp>>?)
          _fn);
  CopyWith$Input$SmithCertBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$SmithCertBoolExp>? Function(
              Iterable<
                  CopyWith$Input$SmithCertBoolExp<Input$SmithCertBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get createdOn;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IdentityBoolExp<TRes> get issuer;
  CopyWith$Input$StringComparisonExp<TRes> get issuerId;
  CopyWith$Input$IdentityBoolExp<TRes> get receiver;
  CopyWith$Input$StringComparisonExp<TRes> get receiverId;
}

class _CopyWithImpl$Input$SmithCertBoolExp<TRes>
    implements CopyWith$Input$SmithCertBoolExp<TRes> {
  _CopyWithImpl$Input$SmithCertBoolExp(
    this._instance,
    this._then,
  );

  final Input$SmithCertBoolExp _instance;

  final TRes Function(Input$SmithCertBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? createdOn = _undefined,
    Object? id = _undefined,
    Object? issuer = _undefined,
    Object? issuerId = _undefined,
    Object? receiver = _undefined,
    Object? receiverId = _undefined,
  }) =>
      _then(Input$SmithCertBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$SmithCertBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$SmithCertBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$SmithCertBoolExp>?),
        if (createdOn != _undefined)
          'createdOn': (createdOn as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (issuer != _undefined) 'issuer': (issuer as Input$IdentityBoolExp?),
        if (issuerId != _undefined)
          'issuerId': (issuerId as Input$StringComparisonExp?),
        if (receiver != _undefined)
          'receiver': (receiver as Input$IdentityBoolExp?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$SmithCertBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$SmithCertBoolExp<Input$SmithCertBoolExp>>?)
              _fn) =>
      call(
          $_and:
              _fn(_instance.$_and?.map((e) => CopyWith$Input$SmithCertBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$SmithCertBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$SmithCertBoolExp.stub(_then(_instance))
        : CopyWith$Input$SmithCertBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$SmithCertBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$SmithCertBoolExp<Input$SmithCertBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$SmithCertBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get createdOn {
    final local$createdOn = _instance.createdOn;
    return local$createdOn == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$createdOn, (e) => call(createdOn: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get issuer {
    final local$issuer = _instance.issuer;
    return local$issuer == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(local$issuer, (e) => call(issuer: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get issuerId {
    final local$issuerId = _instance.issuerId;
    return local$issuerId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$issuerId, (e) => call(issuerId: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get receiver {
    final local$receiver = _instance.receiver;
    return local$receiver == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$receiver, (e) => call(receiver: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get receiverId {
    final local$receiverId = _instance.receiverId;
    return local$receiverId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$receiverId, (e) => call(receiverId: e));
  }
}

class _CopyWithStubImpl$Input$SmithCertBoolExp<TRes>
    implements CopyWith$Input$SmithCertBoolExp<TRes> {
  _CopyWithStubImpl$Input$SmithCertBoolExp(this._res);

  TRes _res;

  call({
    List<Input$SmithCertBoolExp>? $_and,
    Input$SmithCertBoolExp? $_not,
    List<Input$SmithCertBoolExp>? $_or,
    Input$IntComparisonExp? createdOn,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? issuer,
    Input$StringComparisonExp? issuerId,
    Input$IdentityBoolExp? receiver,
    Input$StringComparisonExp? receiverId,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$SmithCertBoolExp<TRes> get $_not =>
      CopyWith$Input$SmithCertBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get createdOn =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get issuer =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get issuerId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get receiver =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get receiverId =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$SmithCertMaxOrderBy {
  factory Input$SmithCertMaxOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  }) =>
      Input$SmithCertMaxOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (id != null) r'id': id,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiverId != null) r'receiverId': receiverId,
      });

  Input$SmithCertMaxOrderBy._(this._$data);

  factory Input$SmithCertMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    return Input$SmithCertMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertMaxOrderBy<Input$SmithCertMaxOrderBy> get copyWith =>
      CopyWith$Input$SmithCertMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$id = id;
    final l$issuerId = issuerId;
    final l$receiverId = receiverId;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithCertMaxOrderBy<TRes> {
  factory CopyWith$Input$SmithCertMaxOrderBy(
    Input$SmithCertMaxOrderBy instance,
    TRes Function(Input$SmithCertMaxOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertMaxOrderBy;

  factory CopyWith$Input$SmithCertMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertMaxOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  });
}

class _CopyWithImpl$Input$SmithCertMaxOrderBy<TRes>
    implements CopyWith$Input$SmithCertMaxOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertMaxOrderBy _instance;

  final TRes Function(Input$SmithCertMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? id = _undefined,
    Object? issuerId = _undefined,
    Object? receiverId = _undefined,
  }) =>
      _then(Input$SmithCertMaxOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertMaxOrderBy<TRes>
    implements CopyWith$Input$SmithCertMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  }) =>
      _res;
}

class Input$SmithCertMinOrderBy {
  factory Input$SmithCertMinOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  }) =>
      Input$SmithCertMinOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (id != null) r'id': id,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiverId != null) r'receiverId': receiverId,
      });

  Input$SmithCertMinOrderBy._(this._$data);

  factory Input$SmithCertMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    return Input$SmithCertMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertMinOrderBy<Input$SmithCertMinOrderBy> get copyWith =>
      CopyWith$Input$SmithCertMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$id = id;
    final l$issuerId = issuerId;
    final l$receiverId = receiverId;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithCertMinOrderBy<TRes> {
  factory CopyWith$Input$SmithCertMinOrderBy(
    Input$SmithCertMinOrderBy instance,
    TRes Function(Input$SmithCertMinOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertMinOrderBy;

  factory CopyWith$Input$SmithCertMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertMinOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  });
}

class _CopyWithImpl$Input$SmithCertMinOrderBy<TRes>
    implements CopyWith$Input$SmithCertMinOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertMinOrderBy _instance;

  final TRes Function(Input$SmithCertMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? id = _undefined,
    Object? issuerId = _undefined,
    Object? receiverId = _undefined,
  }) =>
      _then(Input$SmithCertMinOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertMinOrderBy<TRes>
    implements CopyWith$Input$SmithCertMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Enum$OrderBy? issuerId,
    Enum$OrderBy? receiverId,
  }) =>
      _res;
}

class Input$SmithCertOrderBy {
  factory Input$SmithCertOrderBy({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
  }) =>
      Input$SmithCertOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
        if (id != null) r'id': id,
        if (issuer != null) r'issuer': issuer,
        if (issuerId != null) r'issuerId': issuerId,
        if (receiver != null) r'receiver': receiver,
        if (receiverId != null) r'receiverId': receiverId,
      });

  Input$SmithCertOrderBy._(this._$data);

  factory Input$SmithCertOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = l$issuer == null
          ? null
          : Input$IdentityOrderBy.fromJson((l$issuer as Map<String, dynamic>));
    }
    if (data.containsKey('issuerId')) {
      final l$issuerId = data['issuerId'];
      result$data['issuerId'] = l$issuerId == null
          ? null
          : fromJson$Enum$OrderBy((l$issuerId as String));
    }
    if (data.containsKey('receiver')) {
      final l$receiver = data['receiver'];
      result$data['receiver'] = l$receiver == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$receiver as Map<String, dynamic>));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$OrderBy((l$receiverId as String));
    }
    return Input$SmithCertOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get issuer =>
      (_$data['issuer'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get issuerId => (_$data['issuerId'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get receiver =>
      (_$data['receiver'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get receiverId => (_$data['receiverId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer?.toJson();
    }
    if (_$data.containsKey('issuerId')) {
      final l$issuerId = issuerId;
      result$data['issuerId'] =
          l$issuerId == null ? null : toJson$Enum$OrderBy(l$issuerId);
    }
    if (_$data.containsKey('receiver')) {
      final l$receiver = receiver;
      result$data['receiver'] = l$receiver?.toJson();
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] =
          l$receiverId == null ? null : toJson$Enum$OrderBy(l$receiverId);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertOrderBy<Input$SmithCertOrderBy> get copyWith =>
      CopyWith$Input$SmithCertOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$issuerId = issuerId;
    final lOther$issuerId = other.issuerId;
    if (_$data.containsKey('issuerId') !=
        other._$data.containsKey('issuerId')) {
      return false;
    }
    if (l$issuerId != lOther$issuerId) {
      return false;
    }
    final l$receiver = receiver;
    final lOther$receiver = other.receiver;
    if (_$data.containsKey('receiver') !=
        other._$data.containsKey('receiver')) {
      return false;
    }
    if (l$receiver != lOther$receiver) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    final l$id = id;
    final l$issuer = issuer;
    final l$issuerId = issuerId;
    final l$receiver = receiver;
    final l$receiverId = receiverId;
    return Object.hashAll([
      _$data.containsKey('createdOn') ? l$createdOn : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('issuer') ? l$issuer : const {},
      _$data.containsKey('issuerId') ? l$issuerId : const {},
      _$data.containsKey('receiver') ? l$receiver : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithCertOrderBy<TRes> {
  factory CopyWith$Input$SmithCertOrderBy(
    Input$SmithCertOrderBy instance,
    TRes Function(Input$SmithCertOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertOrderBy;

  factory CopyWith$Input$SmithCertOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertOrderBy;

  TRes call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
  });
  CopyWith$Input$IdentityOrderBy<TRes> get issuer;
  CopyWith$Input$IdentityOrderBy<TRes> get receiver;
}

class _CopyWithImpl$Input$SmithCertOrderBy<TRes>
    implements CopyWith$Input$SmithCertOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertOrderBy _instance;

  final TRes Function(Input$SmithCertOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdOn = _undefined,
    Object? id = _undefined,
    Object? issuer = _undefined,
    Object? issuerId = _undefined,
    Object? receiver = _undefined,
    Object? receiverId = _undefined,
  }) =>
      _then(Input$SmithCertOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (issuer != _undefined) 'issuer': (issuer as Input$IdentityOrderBy?),
        if (issuerId != _undefined) 'issuerId': (issuerId as Enum$OrderBy?),
        if (receiver != _undefined)
          'receiver': (receiver as Input$IdentityOrderBy?),
        if (receiverId != _undefined)
          'receiverId': (receiverId as Enum$OrderBy?),
      }));

  CopyWith$Input$IdentityOrderBy<TRes> get issuer {
    final local$issuer = _instance.issuer;
    return local$issuer == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(local$issuer, (e) => call(issuer: e));
  }

  CopyWith$Input$IdentityOrderBy<TRes> get receiver {
    final local$receiver = _instance.receiver;
    return local$receiver == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$receiver, (e) => call(receiver: e));
  }
}

class _CopyWithStubImpl$Input$SmithCertOrderBy<TRes>
    implements CopyWith$Input$SmithCertOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? createdOn,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? issuer,
    Enum$OrderBy? issuerId,
    Input$IdentityOrderBy? receiver,
    Enum$OrderBy? receiverId,
  }) =>
      _res;

  CopyWith$Input$IdentityOrderBy<TRes> get issuer =>
      CopyWith$Input$IdentityOrderBy.stub(_res);

  CopyWith$Input$IdentityOrderBy<TRes> get receiver =>
      CopyWith$Input$IdentityOrderBy.stub(_res);
}

class Input$SmithCertStddevOrderBy {
  factory Input$SmithCertStddevOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertStddevOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertStddevOrderBy._(this._$data);

  factory Input$SmithCertStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertStddevOrderBy<Input$SmithCertStddevOrderBy>
      get copyWith => CopyWith$Input$SmithCertStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertStddevOrderBy<TRes> {
  factory CopyWith$Input$SmithCertStddevOrderBy(
    Input$SmithCertStddevOrderBy instance,
    TRes Function(Input$SmithCertStddevOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertStddevOrderBy;

  factory CopyWith$Input$SmithCertStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertStddevOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertStddevOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertStddevOrderBy _instance;

  final TRes Function(Input$SmithCertStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertStddevOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertStddevOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertStddevOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertStddevPopOrderBy {
  factory Input$SmithCertStddevPopOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertStddevPopOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertStddevPopOrderBy._(this._$data);

  factory Input$SmithCertStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertStddevPopOrderBy<Input$SmithCertStddevPopOrderBy>
      get copyWith => CopyWith$Input$SmithCertStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertStddevPopOrderBy<TRes> {
  factory CopyWith$Input$SmithCertStddevPopOrderBy(
    Input$SmithCertStddevPopOrderBy instance,
    TRes Function(Input$SmithCertStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertStddevPopOrderBy;

  factory CopyWith$Input$SmithCertStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertStddevPopOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertStddevPopOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertStddevPopOrderBy _instance;

  final TRes Function(Input$SmithCertStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertStddevPopOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertStddevPopOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertStddevPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertStddevSampOrderBy {
  factory Input$SmithCertStddevSampOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertStddevSampOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertStddevSampOrderBy._(this._$data);

  factory Input$SmithCertStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertStddevSampOrderBy<Input$SmithCertStddevSampOrderBy>
      get copyWith => CopyWith$Input$SmithCertStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertStddevSampOrderBy<TRes> {
  factory CopyWith$Input$SmithCertStddevSampOrderBy(
    Input$SmithCertStddevSampOrderBy instance,
    TRes Function(Input$SmithCertStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertStddevSampOrderBy;

  factory CopyWith$Input$SmithCertStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertStddevSampOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertStddevSampOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertStddevSampOrderBy _instance;

  final TRes Function(Input$SmithCertStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertStddevSampOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertStddevSampOrderBy<TRes>
    implements CopyWith$Input$SmithCertStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertStddevSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertSumOrderBy {
  factory Input$SmithCertSumOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertSumOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertSumOrderBy._(this._$data);

  factory Input$SmithCertSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertSumOrderBy<Input$SmithCertSumOrderBy> get copyWith =>
      CopyWith$Input$SmithCertSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertSumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertSumOrderBy<TRes> {
  factory CopyWith$Input$SmithCertSumOrderBy(
    Input$SmithCertSumOrderBy instance,
    TRes Function(Input$SmithCertSumOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertSumOrderBy;

  factory CopyWith$Input$SmithCertSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertSumOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertSumOrderBy<TRes>
    implements CopyWith$Input$SmithCertSumOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertSumOrderBy _instance;

  final TRes Function(Input$SmithCertSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertSumOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertSumOrderBy<TRes>
    implements CopyWith$Input$SmithCertSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertSumOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertVarianceOrderBy {
  factory Input$SmithCertVarianceOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertVarianceOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertVarianceOrderBy._(this._$data);

  factory Input$SmithCertVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertVarianceOrderBy<Input$SmithCertVarianceOrderBy>
      get copyWith => CopyWith$Input$SmithCertVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertVarianceOrderBy<TRes> {
  factory CopyWith$Input$SmithCertVarianceOrderBy(
    Input$SmithCertVarianceOrderBy instance,
    TRes Function(Input$SmithCertVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertVarianceOrderBy;

  factory CopyWith$Input$SmithCertVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertVarianceOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertVarianceOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertVarianceOrderBy _instance;

  final TRes Function(Input$SmithCertVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertVarianceOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertVarianceOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertVarianceOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertVarPopOrderBy {
  factory Input$SmithCertVarPopOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertVarPopOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertVarPopOrderBy._(this._$data);

  factory Input$SmithCertVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertVarPopOrderBy<Input$SmithCertVarPopOrderBy>
      get copyWith => CopyWith$Input$SmithCertVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertVarPopOrderBy<TRes> {
  factory CopyWith$Input$SmithCertVarPopOrderBy(
    Input$SmithCertVarPopOrderBy instance,
    TRes Function(Input$SmithCertVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertVarPopOrderBy;

  factory CopyWith$Input$SmithCertVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertVarPopOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertVarPopOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertVarPopOrderBy _instance;

  final TRes Function(Input$SmithCertVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertVarPopOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertVarPopOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertVarPopOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithCertVarSampOrderBy {
  factory Input$SmithCertVarSampOrderBy({Enum$OrderBy? createdOn}) =>
      Input$SmithCertVarSampOrderBy._({
        if (createdOn != null) r'createdOn': createdOn,
      });

  Input$SmithCertVarSampOrderBy._(this._$data);

  factory Input$SmithCertVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdOn')) {
      final l$createdOn = data['createdOn'];
      result$data['createdOn'] = l$createdOn == null
          ? null
          : fromJson$Enum$OrderBy((l$createdOn as String));
    }
    return Input$SmithCertVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get createdOn => (_$data['createdOn'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdOn')) {
      final l$createdOn = createdOn;
      result$data['createdOn'] =
          l$createdOn == null ? null : toJson$Enum$OrderBy(l$createdOn);
    }
    return result$data;
  }

  CopyWith$Input$SmithCertVarSampOrderBy<Input$SmithCertVarSampOrderBy>
      get copyWith => CopyWith$Input$SmithCertVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithCertVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdOn = createdOn;
    final lOther$createdOn = other.createdOn;
    if (_$data.containsKey('createdOn') !=
        other._$data.containsKey('createdOn')) {
      return false;
    }
    if (l$createdOn != lOther$createdOn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdOn = createdOn;
    return Object.hashAll(
        [_$data.containsKey('createdOn') ? l$createdOn : const {}]);
  }
}

abstract class CopyWith$Input$SmithCertVarSampOrderBy<TRes> {
  factory CopyWith$Input$SmithCertVarSampOrderBy(
    Input$SmithCertVarSampOrderBy instance,
    TRes Function(Input$SmithCertVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$SmithCertVarSampOrderBy;

  factory CopyWith$Input$SmithCertVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithCertVarSampOrderBy;

  TRes call({Enum$OrderBy? createdOn});
}

class _CopyWithImpl$Input$SmithCertVarSampOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$SmithCertVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$SmithCertVarSampOrderBy _instance;

  final TRes Function(Input$SmithCertVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? createdOn = _undefined}) =>
      _then(Input$SmithCertVarSampOrderBy._({
        ..._instance._$data,
        if (createdOn != _undefined) 'createdOn': (createdOn as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$SmithCertVarSampOrderBy<TRes>
    implements CopyWith$Input$SmithCertVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$SmithCertVarSampOrderBy(this._res);

  TRes _res;

  call({Enum$OrderBy? createdOn}) => _res;
}

class Input$SmithStatusEnumComparisonExp {
  factory Input$SmithStatusEnumComparisonExp({
    Enum$SmithStatusEnum? $_eq,
    List<Enum$SmithStatusEnum>? $_in,
    bool? $_isNull,
    Enum$SmithStatusEnum? $_neq,
    List<Enum$SmithStatusEnum>? $_nin,
  }) =>
      Input$SmithStatusEnumComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$SmithStatusEnumComparisonExp._(this._$data);

  factory Input$SmithStatusEnumComparisonExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = l$$_eq == null
          ? null
          : fromJson$Enum$SmithStatusEnum((l$$_eq as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SmithStatusEnum((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromJson$Enum$SmithStatusEnum((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SmithStatusEnum((e as String)))
          .toList();
    }
    return Input$SmithStatusEnumComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SmithStatusEnum? get $_eq => (_$data['_eq'] as Enum$SmithStatusEnum?);

  List<Enum$SmithStatusEnum>? get $_in =>
      (_$data['_in'] as List<Enum$SmithStatusEnum>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  Enum$SmithStatusEnum? get $_neq => (_$data['_neq'] as Enum$SmithStatusEnum?);

  List<Enum$SmithStatusEnum>? get $_nin =>
      (_$data['_nin'] as List<Enum$SmithStatusEnum>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : toJson$Enum$SmithStatusEnum(l$$_eq);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => toJson$Enum$SmithStatusEnum(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] =
          l$$_neq == null ? null : toJson$Enum$SmithStatusEnum(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => toJson$Enum$SmithStatusEnum(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$SmithStatusEnumComparisonExp<
          Input$SmithStatusEnumComparisonExp>
      get copyWith => CopyWith$Input$SmithStatusEnumComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SmithStatusEnumComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SmithStatusEnumComparisonExp<TRes> {
  factory CopyWith$Input$SmithStatusEnumComparisonExp(
    Input$SmithStatusEnumComparisonExp instance,
    TRes Function(Input$SmithStatusEnumComparisonExp) then,
  ) = _CopyWithImpl$Input$SmithStatusEnumComparisonExp;

  factory CopyWith$Input$SmithStatusEnumComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$SmithStatusEnumComparisonExp;

  TRes call({
    Enum$SmithStatusEnum? $_eq,
    List<Enum$SmithStatusEnum>? $_in,
    bool? $_isNull,
    Enum$SmithStatusEnum? $_neq,
    List<Enum$SmithStatusEnum>? $_nin,
  });
}

class _CopyWithImpl$Input$SmithStatusEnumComparisonExp<TRes>
    implements CopyWith$Input$SmithStatusEnumComparisonExp<TRes> {
  _CopyWithImpl$Input$SmithStatusEnumComparisonExp(
    this._instance,
    this._then,
  );

  final Input$SmithStatusEnumComparisonExp _instance;

  final TRes Function(Input$SmithStatusEnumComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$SmithStatusEnumComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as Enum$SmithStatusEnum?),
        if ($_in != _undefined) '_in': ($_in as List<Enum$SmithStatusEnum>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as Enum$SmithStatusEnum?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Enum$SmithStatusEnum>?),
      }));
}

class _CopyWithStubImpl$Input$SmithStatusEnumComparisonExp<TRes>
    implements CopyWith$Input$SmithStatusEnumComparisonExp<TRes> {
  _CopyWithStubImpl$Input$SmithStatusEnumComparisonExp(this._res);

  TRes _res;

  call({
    Enum$SmithStatusEnum? $_eq,
    List<Enum$SmithStatusEnum>? $_in,
    bool? $_isNull,
    Enum$SmithStatusEnum? $_neq,
    List<Enum$SmithStatusEnum>? $_nin,
  }) =>
      _res;
}

class Input$StringArrayComparisonExp {
  factory Input$StringArrayComparisonExp({
    List<String>? $_containedIn,
    List<String>? $_contains,
    List<String>? $_eq,
    List<String>? $_gt,
    List<String>? $_gte,
    List<List<String>>? $_in,
    bool? $_isNull,
    List<String>? $_lt,
    List<String>? $_lte,
    List<String>? $_neq,
    List<List<String>>? $_nin,
  }) =>
      Input$StringArrayComparisonExp._({
        if ($_containedIn != null) r'_containedIn': $_containedIn,
        if ($_contains != null) r'_contains': $_contains,
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$StringArrayComparisonExp._(this._$data);

  factory Input$StringArrayComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_containedIn')) {
      final l$$_containedIn = data['_containedIn'];
      result$data['_containedIn'] = (l$$_containedIn as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('_contains')) {
      final l$$_contains = data['_contains'];
      result$data['_contains'] =
          (l$$_contains as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] =
          (l$$_eq as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] =
          (l$$_gt as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] =
          (l$$_gte as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => (e as List<dynamic>).map((e) => (e as String)).toList())
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] =
          (l$$_lt as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] =
          (l$$_lte as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] =
          (l$$_neq as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => (e as List<dynamic>).map((e) => (e as String)).toList())
          .toList();
    }
    return Input$StringArrayComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get $_containedIn => (_$data['_containedIn'] as List<String>?);

  List<String>? get $_contains => (_$data['_contains'] as List<String>?);

  List<String>? get $_eq => (_$data['_eq'] as List<String>?);

  List<String>? get $_gt => (_$data['_gt'] as List<String>?);

  List<String>? get $_gte => (_$data['_gte'] as List<String>?);

  List<List<String>>? get $_in => (_$data['_in'] as List<List<String>>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  List<String>? get $_lt => (_$data['_lt'] as List<String>?);

  List<String>? get $_lte => (_$data['_lte'] as List<String>?);

  List<String>? get $_neq => (_$data['_neq'] as List<String>?);

  List<List<String>>? get $_nin => (_$data['_nin'] as List<List<String>>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_containedIn')) {
      final l$$_containedIn = $_containedIn;
      result$data['_containedIn'] = l$$_containedIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('_contains')) {
      final l$$_contains = $_contains;
      result$data['_contains'] = l$$_contains?.map((e) => e).toList();
    }
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq?.map((e) => e).toList();
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt?.map((e) => e).toList();
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte?.map((e) => e).toList();
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => e.map((e) => e).toList()).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt?.map((e) => e).toList();
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte?.map((e) => e).toList();
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq?.map((e) => e).toList();
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => e.map((e) => e).toList()).toList();
    }
    return result$data;
  }

  CopyWith$Input$StringArrayComparisonExp<Input$StringArrayComparisonExp>
      get copyWith => CopyWith$Input$StringArrayComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringArrayComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_containedIn = $_containedIn;
    final lOther$$_containedIn = other.$_containedIn;
    if (_$data.containsKey('_containedIn') !=
        other._$data.containsKey('_containedIn')) {
      return false;
    }
    if (l$$_containedIn != null && lOther$$_containedIn != null) {
      if (l$$_containedIn.length != lOther$$_containedIn.length) {
        return false;
      }
      for (int i = 0; i < l$$_containedIn.length; i++) {
        final l$$_containedIn$entry = l$$_containedIn[i];
        final lOther$$_containedIn$entry = lOther$$_containedIn[i];
        if (l$$_containedIn$entry != lOther$$_containedIn$entry) {
          return false;
        }
      }
    } else if (l$$_containedIn != lOther$$_containedIn) {
      return false;
    }
    final l$$_contains = $_contains;
    final lOther$$_contains = other.$_contains;
    if (_$data.containsKey('_contains') !=
        other._$data.containsKey('_contains')) {
      return false;
    }
    if (l$$_contains != null && lOther$$_contains != null) {
      if (l$$_contains.length != lOther$$_contains.length) {
        return false;
      }
      for (int i = 0; i < l$$_contains.length; i++) {
        final l$$_contains$entry = l$$_contains[i];
        final lOther$$_contains$entry = lOther$$_contains[i];
        if (l$$_contains$entry != lOther$$_contains$entry) {
          return false;
        }
      }
    } else if (l$$_contains != lOther$$_contains) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != null && lOther$$_eq != null) {
      if (l$$_eq.length != lOther$$_eq.length) {
        return false;
      }
      for (int i = 0; i < l$$_eq.length; i++) {
        final l$$_eq$entry = l$$_eq[i];
        final lOther$$_eq$entry = lOther$$_eq[i];
        if (l$$_eq$entry != lOther$$_eq$entry) {
          return false;
        }
      }
    } else if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != null && lOther$$_gt != null) {
      if (l$$_gt.length != lOther$$_gt.length) {
        return false;
      }
      for (int i = 0; i < l$$_gt.length; i++) {
        final l$$_gt$entry = l$$_gt[i];
        final lOther$$_gt$entry = lOther$$_gt[i];
        if (l$$_gt$entry != lOther$$_gt$entry) {
          return false;
        }
      }
    } else if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != null && lOther$$_gte != null) {
      if (l$$_gte.length != lOther$$_gte.length) {
        return false;
      }
      for (int i = 0; i < l$$_gte.length; i++) {
        final l$$_gte$entry = l$$_gte[i];
        final lOther$$_gte$entry = lOther$$_gte[i];
        if (l$$_gte$entry != lOther$$_gte$entry) {
          return false;
        }
      }
    } else if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry.length != lOther$$_in$entry.length) {
          return false;
        }
        for (int i = 0; i < l$$_in$entry.length; i++) {
          final l$$_in$entry$entry = l$$_in$entry[i];
          final lOther$$_in$entry$entry = lOther$$_in$entry[i];
          if (l$$_in$entry$entry != lOther$$_in$entry$entry) {
            return false;
          }
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != null && lOther$$_lt != null) {
      if (l$$_lt.length != lOther$$_lt.length) {
        return false;
      }
      for (int i = 0; i < l$$_lt.length; i++) {
        final l$$_lt$entry = l$$_lt[i];
        final lOther$$_lt$entry = lOther$$_lt[i];
        if (l$$_lt$entry != lOther$$_lt$entry) {
          return false;
        }
      }
    } else if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != null && lOther$$_lte != null) {
      if (l$$_lte.length != lOther$$_lte.length) {
        return false;
      }
      for (int i = 0; i < l$$_lte.length; i++) {
        final l$$_lte$entry = l$$_lte[i];
        final lOther$$_lte$entry = lOther$$_lte[i];
        if (l$$_lte$entry != lOther$$_lte$entry) {
          return false;
        }
      }
    } else if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != null && lOther$$_neq != null) {
      if (l$$_neq.length != lOther$$_neq.length) {
        return false;
      }
      for (int i = 0; i < l$$_neq.length; i++) {
        final l$$_neq$entry = l$$_neq[i];
        final lOther$$_neq$entry = lOther$$_neq[i];
        if (l$$_neq$entry != lOther$$_neq$entry) {
          return false;
        }
      }
    } else if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry.length != lOther$$_nin$entry.length) {
          return false;
        }
        for (int i = 0; i < l$$_nin$entry.length; i++) {
          final l$$_nin$entry$entry = l$$_nin$entry[i];
          final lOther$$_nin$entry$entry = lOther$$_nin$entry[i];
          if (l$$_nin$entry$entry != lOther$$_nin$entry$entry) {
            return false;
          }
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_containedIn = $_containedIn;
    final l$$_contains = $_contains;
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_containedIn')
          ? l$$_containedIn == null
              ? null
              : Object.hashAll(l$$_containedIn.map((v) => v))
          : const {},
      _$data.containsKey('_contains')
          ? l$$_contains == null
              ? null
              : Object.hashAll(l$$_contains.map((v) => v))
          : const {},
      _$data.containsKey('_eq')
          ? l$$_eq == null
              ? null
              : Object.hashAll(l$$_eq.map((v) => v))
          : const {},
      _$data.containsKey('_gt')
          ? l$$_gt == null
              ? null
              : Object.hashAll(l$$_gt.map((v) => v))
          : const {},
      _$data.containsKey('_gte')
          ? l$$_gte == null
              ? null
              : Object.hashAll(l$$_gte.map((v) => v))
          : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(
                  l$$_in.map((v) => Object.hashAll(v.map((v) => v))))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt')
          ? l$$_lt == null
              ? null
              : Object.hashAll(l$$_lt.map((v) => v))
          : const {},
      _$data.containsKey('_lte')
          ? l$$_lte == null
              ? null
              : Object.hashAll(l$$_lte.map((v) => v))
          : const {},
      _$data.containsKey('_neq')
          ? l$$_neq == null
              ? null
              : Object.hashAll(l$$_neq.map((v) => v))
          : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(
                  l$$_nin.map((v) => Object.hashAll(v.map((v) => v))))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringArrayComparisonExp<TRes> {
  factory CopyWith$Input$StringArrayComparisonExp(
    Input$StringArrayComparisonExp instance,
    TRes Function(Input$StringArrayComparisonExp) then,
  ) = _CopyWithImpl$Input$StringArrayComparisonExp;

  factory CopyWith$Input$StringArrayComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$StringArrayComparisonExp;

  TRes call({
    List<String>? $_containedIn,
    List<String>? $_contains,
    List<String>? $_eq,
    List<String>? $_gt,
    List<String>? $_gte,
    List<List<String>>? $_in,
    bool? $_isNull,
    List<String>? $_lt,
    List<String>? $_lte,
    List<String>? $_neq,
    List<List<String>>? $_nin,
  });
}

class _CopyWithImpl$Input$StringArrayComparisonExp<TRes>
    implements CopyWith$Input$StringArrayComparisonExp<TRes> {
  _CopyWithImpl$Input$StringArrayComparisonExp(
    this._instance,
    this._then,
  );

  final Input$StringArrayComparisonExp _instance;

  final TRes Function(Input$StringArrayComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_containedIn = _undefined,
    Object? $_contains = _undefined,
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$StringArrayComparisonExp._({
        ..._instance._$data,
        if ($_containedIn != _undefined)
          '_containedIn': ($_containedIn as List<String>?),
        if ($_contains != _undefined)
          '_contains': ($_contains as List<String>?),
        if ($_eq != _undefined) '_eq': ($_eq as List<String>?),
        if ($_gt != _undefined) '_gt': ($_gt as List<String>?),
        if ($_gte != _undefined) '_gte': ($_gte as List<String>?),
        if ($_in != _undefined) '_in': ($_in as List<List<String>>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as List<String>?),
        if ($_lte != _undefined) '_lte': ($_lte as List<String>?),
        if ($_neq != _undefined) '_neq': ($_neq as List<String>?),
        if ($_nin != _undefined) '_nin': ($_nin as List<List<String>>?),
      }));
}

class _CopyWithStubImpl$Input$StringArrayComparisonExp<TRes>
    implements CopyWith$Input$StringArrayComparisonExp<TRes> {
  _CopyWithStubImpl$Input$StringArrayComparisonExp(this._res);

  TRes _res;

  call({
    List<String>? $_containedIn,
    List<String>? $_contains,
    List<String>? $_eq,
    List<String>? $_gt,
    List<String>? $_gte,
    List<List<String>>? $_in,
    bool? $_isNull,
    List<String>? $_lt,
    List<String>? $_lte,
    List<String>? $_neq,
    List<List<String>>? $_nin,
  }) =>
      _res;
}

class Input$StringComparisonExp {
  factory Input$StringComparisonExp({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      Input$StringComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_ilike != null) r'_ilike': $_ilike,
        if ($_in != null) r'_in': $_in,
        if ($_iregex != null) r'_iregex': $_iregex,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_like != null) r'_like': $_like,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nilike != null) r'_nilike': $_nilike,
        if ($_nin != null) r'_nin': $_nin,
        if ($_niregex != null) r'_niregex': $_niregex,
        if ($_nlike != null) r'_nlike': $_nlike,
        if ($_nregex != null) r'_nregex': $_nregex,
        if ($_nsimilar != null) r'_nsimilar': $_nsimilar,
        if ($_regex != null) r'_regex': $_regex,
        if ($_similar != null) r'_similar': $_similar,
      });

  Input$StringComparisonExp._(this._$data);

  factory Input$StringComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as String?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as String?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as String?);
    }
    if (data.containsKey('_ilike')) {
      final l$$_ilike = data['_ilike'];
      result$data['_ilike'] = (l$$_ilike as String?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_iregex')) {
      final l$$_iregex = data['_iregex'];
      result$data['_iregex'] = (l$$_iregex as String?);
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_like')) {
      final l$$_like = data['_like'];
      result$data['_like'] = (l$$_like as String?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as String?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as String?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as String?);
    }
    if (data.containsKey('_nilike')) {
      final l$$_nilike = data['_nilike'];
      result$data['_nilike'] = (l$$_nilike as String?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_niregex')) {
      final l$$_niregex = data['_niregex'];
      result$data['_niregex'] = (l$$_niregex as String?);
    }
    if (data.containsKey('_nlike')) {
      final l$$_nlike = data['_nlike'];
      result$data['_nlike'] = (l$$_nlike as String?);
    }
    if (data.containsKey('_nregex')) {
      final l$$_nregex = data['_nregex'];
      result$data['_nregex'] = (l$$_nregex as String?);
    }
    if (data.containsKey('_nsimilar')) {
      final l$$_nsimilar = data['_nsimilar'];
      result$data['_nsimilar'] = (l$$_nsimilar as String?);
    }
    if (data.containsKey('_regex')) {
      final l$$_regex = data['_regex'];
      result$data['_regex'] = (l$$_regex as String?);
    }
    if (data.containsKey('_similar')) {
      final l$$_similar = data['_similar'];
      result$data['_similar'] = (l$$_similar as String?);
    }
    return Input$StringComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $_eq => (_$data['_eq'] as String?);

  String? get $_gt => (_$data['_gt'] as String?);

  String? get $_gte => (_$data['_gte'] as String?);

  String? get $_ilike => (_$data['_ilike'] as String?);

  List<String>? get $_in => (_$data['_in'] as List<String>?);

  String? get $_iregex => (_$data['_iregex'] as String?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  String? get $_like => (_$data['_like'] as String?);

  String? get $_lt => (_$data['_lt'] as String?);

  String? get $_lte => (_$data['_lte'] as String?);

  String? get $_neq => (_$data['_neq'] as String?);

  String? get $_nilike => (_$data['_nilike'] as String?);

  List<String>? get $_nin => (_$data['_nin'] as List<String>?);

  String? get $_niregex => (_$data['_niregex'] as String?);

  String? get $_nlike => (_$data['_nlike'] as String?);

  String? get $_nregex => (_$data['_nregex'] as String?);

  String? get $_nsimilar => (_$data['_nsimilar'] as String?);

  String? get $_regex => (_$data['_regex'] as String?);

  String? get $_similar => (_$data['_similar'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_ilike')) {
      final l$$_ilike = $_ilike;
      result$data['_ilike'] = l$$_ilike;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_iregex')) {
      final l$$_iregex = $_iregex;
      result$data['_iregex'] = l$$_iregex;
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_like')) {
      final l$$_like = $_like;
      result$data['_like'] = l$$_like;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nilike')) {
      final l$$_nilike = $_nilike;
      result$data['_nilike'] = l$$_nilike;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('_niregex')) {
      final l$$_niregex = $_niregex;
      result$data['_niregex'] = l$$_niregex;
    }
    if (_$data.containsKey('_nlike')) {
      final l$$_nlike = $_nlike;
      result$data['_nlike'] = l$$_nlike;
    }
    if (_$data.containsKey('_nregex')) {
      final l$$_nregex = $_nregex;
      result$data['_nregex'] = l$$_nregex;
    }
    if (_$data.containsKey('_nsimilar')) {
      final l$$_nsimilar = $_nsimilar;
      result$data['_nsimilar'] = l$$_nsimilar;
    }
    if (_$data.containsKey('_regex')) {
      final l$$_regex = $_regex;
      result$data['_regex'] = l$$_regex;
    }
    if (_$data.containsKey('_similar')) {
      final l$$_similar = $_similar;
      result$data['_similar'] = l$$_similar;
    }
    return result$data;
  }

  CopyWith$Input$StringComparisonExp<Input$StringComparisonExp> get copyWith =>
      CopyWith$Input$StringComparisonExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_ilike = $_ilike;
    final lOther$$_ilike = other.$_ilike;
    if (_$data.containsKey('_ilike') != other._$data.containsKey('_ilike')) {
      return false;
    }
    if (l$$_ilike != lOther$$_ilike) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_iregex = $_iregex;
    final lOther$$_iregex = other.$_iregex;
    if (_$data.containsKey('_iregex') != other._$data.containsKey('_iregex')) {
      return false;
    }
    if (l$$_iregex != lOther$$_iregex) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_like = $_like;
    final lOther$$_like = other.$_like;
    if (_$data.containsKey('_like') != other._$data.containsKey('_like')) {
      return false;
    }
    if (l$$_like != lOther$$_like) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nilike = $_nilike;
    final lOther$$_nilike = other.$_nilike;
    if (_$data.containsKey('_nilike') != other._$data.containsKey('_nilike')) {
      return false;
    }
    if (l$$_nilike != lOther$$_nilike) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    final l$$_niregex = $_niregex;
    final lOther$$_niregex = other.$_niregex;
    if (_$data.containsKey('_niregex') !=
        other._$data.containsKey('_niregex')) {
      return false;
    }
    if (l$$_niregex != lOther$$_niregex) {
      return false;
    }
    final l$$_nlike = $_nlike;
    final lOther$$_nlike = other.$_nlike;
    if (_$data.containsKey('_nlike') != other._$data.containsKey('_nlike')) {
      return false;
    }
    if (l$$_nlike != lOther$$_nlike) {
      return false;
    }
    final l$$_nregex = $_nregex;
    final lOther$$_nregex = other.$_nregex;
    if (_$data.containsKey('_nregex') != other._$data.containsKey('_nregex')) {
      return false;
    }
    if (l$$_nregex != lOther$$_nregex) {
      return false;
    }
    final l$$_nsimilar = $_nsimilar;
    final lOther$$_nsimilar = other.$_nsimilar;
    if (_$data.containsKey('_nsimilar') !=
        other._$data.containsKey('_nsimilar')) {
      return false;
    }
    if (l$$_nsimilar != lOther$$_nsimilar) {
      return false;
    }
    final l$$_regex = $_regex;
    final lOther$$_regex = other.$_regex;
    if (_$data.containsKey('_regex') != other._$data.containsKey('_regex')) {
      return false;
    }
    if (l$$_regex != lOther$$_regex) {
      return false;
    }
    final l$$_similar = $_similar;
    final lOther$$_similar = other.$_similar;
    if (_$data.containsKey('_similar') !=
        other._$data.containsKey('_similar')) {
      return false;
    }
    if (l$$_similar != lOther$$_similar) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_ilike = $_ilike;
    final l$$_in = $_in;
    final l$$_iregex = $_iregex;
    final l$$_isNull = $_isNull;
    final l$$_like = $_like;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nilike = $_nilike;
    final l$$_nin = $_nin;
    final l$$_niregex = $_niregex;
    final l$$_nlike = $_nlike;
    final l$$_nregex = $_nregex;
    final l$$_nsimilar = $_nsimilar;
    final l$$_regex = $_regex;
    final l$$_similar = $_similar;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_ilike') ? l$$_ilike : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_iregex') ? l$$_iregex : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_like') ? l$$_like : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nilike') ? l$$_nilike : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
      _$data.containsKey('_niregex') ? l$$_niregex : const {},
      _$data.containsKey('_nlike') ? l$$_nlike : const {},
      _$data.containsKey('_nregex') ? l$$_nregex : const {},
      _$data.containsKey('_nsimilar') ? l$$_nsimilar : const {},
      _$data.containsKey('_regex') ? l$$_regex : const {},
      _$data.containsKey('_similar') ? l$$_similar : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringComparisonExp<TRes> {
  factory CopyWith$Input$StringComparisonExp(
    Input$StringComparisonExp instance,
    TRes Function(Input$StringComparisonExp) then,
  ) = _CopyWithImpl$Input$StringComparisonExp;

  factory CopyWith$Input$StringComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$StringComparisonExp;

  TRes call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  });
}

class _CopyWithImpl$Input$StringComparisonExp<TRes>
    implements CopyWith$Input$StringComparisonExp<TRes> {
  _CopyWithImpl$Input$StringComparisonExp(
    this._instance,
    this._then,
  );

  final Input$StringComparisonExp _instance;

  final TRes Function(Input$StringComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_ilike = _undefined,
    Object? $_in = _undefined,
    Object? $_iregex = _undefined,
    Object? $_isNull = _undefined,
    Object? $_like = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nilike = _undefined,
    Object? $_nin = _undefined,
    Object? $_niregex = _undefined,
    Object? $_nlike = _undefined,
    Object? $_nregex = _undefined,
    Object? $_nsimilar = _undefined,
    Object? $_regex = _undefined,
    Object? $_similar = _undefined,
  }) =>
      _then(Input$StringComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as String?),
        if ($_gt != _undefined) '_gt': ($_gt as String?),
        if ($_gte != _undefined) '_gte': ($_gte as String?),
        if ($_ilike != _undefined) '_ilike': ($_ilike as String?),
        if ($_in != _undefined) '_in': ($_in as List<String>?),
        if ($_iregex != _undefined) '_iregex': ($_iregex as String?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_like != _undefined) '_like': ($_like as String?),
        if ($_lt != _undefined) '_lt': ($_lt as String?),
        if ($_lte != _undefined) '_lte': ($_lte as String?),
        if ($_neq != _undefined) '_neq': ($_neq as String?),
        if ($_nilike != _undefined) '_nilike': ($_nilike as String?),
        if ($_nin != _undefined) '_nin': ($_nin as List<String>?),
        if ($_niregex != _undefined) '_niregex': ($_niregex as String?),
        if ($_nlike != _undefined) '_nlike': ($_nlike as String?),
        if ($_nregex != _undefined) '_nregex': ($_nregex as String?),
        if ($_nsimilar != _undefined) '_nsimilar': ($_nsimilar as String?),
        if ($_regex != _undefined) '_regex': ($_regex as String?),
        if ($_similar != _undefined) '_similar': ($_similar as String?),
      }));
}

class _CopyWithStubImpl$Input$StringComparisonExp<TRes>
    implements CopyWith$Input$StringComparisonExp<TRes> {
  _CopyWithStubImpl$Input$StringComparisonExp(this._res);

  TRes _res;

  call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      _res;
}

class Input$TimestamptzComparisonExp {
  factory Input$TimestamptzComparisonExp({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  }) =>
      Input$TimestamptzComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  Input$TimestamptzComparisonExp._(this._$data);

  factory Input$TimestamptzComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] =
          l$$_eq == null ? null : DateTime.parse((l$$_eq as String));
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] =
          l$$_gt == null ? null : DateTime.parse((l$$_gt as String));
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] =
          l$$_gte == null ? null : DateTime.parse((l$$_gte as String));
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] =
          l$$_lt == null ? null : DateTime.parse((l$$_lt as String));
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] =
          l$$_lte == null ? null : DateTime.parse((l$$_lte as String));
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] =
          l$$_neq == null ? null : DateTime.parse((l$$_neq as String));
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => DateTime.parse((e as String)))
          .toList();
    }
    return Input$TimestamptzComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get $_eq => (_$data['_eq'] as DateTime?);

  DateTime? get $_gt => (_$data['_gt'] as DateTime?);

  DateTime? get $_gte => (_$data['_gte'] as DateTime?);

  List<DateTime>? get $_in => (_$data['_in'] as List<DateTime>?);

  bool? get $_isNull => (_$data['_isNull'] as bool?);

  DateTime? get $_lt => (_$data['_lt'] as DateTime?);

  DateTime? get $_lte => (_$data['_lte'] as DateTime?);

  DateTime? get $_neq => (_$data['_neq'] as DateTime?);

  List<DateTime>? get $_nin => (_$data['_nin'] as List<DateTime>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq?.toIso8601String();
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt?.toIso8601String();
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte?.toIso8601String();
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e.toIso8601String()).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt?.toIso8601String();
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte?.toIso8601String();
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq?.toIso8601String();
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e.toIso8601String()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TimestamptzComparisonExp<Input$TimestamptzComparisonExp>
      get copyWith => CopyWith$Input$TimestamptzComparisonExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TimestamptzComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TimestamptzComparisonExp<TRes> {
  factory CopyWith$Input$TimestamptzComparisonExp(
    Input$TimestamptzComparisonExp instance,
    TRes Function(Input$TimestamptzComparisonExp) then,
  ) = _CopyWithImpl$Input$TimestamptzComparisonExp;

  factory CopyWith$Input$TimestamptzComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$Input$TimestamptzComparisonExp;

  TRes call({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  });
}

class _CopyWithImpl$Input$TimestamptzComparisonExp<TRes>
    implements CopyWith$Input$TimestamptzComparisonExp<TRes> {
  _CopyWithImpl$Input$TimestamptzComparisonExp(
    this._instance,
    this._then,
  );

  final Input$TimestamptzComparisonExp _instance;

  final TRes Function(Input$TimestamptzComparisonExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(Input$TimestamptzComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as DateTime?),
        if ($_gt != _undefined) '_gt': ($_gt as DateTime?),
        if ($_gte != _undefined) '_gte': ($_gte as DateTime?),
        if ($_in != _undefined) '_in': ($_in as List<DateTime>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as DateTime?),
        if ($_lte != _undefined) '_lte': ($_lte as DateTime?),
        if ($_neq != _undefined) '_neq': ($_neq as DateTime?),
        if ($_nin != _undefined) '_nin': ($_nin as List<DateTime>?),
      }));
}

class _CopyWithStubImpl$Input$TimestamptzComparisonExp<TRes>
    implements CopyWith$Input$TimestamptzComparisonExp<TRes> {
  _CopyWithStubImpl$Input$TimestamptzComparisonExp(this._res);

  TRes _res;

  call({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  }) =>
      _res;
}

class Input$TransferAggregateBoolExp {
  factory Input$TransferAggregateBoolExp(
          {Input$transferAggregateBoolExpCount? count}) =>
      Input$TransferAggregateBoolExp._({
        if (count != null) r'count': count,
      });

  Input$TransferAggregateBoolExp._(this._$data);

  factory Input$TransferAggregateBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$transferAggregateBoolExpCount.fromJson(
              (l$count as Map<String, dynamic>));
    }
    return Input$TransferAggregateBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$transferAggregateBoolExpCount? get count =>
      (_$data['count'] as Input$transferAggregateBoolExpCount?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransferAggregateBoolExp<Input$TransferAggregateBoolExp>
      get copyWith => CopyWith$Input$TransferAggregateBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferAggregateBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    return Object.hashAll([_$data.containsKey('count') ? l$count : const {}]);
  }
}

abstract class CopyWith$Input$TransferAggregateBoolExp<TRes> {
  factory CopyWith$Input$TransferAggregateBoolExp(
    Input$TransferAggregateBoolExp instance,
    TRes Function(Input$TransferAggregateBoolExp) then,
  ) = _CopyWithImpl$Input$TransferAggregateBoolExp;

  factory CopyWith$Input$TransferAggregateBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferAggregateBoolExp;

  TRes call({Input$transferAggregateBoolExpCount? count});
  CopyWith$Input$transferAggregateBoolExpCount<TRes> get count;
}

class _CopyWithImpl$Input$TransferAggregateBoolExp<TRes>
    implements CopyWith$Input$TransferAggregateBoolExp<TRes> {
  _CopyWithImpl$Input$TransferAggregateBoolExp(
    this._instance,
    this._then,
  );

  final Input$TransferAggregateBoolExp _instance;

  final TRes Function(Input$TransferAggregateBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? count = _undefined}) =>
      _then(Input$TransferAggregateBoolExp._({
        ..._instance._$data,
        if (count != _undefined)
          'count': (count as Input$transferAggregateBoolExpCount?),
      }));

  CopyWith$Input$transferAggregateBoolExpCount<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$transferAggregateBoolExpCount.stub(_then(_instance))
        : CopyWith$Input$transferAggregateBoolExpCount(
            local$count, (e) => call(count: e));
  }
}

class _CopyWithStubImpl$Input$TransferAggregateBoolExp<TRes>
    implements CopyWith$Input$TransferAggregateBoolExp<TRes> {
  _CopyWithStubImpl$Input$TransferAggregateBoolExp(this._res);

  TRes _res;

  call({Input$transferAggregateBoolExpCount? count}) => _res;

  CopyWith$Input$transferAggregateBoolExpCount<TRes> get count =>
      CopyWith$Input$transferAggregateBoolExpCount.stub(_res);
}

class Input$transferAggregateBoolExpCount {
  factory Input$transferAggregateBoolExpCount({
    List<Enum$TransferSelectColumn>? arguments,
    bool? distinct,
    Input$TransferBoolExp? filter,
    required Input$IntComparisonExp predicate,
  }) =>
      Input$transferAggregateBoolExpCount._({
        if (arguments != null) r'arguments': arguments,
        if (distinct != null) r'distinct': distinct,
        if (filter != null) r'filter': filter,
        r'predicate': predicate,
      });

  Input$transferAggregateBoolExpCount._(this._$data);

  factory Input$transferAggregateBoolExpCount.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('arguments')) {
      final l$arguments = data['arguments'];
      result$data['arguments'] = (l$arguments as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TransferSelectColumn((e as String)))
          .toList();
    }
    if (data.containsKey('distinct')) {
      final l$distinct = data['distinct'];
      result$data['distinct'] = (l$distinct as bool?);
    }
    if (data.containsKey('filter')) {
      final l$filter = data['filter'];
      result$data['filter'] = l$filter == null
          ? null
          : Input$TransferBoolExp.fromJson((l$filter as Map<String, dynamic>));
    }
    final l$predicate = data['predicate'];
    result$data['predicate'] =
        Input$IntComparisonExp.fromJson((l$predicate as Map<String, dynamic>));
    return Input$transferAggregateBoolExpCount._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$TransferSelectColumn>? get arguments =>
      (_$data['arguments'] as List<Enum$TransferSelectColumn>?);

  bool? get distinct => (_$data['distinct'] as bool?);

  Input$TransferBoolExp? get filter =>
      (_$data['filter'] as Input$TransferBoolExp?);

  Input$IntComparisonExp get predicate =>
      (_$data['predicate'] as Input$IntComparisonExp);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('arguments')) {
      final l$arguments = arguments;
      result$data['arguments'] =
          l$arguments?.map((e) => toJson$Enum$TransferSelectColumn(e)).toList();
    }
    if (_$data.containsKey('distinct')) {
      final l$distinct = distinct;
      result$data['distinct'] = l$distinct;
    }
    if (_$data.containsKey('filter')) {
      final l$filter = filter;
      result$data['filter'] = l$filter?.toJson();
    }
    final l$predicate = predicate;
    result$data['predicate'] = l$predicate.toJson();
    return result$data;
  }

  CopyWith$Input$transferAggregateBoolExpCount<
          Input$transferAggregateBoolExpCount>
      get copyWith => CopyWith$Input$transferAggregateBoolExpCount(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$transferAggregateBoolExpCount) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$arguments = arguments;
    final lOther$arguments = other.arguments;
    if (_$data.containsKey('arguments') !=
        other._$data.containsKey('arguments')) {
      return false;
    }
    if (l$arguments != null && lOther$arguments != null) {
      if (l$arguments.length != lOther$arguments.length) {
        return false;
      }
      for (int i = 0; i < l$arguments.length; i++) {
        final l$arguments$entry = l$arguments[i];
        final lOther$arguments$entry = lOther$arguments[i];
        if (l$arguments$entry != lOther$arguments$entry) {
          return false;
        }
      }
    } else if (l$arguments != lOther$arguments) {
      return false;
    }
    final l$distinct = distinct;
    final lOther$distinct = other.distinct;
    if (_$data.containsKey('distinct') !=
        other._$data.containsKey('distinct')) {
      return false;
    }
    if (l$distinct != lOther$distinct) {
      return false;
    }
    final l$filter = filter;
    final lOther$filter = other.filter;
    if (_$data.containsKey('filter') != other._$data.containsKey('filter')) {
      return false;
    }
    if (l$filter != lOther$filter) {
      return false;
    }
    final l$predicate = predicate;
    final lOther$predicate = other.predicate;
    if (l$predicate != lOther$predicate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$arguments = arguments;
    final l$distinct = distinct;
    final l$filter = filter;
    final l$predicate = predicate;
    return Object.hashAll([
      _$data.containsKey('arguments')
          ? l$arguments == null
              ? null
              : Object.hashAll(l$arguments.map((v) => v))
          : const {},
      _$data.containsKey('distinct') ? l$distinct : const {},
      _$data.containsKey('filter') ? l$filter : const {},
      l$predicate,
    ]);
  }
}

abstract class CopyWith$Input$transferAggregateBoolExpCount<TRes> {
  factory CopyWith$Input$transferAggregateBoolExpCount(
    Input$transferAggregateBoolExpCount instance,
    TRes Function(Input$transferAggregateBoolExpCount) then,
  ) = _CopyWithImpl$Input$transferAggregateBoolExpCount;

  factory CopyWith$Input$transferAggregateBoolExpCount.stub(TRes res) =
      _CopyWithStubImpl$Input$transferAggregateBoolExpCount;

  TRes call({
    List<Enum$TransferSelectColumn>? arguments,
    bool? distinct,
    Input$TransferBoolExp? filter,
    Input$IntComparisonExp? predicate,
  });
  CopyWith$Input$TransferBoolExp<TRes> get filter;
  CopyWith$Input$IntComparisonExp<TRes> get predicate;
}

class _CopyWithImpl$Input$transferAggregateBoolExpCount<TRes>
    implements CopyWith$Input$transferAggregateBoolExpCount<TRes> {
  _CopyWithImpl$Input$transferAggregateBoolExpCount(
    this._instance,
    this._then,
  );

  final Input$transferAggregateBoolExpCount _instance;

  final TRes Function(Input$transferAggregateBoolExpCount) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? arguments = _undefined,
    Object? distinct = _undefined,
    Object? filter = _undefined,
    Object? predicate = _undefined,
  }) =>
      _then(Input$transferAggregateBoolExpCount._({
        ..._instance._$data,
        if (arguments != _undefined)
          'arguments': (arguments as List<Enum$TransferSelectColumn>?),
        if (distinct != _undefined) 'distinct': (distinct as bool?),
        if (filter != _undefined) 'filter': (filter as Input$TransferBoolExp?),
        if (predicate != _undefined && predicate != null)
          'predicate': (predicate as Input$IntComparisonExp),
      }));

  CopyWith$Input$TransferBoolExp<TRes> get filter {
    final local$filter = _instance.filter;
    return local$filter == null
        ? CopyWith$Input$TransferBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferBoolExp(local$filter, (e) => call(filter: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get predicate {
    final local$predicate = _instance.predicate;
    return CopyWith$Input$IntComparisonExp(
        local$predicate, (e) => call(predicate: e));
  }
}

class _CopyWithStubImpl$Input$transferAggregateBoolExpCount<TRes>
    implements CopyWith$Input$transferAggregateBoolExpCount<TRes> {
  _CopyWithStubImpl$Input$transferAggregateBoolExpCount(this._res);

  TRes _res;

  call({
    List<Enum$TransferSelectColumn>? arguments,
    bool? distinct,
    Input$TransferBoolExp? filter,
    Input$IntComparisonExp? predicate,
  }) =>
      _res;

  CopyWith$Input$TransferBoolExp<TRes> get filter =>
      CopyWith$Input$TransferBoolExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get predicate =>
      CopyWith$Input$IntComparisonExp.stub(_res);
}

class Input$TransferAggregateOrderBy {
  factory Input$TransferAggregateOrderBy({
    Input$TransferAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$TransferMaxOrderBy? max,
    Input$TransferMinOrderBy? min,
    Input$TransferStddevOrderBy? stddev,
    Input$TransferStddevPopOrderBy? stddevPop,
    Input$TransferStddevSampOrderBy? stddevSamp,
    Input$TransferSumOrderBy? sum,
    Input$TransferVarPopOrderBy? varPop,
    Input$TransferVarSampOrderBy? varSamp,
    Input$TransferVarianceOrderBy? variance,
  }) =>
      Input$TransferAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$TransferAggregateOrderBy._(this._$data);

  factory Input$TransferAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$TransferAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$TransferMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$TransferMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$TransferStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$TransferStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$TransferStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$TransferSumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$TransferVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$TransferVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$TransferVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$TransferAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransferAvgOrderBy? get avg =>
      (_$data['avg'] as Input$TransferAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$TransferMaxOrderBy? get max =>
      (_$data['max'] as Input$TransferMaxOrderBy?);

  Input$TransferMinOrderBy? get min =>
      (_$data['min'] as Input$TransferMinOrderBy?);

  Input$TransferStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$TransferStddevOrderBy?);

  Input$TransferStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$TransferStddevPopOrderBy?);

  Input$TransferStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$TransferStddevSampOrderBy?);

  Input$TransferSumOrderBy? get sum =>
      (_$data['sum'] as Input$TransferSumOrderBy?);

  Input$TransferVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$TransferVarPopOrderBy?);

  Input$TransferVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$TransferVarSampOrderBy?);

  Input$TransferVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$TransferVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransferAggregateOrderBy<Input$TransferAggregateOrderBy>
      get copyWith => CopyWith$Input$TransferAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferAggregateOrderBy<TRes> {
  factory CopyWith$Input$TransferAggregateOrderBy(
    Input$TransferAggregateOrderBy instance,
    TRes Function(Input$TransferAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$TransferAggregateOrderBy;

  factory CopyWith$Input$TransferAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferAggregateOrderBy;

  TRes call({
    Input$TransferAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$TransferMaxOrderBy? max,
    Input$TransferMinOrderBy? min,
    Input$TransferStddevOrderBy? stddev,
    Input$TransferStddevPopOrderBy? stddevPop,
    Input$TransferStddevSampOrderBy? stddevSamp,
    Input$TransferSumOrderBy? sum,
    Input$TransferVarPopOrderBy? varPop,
    Input$TransferVarSampOrderBy? varSamp,
    Input$TransferVarianceOrderBy? variance,
  });
  CopyWith$Input$TransferAvgOrderBy<TRes> get avg;
  CopyWith$Input$TransferMaxOrderBy<TRes> get max;
  CopyWith$Input$TransferMinOrderBy<TRes> get min;
  CopyWith$Input$TransferStddevOrderBy<TRes> get stddev;
  CopyWith$Input$TransferStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$TransferStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$TransferSumOrderBy<TRes> get sum;
  CopyWith$Input$TransferVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$TransferVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$TransferVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$TransferAggregateOrderBy<TRes>
    implements CopyWith$Input$TransferAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$TransferAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferAggregateOrderBy _instance;

  final TRes Function(Input$TransferAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$TransferAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$TransferAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$TransferMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$TransferMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$TransferStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$TransferStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$TransferStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$TransferSumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$TransferVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$TransferVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$TransferVarianceOrderBy?),
      }));

  CopyWith$Input$TransferAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$TransferAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$TransferMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$TransferMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$TransferMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$TransferMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$TransferStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$TransferStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$TransferStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$TransferStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$TransferStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$TransferStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$TransferSumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$TransferSumOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferSumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$TransferVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$TransferVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$TransferVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$TransferVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$TransferVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$TransferVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$TransferVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$TransferAggregateOrderBy<TRes>
    implements CopyWith$Input$TransferAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$TransferAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$TransferMaxOrderBy? max,
    Input$TransferMinOrderBy? min,
    Input$TransferStddevOrderBy? stddev,
    Input$TransferStddevPopOrderBy? stddevPop,
    Input$TransferStddevSampOrderBy? stddevSamp,
    Input$TransferSumOrderBy? sum,
    Input$TransferVarPopOrderBy? varPop,
    Input$TransferVarSampOrderBy? varSamp,
    Input$TransferVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$TransferAvgOrderBy<TRes> get avg =>
      CopyWith$Input$TransferAvgOrderBy.stub(_res);

  CopyWith$Input$TransferMaxOrderBy<TRes> get max =>
      CopyWith$Input$TransferMaxOrderBy.stub(_res);

  CopyWith$Input$TransferMinOrderBy<TRes> get min =>
      CopyWith$Input$TransferMinOrderBy.stub(_res);

  CopyWith$Input$TransferStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$TransferStddevOrderBy.stub(_res);

  CopyWith$Input$TransferStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$TransferStddevPopOrderBy.stub(_res);

  CopyWith$Input$TransferStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$TransferStddevSampOrderBy.stub(_res);

  CopyWith$Input$TransferSumOrderBy<TRes> get sum =>
      CopyWith$Input$TransferSumOrderBy.stub(_res);

  CopyWith$Input$TransferVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$TransferVarPopOrderBy.stub(_res);

  CopyWith$Input$TransferVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$TransferVarSampOrderBy.stub(_res);

  CopyWith$Input$TransferVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$TransferVarianceOrderBy.stub(_res);
}

class Input$TransferAvgOrderBy {
  factory Input$TransferAvgOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferAvgOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferAvgOrderBy._(this._$data);

  factory Input$TransferAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferAvgOrderBy<Input$TransferAvgOrderBy> get copyWith =>
      CopyWith$Input$TransferAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferAvgOrderBy<TRes> {
  factory CopyWith$Input$TransferAvgOrderBy(
    Input$TransferAvgOrderBy instance,
    TRes Function(Input$TransferAvgOrderBy) then,
  ) = _CopyWithImpl$Input$TransferAvgOrderBy;

  factory CopyWith$Input$TransferAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferAvgOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferAvgOrderBy<TRes>
    implements CopyWith$Input$TransferAvgOrderBy<TRes> {
  _CopyWithImpl$Input$TransferAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferAvgOrderBy _instance;

  final TRes Function(Input$TransferAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferAvgOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferAvgOrderBy<TRes>
    implements CopyWith$Input$TransferAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferAvgOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferBoolExp {
  factory Input$TransferBoolExp({
    List<Input$TransferBoolExp>? $_and,
    Input$TransferBoolExp? $_not,
    List<Input$TransferBoolExp>? $_or,
    Input$NumericComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? comment,
    Input$AccountBoolExp? from,
    Input$StringComparisonExp? fromId,
    Input$StringComparisonExp? id,
    Input$TimestamptzComparisonExp? timestamp,
    Input$AccountBoolExp? to,
    Input$StringComparisonExp? toId,
  }) =>
      Input$TransferBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (comment != null) r'comment': comment,
        if (from != null) r'from': from,
        if (fromId != null) r'fromId': fromId,
        if (id != null) r'id': id,
        if (timestamp != null) r'timestamp': timestamp,
        if (to != null) r'to': to,
        if (toId != null) r'toId': toId,
      });

  Input$TransferBoolExp._(this._$data);

  factory Input$TransferBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$TransferBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$TransferBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$TransferBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$NumericComparisonExp.fromJson(
              (l$amount as Map<String, dynamic>));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = l$comment == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$comment as Map<String, dynamic>));
    }
    if (data.containsKey('from')) {
      final l$from = data['from'];
      result$data['from'] = l$from == null
          ? null
          : Input$AccountBoolExp.fromJson((l$from as Map<String, dynamic>));
    }
    if (data.containsKey('fromId')) {
      final l$fromId = data['fromId'];
      result$data['fromId'] = l$fromId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$fromId as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : Input$TimestamptzComparisonExp.fromJson(
              (l$timestamp as Map<String, dynamic>));
    }
    if (data.containsKey('to')) {
      final l$to = data['to'];
      result$data['to'] = l$to == null
          ? null
          : Input$AccountBoolExp.fromJson((l$to as Map<String, dynamic>));
    }
    if (data.containsKey('toId')) {
      final l$toId = data['toId'];
      result$data['toId'] = l$toId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$toId as Map<String, dynamic>));
    }
    return Input$TransferBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransferBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$TransferBoolExp>?);

  Input$TransferBoolExp? get $_not =>
      (_$data['_not'] as Input$TransferBoolExp?);

  List<Input$TransferBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$TransferBoolExp>?);

  Input$NumericComparisonExp? get amount =>
      (_$data['amount'] as Input$NumericComparisonExp?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get comment =>
      (_$data['comment'] as Input$StringComparisonExp?);

  Input$AccountBoolExp? get from => (_$data['from'] as Input$AccountBoolExp?);

  Input$StringComparisonExp? get fromId =>
      (_$data['fromId'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$TimestamptzComparisonExp? get timestamp =>
      (_$data['timestamp'] as Input$TimestamptzComparisonExp?);

  Input$AccountBoolExp? get to => (_$data['to'] as Input$AccountBoolExp?);

  Input$StringComparisonExp? get toId =>
      (_$data['toId'] as Input$StringComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment?.toJson();
    }
    if (_$data.containsKey('from')) {
      final l$from = from;
      result$data['from'] = l$from?.toJson();
    }
    if (_$data.containsKey('fromId')) {
      final l$fromId = fromId;
      result$data['fromId'] = l$fromId?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] = l$timestamp?.toJson();
    }
    if (_$data.containsKey('to')) {
      final l$to = to;
      result$data['to'] = l$to?.toJson();
    }
    if (_$data.containsKey('toId')) {
      final l$toId = toId;
      result$data['toId'] = l$toId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransferBoolExp<Input$TransferBoolExp> get copyWith =>
      CopyWith$Input$TransferBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$from = from;
    final lOther$from = other.from;
    if (_$data.containsKey('from') != other._$data.containsKey('from')) {
      return false;
    }
    if (l$from != lOther$from) {
      return false;
    }
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (_$data.containsKey('fromId') != other._$data.containsKey('fromId')) {
      return false;
    }
    if (l$fromId != lOther$fromId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$to = to;
    final lOther$to = other.to;
    if (_$data.containsKey('to') != other._$data.containsKey('to')) {
      return false;
    }
    if (l$to != lOther$to) {
      return false;
    }
    final l$toId = toId;
    final lOther$toId = other.toId;
    if (_$data.containsKey('toId') != other._$data.containsKey('toId')) {
      return false;
    }
    if (l$toId != lOther$toId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$comment = comment;
    final l$from = from;
    final l$fromId = fromId;
    final l$id = id;
    final l$timestamp = timestamp;
    final l$to = to;
    final l$toId = toId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('from') ? l$from : const {},
      _$data.containsKey('fromId') ? l$fromId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('to') ? l$to : const {},
      _$data.containsKey('toId') ? l$toId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferBoolExp<TRes> {
  factory CopyWith$Input$TransferBoolExp(
    Input$TransferBoolExp instance,
    TRes Function(Input$TransferBoolExp) then,
  ) = _CopyWithImpl$Input$TransferBoolExp;

  factory CopyWith$Input$TransferBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferBoolExp;

  TRes call({
    List<Input$TransferBoolExp>? $_and,
    Input$TransferBoolExp? $_not,
    List<Input$TransferBoolExp>? $_or,
    Input$NumericComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? comment,
    Input$AccountBoolExp? from,
    Input$StringComparisonExp? fromId,
    Input$StringComparisonExp? id,
    Input$TimestamptzComparisonExp? timestamp,
    Input$AccountBoolExp? to,
    Input$StringComparisonExp? toId,
  });
  TRes $_and(
      Iterable<Input$TransferBoolExp>? Function(
              Iterable<CopyWith$Input$TransferBoolExp<Input$TransferBoolExp>>?)
          _fn);
  CopyWith$Input$TransferBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$TransferBoolExp>? Function(
              Iterable<CopyWith$Input$TransferBoolExp<Input$TransferBoolExp>>?)
          _fn);
  CopyWith$Input$NumericComparisonExp<TRes> get amount;
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$StringComparisonExp<TRes> get comment;
  CopyWith$Input$AccountBoolExp<TRes> get from;
  CopyWith$Input$StringComparisonExp<TRes> get fromId;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp;
  CopyWith$Input$AccountBoolExp<TRes> get to;
  CopyWith$Input$StringComparisonExp<TRes> get toId;
}

class _CopyWithImpl$Input$TransferBoolExp<TRes>
    implements CopyWith$Input$TransferBoolExp<TRes> {
  _CopyWithImpl$Input$TransferBoolExp(
    this._instance,
    this._then,
  );

  final Input$TransferBoolExp _instance;

  final TRes Function(Input$TransferBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? comment = _undefined,
    Object? from = _undefined,
    Object? fromId = _undefined,
    Object? id = _undefined,
    Object? timestamp = _undefined,
    Object? to = _undefined,
    Object? toId = _undefined,
  }) =>
      _then(Input$TransferBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$TransferBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$TransferBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$TransferBoolExp>?),
        if (amount != _undefined)
          'amount': (amount as Input$NumericComparisonExp?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (comment != _undefined)
          'comment': (comment as Input$StringComparisonExp?),
        if (from != _undefined) 'from': (from as Input$AccountBoolExp?),
        if (fromId != _undefined)
          'fromId': (fromId as Input$StringComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (timestamp != _undefined)
          'timestamp': (timestamp as Input$TimestamptzComparisonExp?),
        if (to != _undefined) 'to': (to as Input$AccountBoolExp?),
        if (toId != _undefined) 'toId': (toId as Input$StringComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$TransferBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$TransferBoolExp<Input$TransferBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$TransferBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$TransferBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$TransferBoolExp.stub(_then(_instance))
        : CopyWith$Input$TransferBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$TransferBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$TransferBoolExp<Input$TransferBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$TransferBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$NumericComparisonExp<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$NumericComparisonExp.stub(_then(_instance))
        : CopyWith$Input$NumericComparisonExp(
            local$amount, (e) => call(amount: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get comment {
    final local$comment = _instance.comment;
    return local$comment == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$comment, (e) => call(comment: e));
  }

  CopyWith$Input$AccountBoolExp<TRes> get from {
    final local$from = _instance.from;
    return local$from == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$from, (e) => call(from: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get fromId {
    final local$fromId = _instance.fromId;
    return local$fromId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$fromId, (e) => call(fromId: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp {
    final local$timestamp = _instance.timestamp;
    return local$timestamp == null
        ? CopyWith$Input$TimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$Input$TimestamptzComparisonExp(
            local$timestamp, (e) => call(timestamp: e));
  }

  CopyWith$Input$AccountBoolExp<TRes> get to {
    final local$to = _instance.to;
    return local$to == null
        ? CopyWith$Input$AccountBoolExp.stub(_then(_instance))
        : CopyWith$Input$AccountBoolExp(local$to, (e) => call(to: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get toId {
    final local$toId = _instance.toId;
    return local$toId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$toId, (e) => call(toId: e));
  }
}

class _CopyWithStubImpl$Input$TransferBoolExp<TRes>
    implements CopyWith$Input$TransferBoolExp<TRes> {
  _CopyWithStubImpl$Input$TransferBoolExp(this._res);

  TRes _res;

  call({
    List<Input$TransferBoolExp>? $_and,
    Input$TransferBoolExp? $_not,
    List<Input$TransferBoolExp>? $_or,
    Input$NumericComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? comment,
    Input$AccountBoolExp? from,
    Input$StringComparisonExp? fromId,
    Input$StringComparisonExp? id,
    Input$TimestamptzComparisonExp? timestamp,
    Input$AccountBoolExp? to,
    Input$StringComparisonExp? toId,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$TransferBoolExp<TRes> get $_not =>
      CopyWith$Input$TransferBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$NumericComparisonExp<TRes> get amount =>
      CopyWith$Input$NumericComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get comment =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$AccountBoolExp<TRes> get from =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get fromId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp =>
      CopyWith$Input$TimestamptzComparisonExp.stub(_res);

  CopyWith$Input$AccountBoolExp<TRes> get to =>
      CopyWith$Input$AccountBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get toId =>
      CopyWith$Input$StringComparisonExp.stub(_res);
}

class Input$TransferMaxOrderBy {
  factory Input$TransferMaxOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  }) =>
      Input$TransferMaxOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (comment != null) r'comment': comment,
        if (fromId != null) r'fromId': fromId,
        if (id != null) r'id': id,
        if (timestamp != null) r'timestamp': timestamp,
        if (toId != null) r'toId': toId,
      });

  Input$TransferMaxOrderBy._(this._$data);

  factory Input$TransferMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = l$comment == null
          ? null
          : fromJson$Enum$OrderBy((l$comment as String));
    }
    if (data.containsKey('fromId')) {
      final l$fromId = data['fromId'];
      result$data['fromId'] =
          l$fromId == null ? null : fromJson$Enum$OrderBy((l$fromId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    if (data.containsKey('toId')) {
      final l$toId = data['toId'];
      result$data['toId'] =
          l$toId == null ? null : fromJson$Enum$OrderBy((l$toId as String));
    }
    return Input$TransferMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get comment => (_$data['comment'] as Enum$OrderBy?);

  Enum$OrderBy? get fromId => (_$data['fromId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Enum$OrderBy? get toId => (_$data['toId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] =
          l$comment == null ? null : toJson$Enum$OrderBy(l$comment);
    }
    if (_$data.containsKey('fromId')) {
      final l$fromId = fromId;
      result$data['fromId'] =
          l$fromId == null ? null : toJson$Enum$OrderBy(l$fromId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    if (_$data.containsKey('toId')) {
      final l$toId = toId;
      result$data['toId'] = l$toId == null ? null : toJson$Enum$OrderBy(l$toId);
    }
    return result$data;
  }

  CopyWith$Input$TransferMaxOrderBy<Input$TransferMaxOrderBy> get copyWith =>
      CopyWith$Input$TransferMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (_$data.containsKey('fromId') != other._$data.containsKey('fromId')) {
      return false;
    }
    if (l$fromId != lOther$fromId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$toId = toId;
    final lOther$toId = other.toId;
    if (_$data.containsKey('toId') != other._$data.containsKey('toId')) {
      return false;
    }
    if (l$toId != lOther$toId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$comment = comment;
    final l$fromId = fromId;
    final l$id = id;
    final l$timestamp = timestamp;
    final l$toId = toId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('fromId') ? l$fromId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('toId') ? l$toId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferMaxOrderBy<TRes> {
  factory CopyWith$Input$TransferMaxOrderBy(
    Input$TransferMaxOrderBy instance,
    TRes Function(Input$TransferMaxOrderBy) then,
  ) = _CopyWithImpl$Input$TransferMaxOrderBy;

  factory CopyWith$Input$TransferMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferMaxOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  });
}

class _CopyWithImpl$Input$TransferMaxOrderBy<TRes>
    implements CopyWith$Input$TransferMaxOrderBy<TRes> {
  _CopyWithImpl$Input$TransferMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferMaxOrderBy _instance;

  final TRes Function(Input$TransferMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? comment = _undefined,
    Object? fromId = _undefined,
    Object? id = _undefined,
    Object? timestamp = _undefined,
    Object? toId = _undefined,
  }) =>
      _then(Input$TransferMaxOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (comment != _undefined) 'comment': (comment as Enum$OrderBy?),
        if (fromId != _undefined) 'fromId': (fromId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
        if (toId != _undefined) 'toId': (toId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferMaxOrderBy<TRes>
    implements CopyWith$Input$TransferMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  }) =>
      _res;
}

class Input$TransferMinOrderBy {
  factory Input$TransferMinOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  }) =>
      Input$TransferMinOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (comment != null) r'comment': comment,
        if (fromId != null) r'fromId': fromId,
        if (id != null) r'id': id,
        if (timestamp != null) r'timestamp': timestamp,
        if (toId != null) r'toId': toId,
      });

  Input$TransferMinOrderBy._(this._$data);

  factory Input$TransferMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = l$comment == null
          ? null
          : fromJson$Enum$OrderBy((l$comment as String));
    }
    if (data.containsKey('fromId')) {
      final l$fromId = data['fromId'];
      result$data['fromId'] =
          l$fromId == null ? null : fromJson$Enum$OrderBy((l$fromId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    if (data.containsKey('toId')) {
      final l$toId = data['toId'];
      result$data['toId'] =
          l$toId == null ? null : fromJson$Enum$OrderBy((l$toId as String));
    }
    return Input$TransferMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get comment => (_$data['comment'] as Enum$OrderBy?);

  Enum$OrderBy? get fromId => (_$data['fromId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Enum$OrderBy? get toId => (_$data['toId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] =
          l$comment == null ? null : toJson$Enum$OrderBy(l$comment);
    }
    if (_$data.containsKey('fromId')) {
      final l$fromId = fromId;
      result$data['fromId'] =
          l$fromId == null ? null : toJson$Enum$OrderBy(l$fromId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    if (_$data.containsKey('toId')) {
      final l$toId = toId;
      result$data['toId'] = l$toId == null ? null : toJson$Enum$OrderBy(l$toId);
    }
    return result$data;
  }

  CopyWith$Input$TransferMinOrderBy<Input$TransferMinOrderBy> get copyWith =>
      CopyWith$Input$TransferMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (_$data.containsKey('fromId') != other._$data.containsKey('fromId')) {
      return false;
    }
    if (l$fromId != lOther$fromId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$toId = toId;
    final lOther$toId = other.toId;
    if (_$data.containsKey('toId') != other._$data.containsKey('toId')) {
      return false;
    }
    if (l$toId != lOther$toId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$comment = comment;
    final l$fromId = fromId;
    final l$id = id;
    final l$timestamp = timestamp;
    final l$toId = toId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('fromId') ? l$fromId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('toId') ? l$toId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferMinOrderBy<TRes> {
  factory CopyWith$Input$TransferMinOrderBy(
    Input$TransferMinOrderBy instance,
    TRes Function(Input$TransferMinOrderBy) then,
  ) = _CopyWithImpl$Input$TransferMinOrderBy;

  factory CopyWith$Input$TransferMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferMinOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  });
}

class _CopyWithImpl$Input$TransferMinOrderBy<TRes>
    implements CopyWith$Input$TransferMinOrderBy<TRes> {
  _CopyWithImpl$Input$TransferMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferMinOrderBy _instance;

  final TRes Function(Input$TransferMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? comment = _undefined,
    Object? fromId = _undefined,
    Object? id = _undefined,
    Object? timestamp = _undefined,
    Object? toId = _undefined,
  }) =>
      _then(Input$TransferMinOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (comment != _undefined) 'comment': (comment as Enum$OrderBy?),
        if (fromId != _undefined) 'fromId': (fromId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
        if (toId != _undefined) 'toId': (toId as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferMinOrderBy<TRes>
    implements CopyWith$Input$TransferMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Enum$OrderBy? toId,
  }) =>
      _res;
}

class Input$TransferOrderBy {
  factory Input$TransferOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Input$AccountOrderBy? from,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Input$AccountOrderBy? to,
    Enum$OrderBy? toId,
  }) =>
      Input$TransferOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (comment != null) r'comment': comment,
        if (from != null) r'from': from,
        if (fromId != null) r'fromId': fromId,
        if (id != null) r'id': id,
        if (timestamp != null) r'timestamp': timestamp,
        if (to != null) r'to': to,
        if (toId != null) r'toId': toId,
      });

  Input$TransferOrderBy._(this._$data);

  factory Input$TransferOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = l$comment == null
          ? null
          : fromJson$Enum$OrderBy((l$comment as String));
    }
    if (data.containsKey('from')) {
      final l$from = data['from'];
      result$data['from'] = l$from == null
          ? null
          : Input$AccountOrderBy.fromJson((l$from as Map<String, dynamic>));
    }
    if (data.containsKey('fromId')) {
      final l$fromId = data['fromId'];
      result$data['fromId'] =
          l$fromId == null ? null : fromJson$Enum$OrderBy((l$fromId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    if (data.containsKey('to')) {
      final l$to = data['to'];
      result$data['to'] = l$to == null
          ? null
          : Input$AccountOrderBy.fromJson((l$to as Map<String, dynamic>));
    }
    if (data.containsKey('toId')) {
      final l$toId = data['toId'];
      result$data['toId'] =
          l$toId == null ? null : fromJson$Enum$OrderBy((l$toId as String));
    }
    return Input$TransferOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get comment => (_$data['comment'] as Enum$OrderBy?);

  Input$AccountOrderBy? get from => (_$data['from'] as Input$AccountOrderBy?);

  Enum$OrderBy? get fromId => (_$data['fromId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Input$AccountOrderBy? get to => (_$data['to'] as Input$AccountOrderBy?);

  Enum$OrderBy? get toId => (_$data['toId'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] =
          l$comment == null ? null : toJson$Enum$OrderBy(l$comment);
    }
    if (_$data.containsKey('from')) {
      final l$from = from;
      result$data['from'] = l$from?.toJson();
    }
    if (_$data.containsKey('fromId')) {
      final l$fromId = fromId;
      result$data['fromId'] =
          l$fromId == null ? null : toJson$Enum$OrderBy(l$fromId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    if (_$data.containsKey('to')) {
      final l$to = to;
      result$data['to'] = l$to?.toJson();
    }
    if (_$data.containsKey('toId')) {
      final l$toId = toId;
      result$data['toId'] = l$toId == null ? null : toJson$Enum$OrderBy(l$toId);
    }
    return result$data;
  }

  CopyWith$Input$TransferOrderBy<Input$TransferOrderBy> get copyWith =>
      CopyWith$Input$TransferOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$from = from;
    final lOther$from = other.from;
    if (_$data.containsKey('from') != other._$data.containsKey('from')) {
      return false;
    }
    if (l$from != lOther$from) {
      return false;
    }
    final l$fromId = fromId;
    final lOther$fromId = other.fromId;
    if (_$data.containsKey('fromId') != other._$data.containsKey('fromId')) {
      return false;
    }
    if (l$fromId != lOther$fromId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    final l$to = to;
    final lOther$to = other.to;
    if (_$data.containsKey('to') != other._$data.containsKey('to')) {
      return false;
    }
    if (l$to != lOther$to) {
      return false;
    }
    final l$toId = toId;
    final lOther$toId = other.toId;
    if (_$data.containsKey('toId') != other._$data.containsKey('toId')) {
      return false;
    }
    if (l$toId != lOther$toId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$comment = comment;
    final l$from = from;
    final l$fromId = fromId;
    final l$id = id;
    final l$timestamp = timestamp;
    final l$to = to;
    final l$toId = toId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('from') ? l$from : const {},
      _$data.containsKey('fromId') ? l$fromId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
      _$data.containsKey('to') ? l$to : const {},
      _$data.containsKey('toId') ? l$toId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferOrderBy<TRes> {
  factory CopyWith$Input$TransferOrderBy(
    Input$TransferOrderBy instance,
    TRes Function(Input$TransferOrderBy) then,
  ) = _CopyWithImpl$Input$TransferOrderBy;

  factory CopyWith$Input$TransferOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Input$AccountOrderBy? from,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Input$AccountOrderBy? to,
    Enum$OrderBy? toId,
  });
  CopyWith$Input$AccountOrderBy<TRes> get from;
  CopyWith$Input$AccountOrderBy<TRes> get to;
}

class _CopyWithImpl$Input$TransferOrderBy<TRes>
    implements CopyWith$Input$TransferOrderBy<TRes> {
  _CopyWithImpl$Input$TransferOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferOrderBy _instance;

  final TRes Function(Input$TransferOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? comment = _undefined,
    Object? from = _undefined,
    Object? fromId = _undefined,
    Object? id = _undefined,
    Object? timestamp = _undefined,
    Object? to = _undefined,
    Object? toId = _undefined,
  }) =>
      _then(Input$TransferOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (comment != _undefined) 'comment': (comment as Enum$OrderBy?),
        if (from != _undefined) 'from': (from as Input$AccountOrderBy?),
        if (fromId != _undefined) 'fromId': (fromId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
        if (to != _undefined) 'to': (to as Input$AccountOrderBy?),
        if (toId != _undefined) 'toId': (toId as Enum$OrderBy?),
      }));

  CopyWith$Input$AccountOrderBy<TRes> get from {
    final local$from = _instance.from;
    return local$from == null
        ? CopyWith$Input$AccountOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountOrderBy(local$from, (e) => call(from: e));
  }

  CopyWith$Input$AccountOrderBy<TRes> get to {
    final local$to = _instance.to;
    return local$to == null
        ? CopyWith$Input$AccountOrderBy.stub(_then(_instance))
        : CopyWith$Input$AccountOrderBy(local$to, (e) => call(to: e));
  }
}

class _CopyWithStubImpl$Input$TransferOrderBy<TRes>
    implements CopyWith$Input$TransferOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? comment,
    Input$AccountOrderBy? from,
    Enum$OrderBy? fromId,
    Enum$OrderBy? id,
    Enum$OrderBy? timestamp,
    Input$AccountOrderBy? to,
    Enum$OrderBy? toId,
  }) =>
      _res;

  CopyWith$Input$AccountOrderBy<TRes> get from =>
      CopyWith$Input$AccountOrderBy.stub(_res);

  CopyWith$Input$AccountOrderBy<TRes> get to =>
      CopyWith$Input$AccountOrderBy.stub(_res);
}

class Input$TransferStddevOrderBy {
  factory Input$TransferStddevOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferStddevOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferStddevOrderBy._(this._$data);

  factory Input$TransferStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferStddevOrderBy<Input$TransferStddevOrderBy>
      get copyWith => CopyWith$Input$TransferStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferStddevOrderBy<TRes> {
  factory CopyWith$Input$TransferStddevOrderBy(
    Input$TransferStddevOrderBy instance,
    TRes Function(Input$TransferStddevOrderBy) then,
  ) = _CopyWithImpl$Input$TransferStddevOrderBy;

  factory CopyWith$Input$TransferStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferStddevOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferStddevOrderBy<TRes>
    implements CopyWith$Input$TransferStddevOrderBy<TRes> {
  _CopyWithImpl$Input$TransferStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferStddevOrderBy _instance;

  final TRes Function(Input$TransferStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferStddevOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferStddevOrderBy<TRes>
    implements CopyWith$Input$TransferStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferStddevOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferStddevPopOrderBy {
  factory Input$TransferStddevPopOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferStddevPopOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferStddevPopOrderBy._(this._$data);

  factory Input$TransferStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferStddevPopOrderBy<Input$TransferStddevPopOrderBy>
      get copyWith => CopyWith$Input$TransferStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferStddevPopOrderBy<TRes> {
  factory CopyWith$Input$TransferStddevPopOrderBy(
    Input$TransferStddevPopOrderBy instance,
    TRes Function(Input$TransferStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$TransferStddevPopOrderBy;

  factory CopyWith$Input$TransferStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferStddevPopOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferStddevPopOrderBy<TRes>
    implements CopyWith$Input$TransferStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$TransferStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferStddevPopOrderBy _instance;

  final TRes Function(Input$TransferStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferStddevPopOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferStddevPopOrderBy<TRes>
    implements CopyWith$Input$TransferStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferStddevPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferStddevSampOrderBy {
  factory Input$TransferStddevSampOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferStddevSampOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferStddevSampOrderBy._(this._$data);

  factory Input$TransferStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferStddevSampOrderBy<Input$TransferStddevSampOrderBy>
      get copyWith => CopyWith$Input$TransferStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferStddevSampOrderBy<TRes> {
  factory CopyWith$Input$TransferStddevSampOrderBy(
    Input$TransferStddevSampOrderBy instance,
    TRes Function(Input$TransferStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$TransferStddevSampOrderBy;

  factory CopyWith$Input$TransferStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferStddevSampOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferStddevSampOrderBy<TRes>
    implements CopyWith$Input$TransferStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$TransferStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferStddevSampOrderBy _instance;

  final TRes Function(Input$TransferStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferStddevSampOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferStddevSampOrderBy<TRes>
    implements CopyWith$Input$TransferStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferStddevSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferSumOrderBy {
  factory Input$TransferSumOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferSumOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferSumOrderBy._(this._$data);

  factory Input$TransferSumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferSumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferSumOrderBy<Input$TransferSumOrderBy> get copyWith =>
      CopyWith$Input$TransferSumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferSumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferSumOrderBy<TRes> {
  factory CopyWith$Input$TransferSumOrderBy(
    Input$TransferSumOrderBy instance,
    TRes Function(Input$TransferSumOrderBy) then,
  ) = _CopyWithImpl$Input$TransferSumOrderBy;

  factory CopyWith$Input$TransferSumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferSumOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferSumOrderBy<TRes>
    implements CopyWith$Input$TransferSumOrderBy<TRes> {
  _CopyWithImpl$Input$TransferSumOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferSumOrderBy _instance;

  final TRes Function(Input$TransferSumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferSumOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferSumOrderBy<TRes>
    implements CopyWith$Input$TransferSumOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferSumOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferVarianceOrderBy {
  factory Input$TransferVarianceOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferVarianceOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferVarianceOrderBy._(this._$data);

  factory Input$TransferVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferVarianceOrderBy<Input$TransferVarianceOrderBy>
      get copyWith => CopyWith$Input$TransferVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferVarianceOrderBy<TRes> {
  factory CopyWith$Input$TransferVarianceOrderBy(
    Input$TransferVarianceOrderBy instance,
    TRes Function(Input$TransferVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$TransferVarianceOrderBy;

  factory CopyWith$Input$TransferVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferVarianceOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferVarianceOrderBy<TRes>
    implements CopyWith$Input$TransferVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$TransferVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferVarianceOrderBy _instance;

  final TRes Function(Input$TransferVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferVarianceOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferVarianceOrderBy<TRes>
    implements CopyWith$Input$TransferVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferVarianceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferVarPopOrderBy {
  factory Input$TransferVarPopOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferVarPopOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferVarPopOrderBy._(this._$data);

  factory Input$TransferVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferVarPopOrderBy<Input$TransferVarPopOrderBy>
      get copyWith => CopyWith$Input$TransferVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferVarPopOrderBy<TRes> {
  factory CopyWith$Input$TransferVarPopOrderBy(
    Input$TransferVarPopOrderBy instance,
    TRes Function(Input$TransferVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$TransferVarPopOrderBy;

  factory CopyWith$Input$TransferVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferVarPopOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferVarPopOrderBy<TRes>
    implements CopyWith$Input$TransferVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$TransferVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferVarPopOrderBy _instance;

  final TRes Function(Input$TransferVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferVarPopOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferVarPopOrderBy<TRes>
    implements CopyWith$Input$TransferVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferVarPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$TransferVarSampOrderBy {
  factory Input$TransferVarSampOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$TransferVarSampOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$TransferVarSampOrderBy._(this._$data);

  factory Input$TransferVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$TransferVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$TransferVarSampOrderBy<Input$TransferVarSampOrderBy>
      get copyWith => CopyWith$Input$TransferVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferVarSampOrderBy<TRes> {
  factory CopyWith$Input$TransferVarSampOrderBy(
    Input$TransferVarSampOrderBy instance,
    TRes Function(Input$TransferVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$TransferVarSampOrderBy;

  factory CopyWith$Input$TransferVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferVarSampOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$TransferVarSampOrderBy<TRes>
    implements CopyWith$Input$TransferVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$TransferVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$TransferVarSampOrderBy _instance;

  final TRes Function(Input$TransferVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$TransferVarSampOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$TransferVarSampOrderBy<TRes>
    implements CopyWith$Input$TransferVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$TransferVarSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryAggregateOrderBy {
  factory Input$UdHistoryAggregateOrderBy({
    Input$UdHistoryAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$UdHistoryMaxOrderBy? max,
    Input$UdHistoryMinOrderBy? min,
    Input$UdHistoryStddevOrderBy? stddev,
    Input$UdHistoryStddevPopOrderBy? stddevPop,
    Input$UdHistoryStddevSampOrderBy? stddevSamp,
    Input$UdHistorySumOrderBy? sum,
    Input$UdHistoryVarPopOrderBy? varPop,
    Input$UdHistoryVarSampOrderBy? varSamp,
    Input$UdHistoryVarianceOrderBy? variance,
  }) =>
      Input$UdHistoryAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddevPop != null) r'stddevPop': stddevPop,
        if (stddevSamp != null) r'stddevSamp': stddevSamp,
        if (sum != null) r'sum': sum,
        if (varPop != null) r'varPop': varPop,
        if (varSamp != null) r'varSamp': varSamp,
        if (variance != null) r'variance': variance,
      });

  Input$UdHistoryAggregateOrderBy._(this._$data);

  factory Input$UdHistoryAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Input$UdHistoryAvgOrderBy.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$Enum$OrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$UdHistoryMaxOrderBy.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$UdHistoryMinOrderBy.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Input$UdHistoryStddevOrderBy.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddevPop')) {
      final l$stddevPop = data['stddevPop'];
      result$data['stddevPop'] = l$stddevPop == null
          ? null
          : Input$UdHistoryStddevPopOrderBy.fromJson(
              (l$stddevPop as Map<String, dynamic>));
    }
    if (data.containsKey('stddevSamp')) {
      final l$stddevSamp = data['stddevSamp'];
      result$data['stddevSamp'] = l$stddevSamp == null
          ? null
          : Input$UdHistoryStddevSampOrderBy.fromJson(
              (l$stddevSamp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Input$UdHistorySumOrderBy.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('varPop')) {
      final l$varPop = data['varPop'];
      result$data['varPop'] = l$varPop == null
          ? null
          : Input$UdHistoryVarPopOrderBy.fromJson(
              (l$varPop as Map<String, dynamic>));
    }
    if (data.containsKey('varSamp')) {
      final l$varSamp = data['varSamp'];
      result$data['varSamp'] = l$varSamp == null
          ? null
          : Input$UdHistoryVarSampOrderBy.fromJson(
              (l$varSamp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Input$UdHistoryVarianceOrderBy.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return Input$UdHistoryAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UdHistoryAvgOrderBy? get avg =>
      (_$data['avg'] as Input$UdHistoryAvgOrderBy?);

  Enum$OrderBy? get count => (_$data['count'] as Enum$OrderBy?);

  Input$UdHistoryMaxOrderBy? get max =>
      (_$data['max'] as Input$UdHistoryMaxOrderBy?);

  Input$UdHistoryMinOrderBy? get min =>
      (_$data['min'] as Input$UdHistoryMinOrderBy?);

  Input$UdHistoryStddevOrderBy? get stddev =>
      (_$data['stddev'] as Input$UdHistoryStddevOrderBy?);

  Input$UdHistoryStddevPopOrderBy? get stddevPop =>
      (_$data['stddevPop'] as Input$UdHistoryStddevPopOrderBy?);

  Input$UdHistoryStddevSampOrderBy? get stddevSamp =>
      (_$data['stddevSamp'] as Input$UdHistoryStddevSampOrderBy?);

  Input$UdHistorySumOrderBy? get sum =>
      (_$data['sum'] as Input$UdHistorySumOrderBy?);

  Input$UdHistoryVarPopOrderBy? get varPop =>
      (_$data['varPop'] as Input$UdHistoryVarPopOrderBy?);

  Input$UdHistoryVarSampOrderBy? get varSamp =>
      (_$data['varSamp'] as Input$UdHistoryVarSampOrderBy?);

  Input$UdHistoryVarianceOrderBy? get variance =>
      (_$data['variance'] as Input$UdHistoryVarianceOrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$Enum$OrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddevPop')) {
      final l$stddevPop = stddevPop;
      result$data['stddevPop'] = l$stddevPop?.toJson();
    }
    if (_$data.containsKey('stddevSamp')) {
      final l$stddevSamp = stddevSamp;
      result$data['stddevSamp'] = l$stddevSamp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('varPop')) {
      final l$varPop = varPop;
      result$data['varPop'] = l$varPop?.toJson();
    }
    if (_$data.containsKey('varSamp')) {
      final l$varSamp = varSamp;
      result$data['varSamp'] = l$varSamp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryAggregateOrderBy<Input$UdHistoryAggregateOrderBy>
      get copyWith => CopyWith$Input$UdHistoryAggregateOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddevPop = stddevPop;
    final lOther$stddevPop = other.stddevPop;
    if (_$data.containsKey('stddevPop') !=
        other._$data.containsKey('stddevPop')) {
      return false;
    }
    if (l$stddevPop != lOther$stddevPop) {
      return false;
    }
    final l$stddevSamp = stddevSamp;
    final lOther$stddevSamp = other.stddevSamp;
    if (_$data.containsKey('stddevSamp') !=
        other._$data.containsKey('stddevSamp')) {
      return false;
    }
    if (l$stddevSamp != lOther$stddevSamp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$varPop = varPop;
    final lOther$varPop = other.varPop;
    if (_$data.containsKey('varPop') != other._$data.containsKey('varPop')) {
      return false;
    }
    if (l$varPop != lOther$varPop) {
      return false;
    }
    final l$varSamp = varSamp;
    final lOther$varSamp = other.varSamp;
    if (_$data.containsKey('varSamp') != other._$data.containsKey('varSamp')) {
      return false;
    }
    if (l$varSamp != lOther$varSamp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddevPop = stddevPop;
    final l$stddevSamp = stddevSamp;
    final l$sum = sum;
    final l$varPop = varPop;
    final l$varSamp = varSamp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddevPop') ? l$stddevPop : const {},
      _$data.containsKey('stddevSamp') ? l$stddevSamp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('varPop') ? l$varPop : const {},
      _$data.containsKey('varSamp') ? l$varSamp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryAggregateOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryAggregateOrderBy(
    Input$UdHistoryAggregateOrderBy instance,
    TRes Function(Input$UdHistoryAggregateOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryAggregateOrderBy;

  factory CopyWith$Input$UdHistoryAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryAggregateOrderBy;

  TRes call({
    Input$UdHistoryAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$UdHistoryMaxOrderBy? max,
    Input$UdHistoryMinOrderBy? min,
    Input$UdHistoryStddevOrderBy? stddev,
    Input$UdHistoryStddevPopOrderBy? stddevPop,
    Input$UdHistoryStddevSampOrderBy? stddevSamp,
    Input$UdHistorySumOrderBy? sum,
    Input$UdHistoryVarPopOrderBy? varPop,
    Input$UdHistoryVarSampOrderBy? varSamp,
    Input$UdHistoryVarianceOrderBy? variance,
  });
  CopyWith$Input$UdHistoryAvgOrderBy<TRes> get avg;
  CopyWith$Input$UdHistoryMaxOrderBy<TRes> get max;
  CopyWith$Input$UdHistoryMinOrderBy<TRes> get min;
  CopyWith$Input$UdHistoryStddevOrderBy<TRes> get stddev;
  CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> get stddevPop;
  CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> get stddevSamp;
  CopyWith$Input$UdHistorySumOrderBy<TRes> get sum;
  CopyWith$Input$UdHistoryVarPopOrderBy<TRes> get varPop;
  CopyWith$Input$UdHistoryVarSampOrderBy<TRes> get varSamp;
  CopyWith$Input$UdHistoryVarianceOrderBy<TRes> get variance;
}

class _CopyWithImpl$Input$UdHistoryAggregateOrderBy<TRes>
    implements CopyWith$Input$UdHistoryAggregateOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryAggregateOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryAggregateOrderBy _instance;

  final TRes Function(Input$UdHistoryAggregateOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddevPop = _undefined,
    Object? stddevSamp = _undefined,
    Object? sum = _undefined,
    Object? varPop = _undefined,
    Object? varSamp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(Input$UdHistoryAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Input$UdHistoryAvgOrderBy?),
        if (count != _undefined) 'count': (count as Enum$OrderBy?),
        if (max != _undefined) 'max': (max as Input$UdHistoryMaxOrderBy?),
        if (min != _undefined) 'min': (min as Input$UdHistoryMinOrderBy?),
        if (stddev != _undefined)
          'stddev': (stddev as Input$UdHistoryStddevOrderBy?),
        if (stddevPop != _undefined)
          'stddevPop': (stddevPop as Input$UdHistoryStddevPopOrderBy?),
        if (stddevSamp != _undefined)
          'stddevSamp': (stddevSamp as Input$UdHistoryStddevSampOrderBy?),
        if (sum != _undefined) 'sum': (sum as Input$UdHistorySumOrderBy?),
        if (varPop != _undefined)
          'varPop': (varPop as Input$UdHistoryVarPopOrderBy?),
        if (varSamp != _undefined)
          'varSamp': (varSamp as Input$UdHistoryVarSampOrderBy?),
        if (variance != _undefined)
          'variance': (variance as Input$UdHistoryVarianceOrderBy?),
      }));

  CopyWith$Input$UdHistoryAvgOrderBy<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Input$UdHistoryAvgOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryAvgOrderBy(local$avg, (e) => call(avg: e));
  }

  CopyWith$Input$UdHistoryMaxOrderBy<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$UdHistoryMaxOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryMaxOrderBy(local$max, (e) => call(max: e));
  }

  CopyWith$Input$UdHistoryMinOrderBy<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$UdHistoryMinOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryMinOrderBy(local$min, (e) => call(min: e));
  }

  CopyWith$Input$UdHistoryStddevOrderBy<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Input$UdHistoryStddevOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryStddevOrderBy(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> get stddevPop {
    final local$stddevPop = _instance.stddevPop;
    return local$stddevPop == null
        ? CopyWith$Input$UdHistoryStddevPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryStddevPopOrderBy(
            local$stddevPop, (e) => call(stddevPop: e));
  }

  CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> get stddevSamp {
    final local$stddevSamp = _instance.stddevSamp;
    return local$stddevSamp == null
        ? CopyWith$Input$UdHistoryStddevSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryStddevSampOrderBy(
            local$stddevSamp, (e) => call(stddevSamp: e));
  }

  CopyWith$Input$UdHistorySumOrderBy<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Input$UdHistorySumOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistorySumOrderBy(local$sum, (e) => call(sum: e));
  }

  CopyWith$Input$UdHistoryVarPopOrderBy<TRes> get varPop {
    final local$varPop = _instance.varPop;
    return local$varPop == null
        ? CopyWith$Input$UdHistoryVarPopOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryVarPopOrderBy(
            local$varPop, (e) => call(varPop: e));
  }

  CopyWith$Input$UdHistoryVarSampOrderBy<TRes> get varSamp {
    final local$varSamp = _instance.varSamp;
    return local$varSamp == null
        ? CopyWith$Input$UdHistoryVarSampOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryVarSampOrderBy(
            local$varSamp, (e) => call(varSamp: e));
  }

  CopyWith$Input$UdHistoryVarianceOrderBy<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Input$UdHistoryVarianceOrderBy.stub(_then(_instance))
        : CopyWith$Input$UdHistoryVarianceOrderBy(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$Input$UdHistoryAggregateOrderBy<TRes>
    implements CopyWith$Input$UdHistoryAggregateOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryAggregateOrderBy(this._res);

  TRes _res;

  call({
    Input$UdHistoryAvgOrderBy? avg,
    Enum$OrderBy? count,
    Input$UdHistoryMaxOrderBy? max,
    Input$UdHistoryMinOrderBy? min,
    Input$UdHistoryStddevOrderBy? stddev,
    Input$UdHistoryStddevPopOrderBy? stddevPop,
    Input$UdHistoryStddevSampOrderBy? stddevSamp,
    Input$UdHistorySumOrderBy? sum,
    Input$UdHistoryVarPopOrderBy? varPop,
    Input$UdHistoryVarSampOrderBy? varSamp,
    Input$UdHistoryVarianceOrderBy? variance,
  }) =>
      _res;

  CopyWith$Input$UdHistoryAvgOrderBy<TRes> get avg =>
      CopyWith$Input$UdHistoryAvgOrderBy.stub(_res);

  CopyWith$Input$UdHistoryMaxOrderBy<TRes> get max =>
      CopyWith$Input$UdHistoryMaxOrderBy.stub(_res);

  CopyWith$Input$UdHistoryMinOrderBy<TRes> get min =>
      CopyWith$Input$UdHistoryMinOrderBy.stub(_res);

  CopyWith$Input$UdHistoryStddevOrderBy<TRes> get stddev =>
      CopyWith$Input$UdHistoryStddevOrderBy.stub(_res);

  CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> get stddevPop =>
      CopyWith$Input$UdHistoryStddevPopOrderBy.stub(_res);

  CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> get stddevSamp =>
      CopyWith$Input$UdHistoryStddevSampOrderBy.stub(_res);

  CopyWith$Input$UdHistorySumOrderBy<TRes> get sum =>
      CopyWith$Input$UdHistorySumOrderBy.stub(_res);

  CopyWith$Input$UdHistoryVarPopOrderBy<TRes> get varPop =>
      CopyWith$Input$UdHistoryVarPopOrderBy.stub(_res);

  CopyWith$Input$UdHistoryVarSampOrderBy<TRes> get varSamp =>
      CopyWith$Input$UdHistoryVarSampOrderBy.stub(_res);

  CopyWith$Input$UdHistoryVarianceOrderBy<TRes> get variance =>
      CopyWith$Input$UdHistoryVarianceOrderBy.stub(_res);
}

class Input$UdHistoryAvgOrderBy {
  factory Input$UdHistoryAvgOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryAvgOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryAvgOrderBy._(this._$data);

  factory Input$UdHistoryAvgOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryAvgOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryAvgOrderBy<Input$UdHistoryAvgOrderBy> get copyWith =>
      CopyWith$Input$UdHistoryAvgOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryAvgOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryAvgOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryAvgOrderBy(
    Input$UdHistoryAvgOrderBy instance,
    TRes Function(Input$UdHistoryAvgOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryAvgOrderBy;

  factory CopyWith$Input$UdHistoryAvgOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryAvgOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryAvgOrderBy<TRes>
    implements CopyWith$Input$UdHistoryAvgOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryAvgOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryAvgOrderBy _instance;

  final TRes Function(Input$UdHistoryAvgOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryAvgOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryAvgOrderBy<TRes>
    implements CopyWith$Input$UdHistoryAvgOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryAvgOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryBoolExp {
  factory Input$UdHistoryBoolExp({
    List<Input$UdHistoryBoolExp>? $_and,
    Input$UdHistoryBoolExp? $_not,
    List<Input$UdHistoryBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      Input$UdHistoryBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdHistoryBoolExp._(this._$data);

  factory Input$UdHistoryBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$UdHistoryBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$UdHistoryBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$UdHistoryBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$IntComparisonExp.fromJson((l$amount as Map<String, dynamic>));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityBoolExp.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$identityId as Map<String, dynamic>));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : Input$TimestamptzComparisonExp.fromJson(
              (l$timestamp as Map<String, dynamic>));
    }
    return Input$UdHistoryBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UdHistoryBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$UdHistoryBoolExp>?);

  Input$UdHistoryBoolExp? get $_not =>
      (_$data['_not'] as Input$UdHistoryBoolExp?);

  List<Input$UdHistoryBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$UdHistoryBoolExp>?);

  Input$IntComparisonExp? get amount =>
      (_$data['amount'] as Input$IntComparisonExp?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IdentityBoolExp? get identity =>
      (_$data['identity'] as Input$IdentityBoolExp?);

  Input$StringComparisonExp? get identityId =>
      (_$data['identityId'] as Input$StringComparisonExp?);

  Input$TimestamptzComparisonExp? get timestamp =>
      (_$data['timestamp'] as Input$TimestamptzComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] = l$identityId?.toJson();
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] = l$timestamp?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryBoolExp<Input$UdHistoryBoolExp> get copyWith =>
      CopyWith$Input$UdHistoryBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryBoolExp<TRes> {
  factory CopyWith$Input$UdHistoryBoolExp(
    Input$UdHistoryBoolExp instance,
    TRes Function(Input$UdHistoryBoolExp) then,
  ) = _CopyWithImpl$Input$UdHistoryBoolExp;

  factory CopyWith$Input$UdHistoryBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryBoolExp;

  TRes call({
    List<Input$UdHistoryBoolExp>? $_and,
    Input$UdHistoryBoolExp? $_not,
    List<Input$UdHistoryBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$TimestamptzComparisonExp? timestamp,
  });
  TRes $_and(
      Iterable<Input$UdHistoryBoolExp>? Function(
              Iterable<
                  CopyWith$Input$UdHistoryBoolExp<Input$UdHistoryBoolExp>>?)
          _fn);
  CopyWith$Input$UdHistoryBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$UdHistoryBoolExp>? Function(
              Iterable<
                  CopyWith$Input$UdHistoryBoolExp<Input$UdHistoryBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get amount;
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IdentityBoolExp<TRes> get identity;
  CopyWith$Input$StringComparisonExp<TRes> get identityId;
  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp;
}

class _CopyWithImpl$Input$UdHistoryBoolExp<TRes>
    implements CopyWith$Input$UdHistoryBoolExp<TRes> {
  _CopyWithImpl$Input$UdHistoryBoolExp(
    this._instance,
    this._then,
  );

  final Input$UdHistoryBoolExp _instance;

  final TRes Function(Input$UdHistoryBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdHistoryBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$UdHistoryBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$UdHistoryBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$UdHistoryBoolExp>?),
        if (amount != _undefined) 'amount': (amount as Input$IntComparisonExp?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityBoolExp?),
        if (identityId != _undefined)
          'identityId': (identityId as Input$StringComparisonExp?),
        if (timestamp != _undefined)
          'timestamp': (timestamp as Input$TimestamptzComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$UdHistoryBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UdHistoryBoolExp<Input$UdHistoryBoolExp>>?)
              _fn) =>
      call(
          $_and:
              _fn(_instance.$_and?.map((e) => CopyWith$Input$UdHistoryBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UdHistoryBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$UdHistoryBoolExp.stub(_then(_instance))
        : CopyWith$Input$UdHistoryBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$UdHistoryBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UdHistoryBoolExp<Input$UdHistoryBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$UdHistoryBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$amount, (e) => call(amount: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IdentityBoolExp<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityBoolExp.stub(_then(_instance))
        : CopyWith$Input$IdentityBoolExp(
            local$identity, (e) => call(identity: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get identityId {
    final local$identityId = _instance.identityId;
    return local$identityId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$identityId, (e) => call(identityId: e));
  }

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp {
    final local$timestamp = _instance.timestamp;
    return local$timestamp == null
        ? CopyWith$Input$TimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$Input$TimestamptzComparisonExp(
            local$timestamp, (e) => call(timestamp: e));
  }
}

class _CopyWithStubImpl$Input$UdHistoryBoolExp<TRes>
    implements CopyWith$Input$UdHistoryBoolExp<TRes> {
  _CopyWithStubImpl$Input$UdHistoryBoolExp(this._res);

  TRes _res;

  call({
    List<Input$UdHistoryBoolExp>? $_and,
    Input$UdHistoryBoolExp? $_not,
    List<Input$UdHistoryBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$StringComparisonExp? id,
    Input$IdentityBoolExp? identity,
    Input$StringComparisonExp? identityId,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$UdHistoryBoolExp<TRes> get $_not =>
      CopyWith$Input$UdHistoryBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get amount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IdentityBoolExp<TRes> get identity =>
      CopyWith$Input$IdentityBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get identityId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp =>
      CopyWith$Input$TimestamptzComparisonExp.stub(_res);
}

class Input$UdHistoryMaxOrderBy {
  factory Input$UdHistoryMaxOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      Input$UdHistoryMaxOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdHistoryMaxOrderBy._(this._$data);

  factory Input$UdHistoryMaxOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    return Input$UdHistoryMaxOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryMaxOrderBy<Input$UdHistoryMaxOrderBy> get copyWith =>
      CopyWith$Input$UdHistoryMaxOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryMaxOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identityId = identityId;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryMaxOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryMaxOrderBy(
    Input$UdHistoryMaxOrderBy instance,
    TRes Function(Input$UdHistoryMaxOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryMaxOrderBy;

  factory CopyWith$Input$UdHistoryMaxOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryMaxOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  });
}

class _CopyWithImpl$Input$UdHistoryMaxOrderBy<TRes>
    implements CopyWith$Input$UdHistoryMaxOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryMaxOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryMaxOrderBy _instance;

  final TRes Function(Input$UdHistoryMaxOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdHistoryMaxOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryMaxOrderBy<TRes>
    implements CopyWith$Input$UdHistoryMaxOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryMaxOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      _res;
}

class Input$UdHistoryMinOrderBy {
  factory Input$UdHistoryMinOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      Input$UdHistoryMinOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identityId != null) r'identityId': identityId,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdHistoryMinOrderBy._(this._$data);

  factory Input$UdHistoryMinOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    return Input$UdHistoryMinOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryMinOrderBy<Input$UdHistoryMinOrderBy> get copyWith =>
      CopyWith$Input$UdHistoryMinOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryMinOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identityId = identityId;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryMinOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryMinOrderBy(
    Input$UdHistoryMinOrderBy instance,
    TRes Function(Input$UdHistoryMinOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryMinOrderBy;

  factory CopyWith$Input$UdHistoryMinOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryMinOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  });
}

class _CopyWithImpl$Input$UdHistoryMinOrderBy<TRes>
    implements CopyWith$Input$UdHistoryMinOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryMinOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryMinOrderBy _instance;

  final TRes Function(Input$UdHistoryMinOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identityId = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdHistoryMinOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryMinOrderBy<TRes>
    implements CopyWith$Input$UdHistoryMinOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryMinOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      _res;
}

class Input$UdHistoryOrderBy {
  factory Input$UdHistoryOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      Input$UdHistoryOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (id != null) r'id': id,
        if (identity != null) r'identity': identity,
        if (identityId != null) r'identityId': identityId,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdHistoryOrderBy._(this._$data);

  factory Input$UdHistoryOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('identity')) {
      final l$identity = data['identity'];
      result$data['identity'] = l$identity == null
          ? null
          : Input$IdentityOrderBy.fromJson(
              (l$identity as Map<String, dynamic>));
    }
    if (data.containsKey('identityId')) {
      final l$identityId = data['identityId'];
      result$data['identityId'] = l$identityId == null
          ? null
          : fromJson$Enum$OrderBy((l$identityId as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    return Input$UdHistoryOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Input$IdentityOrderBy? get identity =>
      (_$data['identity'] as Input$IdentityOrderBy?);

  Enum$OrderBy? get identityId => (_$data['identityId'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('identity')) {
      final l$identity = identity;
      result$data['identity'] = l$identity?.toJson();
    }
    if (_$data.containsKey('identityId')) {
      final l$identityId = identityId;
      result$data['identityId'] =
          l$identityId == null ? null : toJson$Enum$OrderBy(l$identityId);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryOrderBy<Input$UdHistoryOrderBy> get copyWith =>
      CopyWith$Input$UdHistoryOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$identity = identity;
    final lOther$identity = other.identity;
    if (_$data.containsKey('identity') !=
        other._$data.containsKey('identity')) {
      return false;
    }
    if (l$identity != lOther$identity) {
      return false;
    }
    final l$identityId = identityId;
    final lOther$identityId = other.identityId;
    if (_$data.containsKey('identityId') !=
        other._$data.containsKey('identityId')) {
      return false;
    }
    if (l$identityId != lOther$identityId) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$id = id;
    final l$identity = identity;
    final l$identityId = identityId;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('identity') ? l$identity : const {},
      _$data.containsKey('identityId') ? l$identityId : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryOrderBy(
    Input$UdHistoryOrderBy instance,
    TRes Function(Input$UdHistoryOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryOrderBy;

  factory CopyWith$Input$UdHistoryOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  });
  CopyWith$Input$IdentityOrderBy<TRes> get identity;
}

class _CopyWithImpl$Input$UdHistoryOrderBy<TRes>
    implements CopyWith$Input$UdHistoryOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryOrderBy _instance;

  final TRes Function(Input$UdHistoryOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? id = _undefined,
    Object? identity = _undefined,
    Object? identityId = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdHistoryOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (identity != _undefined)
          'identity': (identity as Input$IdentityOrderBy?),
        if (identityId != _undefined)
          'identityId': (identityId as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
      }));

  CopyWith$Input$IdentityOrderBy<TRes> get identity {
    final local$identity = _instance.identity;
    return local$identity == null
        ? CopyWith$Input$IdentityOrderBy.stub(_then(_instance))
        : CopyWith$Input$IdentityOrderBy(
            local$identity, (e) => call(identity: e));
  }
}

class _CopyWithStubImpl$Input$UdHistoryOrderBy<TRes>
    implements CopyWith$Input$UdHistoryOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Enum$OrderBy? id,
    Input$IdentityOrderBy? identity,
    Enum$OrderBy? identityId,
    Enum$OrderBy? timestamp,
  }) =>
      _res;

  CopyWith$Input$IdentityOrderBy<TRes> get identity =>
      CopyWith$Input$IdentityOrderBy.stub(_res);
}

class Input$UdHistoryStddevOrderBy {
  factory Input$UdHistoryStddevOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryStddevOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryStddevOrderBy._(this._$data);

  factory Input$UdHistoryStddevOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryStddevOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryStddevOrderBy<Input$UdHistoryStddevOrderBy>
      get copyWith => CopyWith$Input$UdHistoryStddevOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryStddevOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryStddevOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryStddevOrderBy(
    Input$UdHistoryStddevOrderBy instance,
    TRes Function(Input$UdHistoryStddevOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryStddevOrderBy;

  factory CopyWith$Input$UdHistoryStddevOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryStddevOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryStddevOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryStddevOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryStddevOrderBy _instance;

  final TRes Function(Input$UdHistoryStddevOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryStddevOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryStddevOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryStddevOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryStddevPopOrderBy {
  factory Input$UdHistoryStddevPopOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryStddevPopOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryStddevPopOrderBy._(this._$data);

  factory Input$UdHistoryStddevPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryStddevPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryStddevPopOrderBy<Input$UdHistoryStddevPopOrderBy>
      get copyWith => CopyWith$Input$UdHistoryStddevPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryStddevPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryStddevPopOrderBy(
    Input$UdHistoryStddevPopOrderBy instance,
    TRes Function(Input$UdHistoryStddevPopOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryStddevPopOrderBy;

  factory CopyWith$Input$UdHistoryStddevPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryStddevPopOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryStddevPopOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryStddevPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryStddevPopOrderBy _instance;

  final TRes Function(Input$UdHistoryStddevPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryStddevPopOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryStddevPopOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryStddevPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryStddevSampOrderBy {
  factory Input$UdHistoryStddevSampOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryStddevSampOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryStddevSampOrderBy._(this._$data);

  factory Input$UdHistoryStddevSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryStddevSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryStddevSampOrderBy<Input$UdHistoryStddevSampOrderBy>
      get copyWith => CopyWith$Input$UdHistoryStddevSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryStddevSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryStddevSampOrderBy(
    Input$UdHistoryStddevSampOrderBy instance,
    TRes Function(Input$UdHistoryStddevSampOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryStddevSampOrderBy;

  factory CopyWith$Input$UdHistoryStddevSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryStddevSampOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryStddevSampOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryStddevSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryStddevSampOrderBy _instance;

  final TRes Function(Input$UdHistoryStddevSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryStddevSampOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryStddevSampOrderBy<TRes>
    implements CopyWith$Input$UdHistoryStddevSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryStddevSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistorySumOrderBy {
  factory Input$UdHistorySumOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistorySumOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistorySumOrderBy._(this._$data);

  factory Input$UdHistorySumOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistorySumOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistorySumOrderBy<Input$UdHistorySumOrderBy> get copyWith =>
      CopyWith$Input$UdHistorySumOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistorySumOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistorySumOrderBy<TRes> {
  factory CopyWith$Input$UdHistorySumOrderBy(
    Input$UdHistorySumOrderBy instance,
    TRes Function(Input$UdHistorySumOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistorySumOrderBy;

  factory CopyWith$Input$UdHistorySumOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistorySumOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistorySumOrderBy<TRes>
    implements CopyWith$Input$UdHistorySumOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistorySumOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistorySumOrderBy _instance;

  final TRes Function(Input$UdHistorySumOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistorySumOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistorySumOrderBy<TRes>
    implements CopyWith$Input$UdHistorySumOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistorySumOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryVarianceOrderBy {
  factory Input$UdHistoryVarianceOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryVarianceOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryVarianceOrderBy._(this._$data);

  factory Input$UdHistoryVarianceOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryVarianceOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryVarianceOrderBy<Input$UdHistoryVarianceOrderBy>
      get copyWith => CopyWith$Input$UdHistoryVarianceOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryVarianceOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryVarianceOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryVarianceOrderBy(
    Input$UdHistoryVarianceOrderBy instance,
    TRes Function(Input$UdHistoryVarianceOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryVarianceOrderBy;

  factory CopyWith$Input$UdHistoryVarianceOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryVarianceOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryVarianceOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarianceOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryVarianceOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryVarianceOrderBy _instance;

  final TRes Function(Input$UdHistoryVarianceOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryVarianceOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryVarianceOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarianceOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryVarianceOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryVarPopOrderBy {
  factory Input$UdHistoryVarPopOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryVarPopOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryVarPopOrderBy._(this._$data);

  factory Input$UdHistoryVarPopOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryVarPopOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryVarPopOrderBy<Input$UdHistoryVarPopOrderBy>
      get copyWith => CopyWith$Input$UdHistoryVarPopOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryVarPopOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryVarPopOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryVarPopOrderBy(
    Input$UdHistoryVarPopOrderBy instance,
    TRes Function(Input$UdHistoryVarPopOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryVarPopOrderBy;

  factory CopyWith$Input$UdHistoryVarPopOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryVarPopOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryVarPopOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarPopOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryVarPopOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryVarPopOrderBy _instance;

  final TRes Function(Input$UdHistoryVarPopOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryVarPopOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryVarPopOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarPopOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryVarPopOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdHistoryVarSampOrderBy {
  factory Input$UdHistoryVarSampOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      Input$UdHistoryVarSampOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
      });

  Input$UdHistoryVarSampOrderBy._(this._$data);

  factory Input$UdHistoryVarSampOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    return Input$UdHistoryVarSampOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    return result$data;
  }

  CopyWith$Input$UdHistoryVarSampOrderBy<Input$UdHistoryVarSampOrderBy>
      get copyWith => CopyWith$Input$UdHistoryVarSampOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdHistoryVarSampOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdHistoryVarSampOrderBy<TRes> {
  factory CopyWith$Input$UdHistoryVarSampOrderBy(
    Input$UdHistoryVarSampOrderBy instance,
    TRes Function(Input$UdHistoryVarSampOrderBy) then,
  ) = _CopyWithImpl$Input$UdHistoryVarSampOrderBy;

  factory CopyWith$Input$UdHistoryVarSampOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdHistoryVarSampOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  });
}

class _CopyWithImpl$Input$UdHistoryVarSampOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarSampOrderBy<TRes> {
  _CopyWithImpl$Input$UdHistoryVarSampOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdHistoryVarSampOrderBy _instance;

  final TRes Function(Input$UdHistoryVarSampOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
  }) =>
      _then(Input$UdHistoryVarSampOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
      }));
}

class _CopyWithStubImpl$Input$UdHistoryVarSampOrderBy<TRes>
    implements CopyWith$Input$UdHistoryVarSampOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdHistoryVarSampOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
  }) =>
      _res;
}

class Input$UdReevalBoolExp {
  factory Input$UdReevalBoolExp({
    List<Input$UdReevalBoolExp>? $_and,
    Input$UdReevalBoolExp? $_not,
    List<Input$UdReevalBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$IntComparisonExp? newUdAmount,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      Input$UdReevalBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (membersCount != null) r'membersCount': membersCount,
        if (monetaryMass != null) r'monetaryMass': monetaryMass,
        if (newUdAmount != null) r'newUdAmount': newUdAmount,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdReevalBoolExp._(this._$data);

  factory Input$UdReevalBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              Input$UdReevalBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$UdReevalBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              Input$UdReevalBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventBoolExp.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$eventId as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('membersCount')) {
      final l$membersCount = data['membersCount'];
      result$data['membersCount'] = l$membersCount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$membersCount as Map<String, dynamic>));
    }
    if (data.containsKey('monetaryMass')) {
      final l$monetaryMass = data['monetaryMass'];
      result$data['monetaryMass'] = l$monetaryMass == null
          ? null
          : Input$NumericComparisonExp.fromJson(
              (l$monetaryMass as Map<String, dynamic>));
    }
    if (data.containsKey('newUdAmount')) {
      final l$newUdAmount = data['newUdAmount'];
      result$data['newUdAmount'] = l$newUdAmount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$newUdAmount as Map<String, dynamic>));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : Input$TimestamptzComparisonExp.fromJson(
              (l$timestamp as Map<String, dynamic>));
    }
    return Input$UdReevalBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UdReevalBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$UdReevalBoolExp>?);

  Input$UdReevalBoolExp? get $_not =>
      (_$data['_not'] as Input$UdReevalBoolExp?);

  List<Input$UdReevalBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$UdReevalBoolExp>?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$EventBoolExp? get event => (_$data['event'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get eventId =>
      (_$data['eventId'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get membersCount =>
      (_$data['membersCount'] as Input$IntComparisonExp?);

  Input$NumericComparisonExp? get monetaryMass =>
      (_$data['monetaryMass'] as Input$NumericComparisonExp?);

  Input$IntComparisonExp? get newUdAmount =>
      (_$data['newUdAmount'] as Input$IntComparisonExp?);

  Input$TimestamptzComparisonExp? get timestamp =>
      (_$data['timestamp'] as Input$TimestamptzComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] = l$eventId?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('membersCount')) {
      final l$membersCount = membersCount;
      result$data['membersCount'] = l$membersCount?.toJson();
    }
    if (_$data.containsKey('monetaryMass')) {
      final l$monetaryMass = monetaryMass;
      result$data['monetaryMass'] = l$monetaryMass?.toJson();
    }
    if (_$data.containsKey('newUdAmount')) {
      final l$newUdAmount = newUdAmount;
      result$data['newUdAmount'] = l$newUdAmount?.toJson();
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] = l$timestamp?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UdReevalBoolExp<Input$UdReevalBoolExp> get copyWith =>
      CopyWith$Input$UdReevalBoolExp(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdReevalBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$membersCount = membersCount;
    final lOther$membersCount = other.membersCount;
    if (_$data.containsKey('membersCount') !=
        other._$data.containsKey('membersCount')) {
      return false;
    }
    if (l$membersCount != lOther$membersCount) {
      return false;
    }
    final l$monetaryMass = monetaryMass;
    final lOther$monetaryMass = other.monetaryMass;
    if (_$data.containsKey('monetaryMass') !=
        other._$data.containsKey('monetaryMass')) {
      return false;
    }
    if (l$monetaryMass != lOther$monetaryMass) {
      return false;
    }
    final l$newUdAmount = newUdAmount;
    final lOther$newUdAmount = other.newUdAmount;
    if (_$data.containsKey('newUdAmount') !=
        other._$data.containsKey('newUdAmount')) {
      return false;
    }
    if (l$newUdAmount != lOther$newUdAmount) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$id = id;
    final l$membersCount = membersCount;
    final l$monetaryMass = monetaryMass;
    final l$newUdAmount = newUdAmount;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('membersCount') ? l$membersCount : const {},
      _$data.containsKey('monetaryMass') ? l$monetaryMass : const {},
      _$data.containsKey('newUdAmount') ? l$newUdAmount : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdReevalBoolExp<TRes> {
  factory CopyWith$Input$UdReevalBoolExp(
    Input$UdReevalBoolExp instance,
    TRes Function(Input$UdReevalBoolExp) then,
  ) = _CopyWithImpl$Input$UdReevalBoolExp;

  factory CopyWith$Input$UdReevalBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$UdReevalBoolExp;

  TRes call({
    List<Input$UdReevalBoolExp>? $_and,
    Input$UdReevalBoolExp? $_not,
    List<Input$UdReevalBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$IntComparisonExp? newUdAmount,
    Input$TimestamptzComparisonExp? timestamp,
  });
  TRes $_and(
      Iterable<Input$UdReevalBoolExp>? Function(
              Iterable<CopyWith$Input$UdReevalBoolExp<Input$UdReevalBoolExp>>?)
          _fn);
  CopyWith$Input$UdReevalBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$UdReevalBoolExp>? Function(
              Iterable<CopyWith$Input$UdReevalBoolExp<Input$UdReevalBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$EventBoolExp<TRes> get event;
  CopyWith$Input$StringComparisonExp<TRes> get eventId;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IntComparisonExp<TRes> get membersCount;
  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass;
  CopyWith$Input$IntComparisonExp<TRes> get newUdAmount;
  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp;
}

class _CopyWithImpl$Input$UdReevalBoolExp<TRes>
    implements CopyWith$Input$UdReevalBoolExp<TRes> {
  _CopyWithImpl$Input$UdReevalBoolExp(
    this._instance,
    this._then,
  );

  final Input$UdReevalBoolExp _instance;

  final TRes Function(Input$UdReevalBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? membersCount = _undefined,
    Object? monetaryMass = _undefined,
    Object? newUdAmount = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdReevalBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$UdReevalBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as Input$UdReevalBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<Input$UdReevalBoolExp>?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (event != _undefined) 'event': (event as Input$EventBoolExp?),
        if (eventId != _undefined)
          'eventId': (eventId as Input$StringComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (membersCount != _undefined)
          'membersCount': (membersCount as Input$IntComparisonExp?),
        if (monetaryMass != _undefined)
          'monetaryMass': (monetaryMass as Input$NumericComparisonExp?),
        if (newUdAmount != _undefined)
          'newUdAmount': (newUdAmount as Input$IntComparisonExp?),
        if (timestamp != _undefined)
          'timestamp': (timestamp as Input$TimestamptzComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$UdReevalBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UdReevalBoolExp<Input$UdReevalBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$Input$UdReevalBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$UdReevalBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$UdReevalBoolExp.stub(_then(_instance))
        : CopyWith$Input$UdReevalBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$UdReevalBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UdReevalBoolExp<Input$UdReevalBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$Input$UdReevalBoolExp(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$event, (e) => call(event: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get eventId {
    final local$eventId = _instance.eventId;
    return local$eventId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$eventId, (e) => call(eventId: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get membersCount {
    final local$membersCount = _instance.membersCount;
    return local$membersCount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$membersCount, (e) => call(membersCount: e));
  }

  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass {
    final local$monetaryMass = _instance.monetaryMass;
    return local$monetaryMass == null
        ? CopyWith$Input$NumericComparisonExp.stub(_then(_instance))
        : CopyWith$Input$NumericComparisonExp(
            local$monetaryMass, (e) => call(monetaryMass: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get newUdAmount {
    final local$newUdAmount = _instance.newUdAmount;
    return local$newUdAmount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$newUdAmount, (e) => call(newUdAmount: e));
  }

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp {
    final local$timestamp = _instance.timestamp;
    return local$timestamp == null
        ? CopyWith$Input$TimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$Input$TimestamptzComparisonExp(
            local$timestamp, (e) => call(timestamp: e));
  }
}

class _CopyWithStubImpl$Input$UdReevalBoolExp<TRes>
    implements CopyWith$Input$UdReevalBoolExp<TRes> {
  _CopyWithStubImpl$Input$UdReevalBoolExp(this._res);

  TRes _res;

  call({
    List<Input$UdReevalBoolExp>? $_and,
    Input$UdReevalBoolExp? $_not,
    List<Input$UdReevalBoolExp>? $_or,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$IntComparisonExp? newUdAmount,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$UdReevalBoolExp<TRes> get $_not =>
      CopyWith$Input$UdReevalBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get event =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get eventId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get membersCount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass =>
      CopyWith$Input$NumericComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get newUdAmount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp =>
      CopyWith$Input$TimestamptzComparisonExp.stub(_res);
}

class Input$UdReevalOrderBy {
  factory Input$UdReevalOrderBy({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? newUdAmount,
    Enum$OrderBy? timestamp,
  }) =>
      Input$UdReevalOrderBy._({
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (membersCount != null) r'membersCount': membersCount,
        if (monetaryMass != null) r'monetaryMass': monetaryMass,
        if (newUdAmount != null) r'newUdAmount': newUdAmount,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UdReevalOrderBy._(this._$data);

  factory Input$UdReevalOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventOrderBy.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('membersCount')) {
      final l$membersCount = data['membersCount'];
      result$data['membersCount'] = l$membersCount == null
          ? null
          : fromJson$Enum$OrderBy((l$membersCount as String));
    }
    if (data.containsKey('monetaryMass')) {
      final l$monetaryMass = data['monetaryMass'];
      result$data['monetaryMass'] = l$monetaryMass == null
          ? null
          : fromJson$Enum$OrderBy((l$monetaryMass as String));
    }
    if (data.containsKey('newUdAmount')) {
      final l$newUdAmount = data['newUdAmount'];
      result$data['newUdAmount'] = l$newUdAmount == null
          ? null
          : fromJson$Enum$OrderBy((l$newUdAmount as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    return Input$UdReevalOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Input$EventOrderBy? get event => (_$data['event'] as Input$EventOrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get membersCount => (_$data['membersCount'] as Enum$OrderBy?);

  Enum$OrderBy? get monetaryMass => (_$data['monetaryMass'] as Enum$OrderBy?);

  Enum$OrderBy? get newUdAmount => (_$data['newUdAmount'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('membersCount')) {
      final l$membersCount = membersCount;
      result$data['membersCount'] =
          l$membersCount == null ? null : toJson$Enum$OrderBy(l$membersCount);
    }
    if (_$data.containsKey('monetaryMass')) {
      final l$monetaryMass = monetaryMass;
      result$data['monetaryMass'] =
          l$monetaryMass == null ? null : toJson$Enum$OrderBy(l$monetaryMass);
    }
    if (_$data.containsKey('newUdAmount')) {
      final l$newUdAmount = newUdAmount;
      result$data['newUdAmount'] =
          l$newUdAmount == null ? null : toJson$Enum$OrderBy(l$newUdAmount);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    return result$data;
  }

  CopyWith$Input$UdReevalOrderBy<Input$UdReevalOrderBy> get copyWith =>
      CopyWith$Input$UdReevalOrderBy(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UdReevalOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$membersCount = membersCount;
    final lOther$membersCount = other.membersCount;
    if (_$data.containsKey('membersCount') !=
        other._$data.containsKey('membersCount')) {
      return false;
    }
    if (l$membersCount != lOther$membersCount) {
      return false;
    }
    final l$monetaryMass = monetaryMass;
    final lOther$monetaryMass = other.monetaryMass;
    if (_$data.containsKey('monetaryMass') !=
        other._$data.containsKey('monetaryMass')) {
      return false;
    }
    if (l$monetaryMass != lOther$monetaryMass) {
      return false;
    }
    final l$newUdAmount = newUdAmount;
    final lOther$newUdAmount = other.newUdAmount;
    if (_$data.containsKey('newUdAmount') !=
        other._$data.containsKey('newUdAmount')) {
      return false;
    }
    if (l$newUdAmount != lOther$newUdAmount) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$id = id;
    final l$membersCount = membersCount;
    final l$monetaryMass = monetaryMass;
    final l$newUdAmount = newUdAmount;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('membersCount') ? l$membersCount : const {},
      _$data.containsKey('monetaryMass') ? l$monetaryMass : const {},
      _$data.containsKey('newUdAmount') ? l$newUdAmount : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UdReevalOrderBy<TRes> {
  factory CopyWith$Input$UdReevalOrderBy(
    Input$UdReevalOrderBy instance,
    TRes Function(Input$UdReevalOrderBy) then,
  ) = _CopyWithImpl$Input$UdReevalOrderBy;

  factory CopyWith$Input$UdReevalOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UdReevalOrderBy;

  TRes call({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? newUdAmount,
    Enum$OrderBy? timestamp,
  });
  CopyWith$Input$EventOrderBy<TRes> get event;
}

class _CopyWithImpl$Input$UdReevalOrderBy<TRes>
    implements CopyWith$Input$UdReevalOrderBy<TRes> {
  _CopyWithImpl$Input$UdReevalOrderBy(
    this._instance,
    this._then,
  );

  final Input$UdReevalOrderBy _instance;

  final TRes Function(Input$UdReevalOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? membersCount = _undefined,
    Object? monetaryMass = _undefined,
    Object? newUdAmount = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UdReevalOrderBy._({
        ..._instance._$data,
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (event != _undefined) 'event': (event as Input$EventOrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (membersCount != _undefined)
          'membersCount': (membersCount as Enum$OrderBy?),
        if (monetaryMass != _undefined)
          'monetaryMass': (monetaryMass as Enum$OrderBy?),
        if (newUdAmount != _undefined)
          'newUdAmount': (newUdAmount as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
      }));

  CopyWith$Input$EventOrderBy<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(local$event, (e) => call(event: e));
  }
}

class _CopyWithStubImpl$Input$UdReevalOrderBy<TRes>
    implements CopyWith$Input$UdReevalOrderBy<TRes> {
  _CopyWithStubImpl$Input$UdReevalOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? newUdAmount,
    Enum$OrderBy? timestamp,
  }) =>
      _res;

  CopyWith$Input$EventOrderBy<TRes> get event =>
      CopyWith$Input$EventOrderBy.stub(_res);
}

class Input$UniversalDividendBoolExp {
  factory Input$UniversalDividendBoolExp({
    List<Input$UniversalDividendBoolExp>? $_and,
    Input$UniversalDividendBoolExp? $_not,
    List<Input$UniversalDividendBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      Input$UniversalDividendBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (membersCount != null) r'membersCount': membersCount,
        if (monetaryMass != null) r'monetaryMass': monetaryMass,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UniversalDividendBoolExp._(this._$data);

  factory Input$UniversalDividendBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => Input$UniversalDividendBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : Input$UniversalDividendBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => Input$UniversalDividendBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$IntComparisonExp.fromJson((l$amount as Map<String, dynamic>));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$blockNumber as Map<String, dynamic>));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventBoolExp.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : Input$StringComparisonExp.fromJson(
              (l$eventId as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('membersCount')) {
      final l$membersCount = data['membersCount'];
      result$data['membersCount'] = l$membersCount == null
          ? null
          : Input$IntComparisonExp.fromJson(
              (l$membersCount as Map<String, dynamic>));
    }
    if (data.containsKey('monetaryMass')) {
      final l$monetaryMass = data['monetaryMass'];
      result$data['monetaryMass'] = l$monetaryMass == null
          ? null
          : Input$NumericComparisonExp.fromJson(
              (l$monetaryMass as Map<String, dynamic>));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : Input$TimestamptzComparisonExp.fromJson(
              (l$timestamp as Map<String, dynamic>));
    }
    return Input$UniversalDividendBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UniversalDividendBoolExp>? get $_and =>
      (_$data['_and'] as List<Input$UniversalDividendBoolExp>?);

  Input$UniversalDividendBoolExp? get $_not =>
      (_$data['_not'] as Input$UniversalDividendBoolExp?);

  List<Input$UniversalDividendBoolExp>? get $_or =>
      (_$data['_or'] as List<Input$UniversalDividendBoolExp>?);

  Input$IntComparisonExp? get amount =>
      (_$data['amount'] as Input$IntComparisonExp?);

  Input$IntComparisonExp? get blockNumber =>
      (_$data['blockNumber'] as Input$IntComparisonExp?);

  Input$EventBoolExp? get event => (_$data['event'] as Input$EventBoolExp?);

  Input$StringComparisonExp? get eventId =>
      (_$data['eventId'] as Input$StringComparisonExp?);

  Input$StringComparisonExp? get id =>
      (_$data['id'] as Input$StringComparisonExp?);

  Input$IntComparisonExp? get membersCount =>
      (_$data['membersCount'] as Input$IntComparisonExp?);

  Input$NumericComparisonExp? get monetaryMass =>
      (_$data['monetaryMass'] as Input$NumericComparisonExp?);

  Input$TimestamptzComparisonExp? get timestamp =>
      (_$data['timestamp'] as Input$TimestamptzComparisonExp?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] = l$blockNumber?.toJson();
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] = l$eventId?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('membersCount')) {
      final l$membersCount = membersCount;
      result$data['membersCount'] = l$membersCount?.toJson();
    }
    if (_$data.containsKey('monetaryMass')) {
      final l$monetaryMass = monetaryMass;
      result$data['monetaryMass'] = l$monetaryMass?.toJson();
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] = l$timestamp?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UniversalDividendBoolExp<Input$UniversalDividendBoolExp>
      get copyWith => CopyWith$Input$UniversalDividendBoolExp(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UniversalDividendBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$membersCount = membersCount;
    final lOther$membersCount = other.membersCount;
    if (_$data.containsKey('membersCount') !=
        other._$data.containsKey('membersCount')) {
      return false;
    }
    if (l$membersCount != lOther$membersCount) {
      return false;
    }
    final l$monetaryMass = monetaryMass;
    final lOther$monetaryMass = other.monetaryMass;
    if (_$data.containsKey('monetaryMass') !=
        other._$data.containsKey('monetaryMass')) {
      return false;
    }
    if (l$monetaryMass != lOther$monetaryMass) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$id = id;
    final l$membersCount = membersCount;
    final l$monetaryMass = monetaryMass;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('membersCount') ? l$membersCount : const {},
      _$data.containsKey('monetaryMass') ? l$monetaryMass : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UniversalDividendBoolExp<TRes> {
  factory CopyWith$Input$UniversalDividendBoolExp(
    Input$UniversalDividendBoolExp instance,
    TRes Function(Input$UniversalDividendBoolExp) then,
  ) = _CopyWithImpl$Input$UniversalDividendBoolExp;

  factory CopyWith$Input$UniversalDividendBoolExp.stub(TRes res) =
      _CopyWithStubImpl$Input$UniversalDividendBoolExp;

  TRes call({
    List<Input$UniversalDividendBoolExp>? $_and,
    Input$UniversalDividendBoolExp? $_not,
    List<Input$UniversalDividendBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$TimestamptzComparisonExp? timestamp,
  });
  TRes $_and(
      Iterable<Input$UniversalDividendBoolExp>? Function(
              Iterable<
                  CopyWith$Input$UniversalDividendBoolExp<
                      Input$UniversalDividendBoolExp>>?)
          _fn);
  CopyWith$Input$UniversalDividendBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<Input$UniversalDividendBoolExp>? Function(
              Iterable<
                  CopyWith$Input$UniversalDividendBoolExp<
                      Input$UniversalDividendBoolExp>>?)
          _fn);
  CopyWith$Input$IntComparisonExp<TRes> get amount;
  CopyWith$Input$IntComparisonExp<TRes> get blockNumber;
  CopyWith$Input$EventBoolExp<TRes> get event;
  CopyWith$Input$StringComparisonExp<TRes> get eventId;
  CopyWith$Input$StringComparisonExp<TRes> get id;
  CopyWith$Input$IntComparisonExp<TRes> get membersCount;
  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass;
  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp;
}

class _CopyWithImpl$Input$UniversalDividendBoolExp<TRes>
    implements CopyWith$Input$UniversalDividendBoolExp<TRes> {
  _CopyWithImpl$Input$UniversalDividendBoolExp(
    this._instance,
    this._then,
  );

  final Input$UniversalDividendBoolExp _instance;

  final TRes Function(Input$UniversalDividendBoolExp) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? membersCount = _undefined,
    Object? monetaryMass = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UniversalDividendBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<Input$UniversalDividendBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as Input$UniversalDividendBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<Input$UniversalDividendBoolExp>?),
        if (amount != _undefined) 'amount': (amount as Input$IntComparisonExp?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Input$IntComparisonExp?),
        if (event != _undefined) 'event': (event as Input$EventBoolExp?),
        if (eventId != _undefined)
          'eventId': (eventId as Input$StringComparisonExp?),
        if (id != _undefined) 'id': (id as Input$StringComparisonExp?),
        if (membersCount != _undefined)
          'membersCount': (membersCount as Input$IntComparisonExp?),
        if (monetaryMass != _undefined)
          'monetaryMass': (monetaryMass as Input$NumericComparisonExp?),
        if (timestamp != _undefined)
          'timestamp': (timestamp as Input$TimestamptzComparisonExp?),
      }));

  TRes $_and(
          Iterable<Input$UniversalDividendBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UniversalDividendBoolExp<
                          Input$UniversalDividendBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and
              ?.map((e) => CopyWith$Input$UniversalDividendBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UniversalDividendBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$Input$UniversalDividendBoolExp.stub(_then(_instance))
        : CopyWith$Input$UniversalDividendBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<Input$UniversalDividendBoolExp>? Function(
                  Iterable<
                      CopyWith$Input$UniversalDividendBoolExp<
                          Input$UniversalDividendBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or
              ?.map((e) => CopyWith$Input$UniversalDividendBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$IntComparisonExp<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(local$amount, (e) => call(amount: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber {
    final local$blockNumber = _instance.blockNumber;
    return local$blockNumber == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$blockNumber, (e) => call(blockNumber: e));
  }

  CopyWith$Input$EventBoolExp<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventBoolExp.stub(_then(_instance))
        : CopyWith$Input$EventBoolExp(local$event, (e) => call(event: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get eventId {
    final local$eventId = _instance.eventId;
    return local$eventId == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(
            local$eventId, (e) => call(eventId: e));
  }

  CopyWith$Input$StringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringComparisonExp.stub(_then(_instance))
        : CopyWith$Input$StringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$Input$IntComparisonExp<TRes> get membersCount {
    final local$membersCount = _instance.membersCount;
    return local$membersCount == null
        ? CopyWith$Input$IntComparisonExp.stub(_then(_instance))
        : CopyWith$Input$IntComparisonExp(
            local$membersCount, (e) => call(membersCount: e));
  }

  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass {
    final local$monetaryMass = _instance.monetaryMass;
    return local$monetaryMass == null
        ? CopyWith$Input$NumericComparisonExp.stub(_then(_instance))
        : CopyWith$Input$NumericComparisonExp(
            local$monetaryMass, (e) => call(monetaryMass: e));
  }

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp {
    final local$timestamp = _instance.timestamp;
    return local$timestamp == null
        ? CopyWith$Input$TimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$Input$TimestamptzComparisonExp(
            local$timestamp, (e) => call(timestamp: e));
  }
}

class _CopyWithStubImpl$Input$UniversalDividendBoolExp<TRes>
    implements CopyWith$Input$UniversalDividendBoolExp<TRes> {
  _CopyWithStubImpl$Input$UniversalDividendBoolExp(this._res);

  TRes _res;

  call({
    List<Input$UniversalDividendBoolExp>? $_and,
    Input$UniversalDividendBoolExp? $_not,
    List<Input$UniversalDividendBoolExp>? $_or,
    Input$IntComparisonExp? amount,
    Input$IntComparisonExp? blockNumber,
    Input$EventBoolExp? event,
    Input$StringComparisonExp? eventId,
    Input$StringComparisonExp? id,
    Input$IntComparisonExp? membersCount,
    Input$NumericComparisonExp? monetaryMass,
    Input$TimestamptzComparisonExp? timestamp,
  }) =>
      _res;

  $_and(_fn) => _res;

  CopyWith$Input$UniversalDividendBoolExp<TRes> get $_not =>
      CopyWith$Input$UniversalDividendBoolExp.stub(_res);

  $_or(_fn) => _res;

  CopyWith$Input$IntComparisonExp<TRes> get amount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get blockNumber =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$EventBoolExp<TRes> get event =>
      CopyWith$Input$EventBoolExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get eventId =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$StringComparisonExp<TRes> get id =>
      CopyWith$Input$StringComparisonExp.stub(_res);

  CopyWith$Input$IntComparisonExp<TRes> get membersCount =>
      CopyWith$Input$IntComparisonExp.stub(_res);

  CopyWith$Input$NumericComparisonExp<TRes> get monetaryMass =>
      CopyWith$Input$NumericComparisonExp.stub(_res);

  CopyWith$Input$TimestamptzComparisonExp<TRes> get timestamp =>
      CopyWith$Input$TimestamptzComparisonExp.stub(_res);
}

class Input$UniversalDividendOrderBy {
  factory Input$UniversalDividendOrderBy({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? timestamp,
  }) =>
      Input$UniversalDividendOrderBy._({
        if (amount != null) r'amount': amount,
        if (blockNumber != null) r'blockNumber': blockNumber,
        if (event != null) r'event': event,
        if (eventId != null) r'eventId': eventId,
        if (id != null) r'id': id,
        if (membersCount != null) r'membersCount': membersCount,
        if (monetaryMass != null) r'monetaryMass': monetaryMass,
        if (timestamp != null) r'timestamp': timestamp,
      });

  Input$UniversalDividendOrderBy._(this._$data);

  factory Input$UniversalDividendOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] =
          l$amount == null ? null : fromJson$Enum$OrderBy((l$amount as String));
    }
    if (data.containsKey('blockNumber')) {
      final l$blockNumber = data['blockNumber'];
      result$data['blockNumber'] = l$blockNumber == null
          ? null
          : fromJson$Enum$OrderBy((l$blockNumber as String));
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : Input$EventOrderBy.fromJson((l$event as Map<String, dynamic>));
    }
    if (data.containsKey('eventId')) {
      final l$eventId = data['eventId'];
      result$data['eventId'] = l$eventId == null
          ? null
          : fromJson$Enum$OrderBy((l$eventId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$OrderBy((l$id as String));
    }
    if (data.containsKey('membersCount')) {
      final l$membersCount = data['membersCount'];
      result$data['membersCount'] = l$membersCount == null
          ? null
          : fromJson$Enum$OrderBy((l$membersCount as String));
    }
    if (data.containsKey('monetaryMass')) {
      final l$monetaryMass = data['monetaryMass'];
      result$data['monetaryMass'] = l$monetaryMass == null
          ? null
          : fromJson$Enum$OrderBy((l$monetaryMass as String));
    }
    if (data.containsKey('timestamp')) {
      final l$timestamp = data['timestamp'];
      result$data['timestamp'] = l$timestamp == null
          ? null
          : fromJson$Enum$OrderBy((l$timestamp as String));
    }
    return Input$UniversalDividendOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderBy? get amount => (_$data['amount'] as Enum$OrderBy?);

  Enum$OrderBy? get blockNumber => (_$data['blockNumber'] as Enum$OrderBy?);

  Input$EventOrderBy? get event => (_$data['event'] as Input$EventOrderBy?);

  Enum$OrderBy? get eventId => (_$data['eventId'] as Enum$OrderBy?);

  Enum$OrderBy? get id => (_$data['id'] as Enum$OrderBy?);

  Enum$OrderBy? get membersCount => (_$data['membersCount'] as Enum$OrderBy?);

  Enum$OrderBy? get monetaryMass => (_$data['monetaryMass'] as Enum$OrderBy?);

  Enum$OrderBy? get timestamp => (_$data['timestamp'] as Enum$OrderBy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] =
          l$amount == null ? null : toJson$Enum$OrderBy(l$amount);
    }
    if (_$data.containsKey('blockNumber')) {
      final l$blockNumber = blockNumber;
      result$data['blockNumber'] =
          l$blockNumber == null ? null : toJson$Enum$OrderBy(l$blockNumber);
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] = l$event?.toJson();
    }
    if (_$data.containsKey('eventId')) {
      final l$eventId = eventId;
      result$data['eventId'] =
          l$eventId == null ? null : toJson$Enum$OrderBy(l$eventId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$OrderBy(l$id);
    }
    if (_$data.containsKey('membersCount')) {
      final l$membersCount = membersCount;
      result$data['membersCount'] =
          l$membersCount == null ? null : toJson$Enum$OrderBy(l$membersCount);
    }
    if (_$data.containsKey('monetaryMass')) {
      final l$monetaryMass = monetaryMass;
      result$data['monetaryMass'] =
          l$monetaryMass == null ? null : toJson$Enum$OrderBy(l$monetaryMass);
    }
    if (_$data.containsKey('timestamp')) {
      final l$timestamp = timestamp;
      result$data['timestamp'] =
          l$timestamp == null ? null : toJson$Enum$OrderBy(l$timestamp);
    }
    return result$data;
  }

  CopyWith$Input$UniversalDividendOrderBy<Input$UniversalDividendOrderBy>
      get copyWith => CopyWith$Input$UniversalDividendOrderBy(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UniversalDividendOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$blockNumber = blockNumber;
    final lOther$blockNumber = other.blockNumber;
    if (_$data.containsKey('blockNumber') !=
        other._$data.containsKey('blockNumber')) {
      return false;
    }
    if (l$blockNumber != lOther$blockNumber) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$eventId = eventId;
    final lOther$eventId = other.eventId;
    if (_$data.containsKey('eventId') != other._$data.containsKey('eventId')) {
      return false;
    }
    if (l$eventId != lOther$eventId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$membersCount = membersCount;
    final lOther$membersCount = other.membersCount;
    if (_$data.containsKey('membersCount') !=
        other._$data.containsKey('membersCount')) {
      return false;
    }
    if (l$membersCount != lOther$membersCount) {
      return false;
    }
    final l$monetaryMass = monetaryMass;
    final lOther$monetaryMass = other.monetaryMass;
    if (_$data.containsKey('monetaryMass') !=
        other._$data.containsKey('monetaryMass')) {
      return false;
    }
    if (l$monetaryMass != lOther$monetaryMass) {
      return false;
    }
    final l$timestamp = timestamp;
    final lOther$timestamp = other.timestamp;
    if (_$data.containsKey('timestamp') !=
        other._$data.containsKey('timestamp')) {
      return false;
    }
    if (l$timestamp != lOther$timestamp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$blockNumber = blockNumber;
    final l$event = event;
    final l$eventId = eventId;
    final l$id = id;
    final l$membersCount = membersCount;
    final l$monetaryMass = monetaryMass;
    final l$timestamp = timestamp;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('blockNumber') ? l$blockNumber : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('eventId') ? l$eventId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('membersCount') ? l$membersCount : const {},
      _$data.containsKey('monetaryMass') ? l$monetaryMass : const {},
      _$data.containsKey('timestamp') ? l$timestamp : const {},
    ]);
  }
}

abstract class CopyWith$Input$UniversalDividendOrderBy<TRes> {
  factory CopyWith$Input$UniversalDividendOrderBy(
    Input$UniversalDividendOrderBy instance,
    TRes Function(Input$UniversalDividendOrderBy) then,
  ) = _CopyWithImpl$Input$UniversalDividendOrderBy;

  factory CopyWith$Input$UniversalDividendOrderBy.stub(TRes res) =
      _CopyWithStubImpl$Input$UniversalDividendOrderBy;

  TRes call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? timestamp,
  });
  CopyWith$Input$EventOrderBy<TRes> get event;
}

class _CopyWithImpl$Input$UniversalDividendOrderBy<TRes>
    implements CopyWith$Input$UniversalDividendOrderBy<TRes> {
  _CopyWithImpl$Input$UniversalDividendOrderBy(
    this._instance,
    this._then,
  );

  final Input$UniversalDividendOrderBy _instance;

  final TRes Function(Input$UniversalDividendOrderBy) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? blockNumber = _undefined,
    Object? event = _undefined,
    Object? eventId = _undefined,
    Object? id = _undefined,
    Object? membersCount = _undefined,
    Object? monetaryMass = _undefined,
    Object? timestamp = _undefined,
  }) =>
      _then(Input$UniversalDividendOrderBy._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as Enum$OrderBy?),
        if (blockNumber != _undefined)
          'blockNumber': (blockNumber as Enum$OrderBy?),
        if (event != _undefined) 'event': (event as Input$EventOrderBy?),
        if (eventId != _undefined) 'eventId': (eventId as Enum$OrderBy?),
        if (id != _undefined) 'id': (id as Enum$OrderBy?),
        if (membersCount != _undefined)
          'membersCount': (membersCount as Enum$OrderBy?),
        if (monetaryMass != _undefined)
          'monetaryMass': (monetaryMass as Enum$OrderBy?),
        if (timestamp != _undefined) 'timestamp': (timestamp as Enum$OrderBy?),
      }));

  CopyWith$Input$EventOrderBy<TRes> get event {
    final local$event = _instance.event;
    return local$event == null
        ? CopyWith$Input$EventOrderBy.stub(_then(_instance))
        : CopyWith$Input$EventOrderBy(local$event, (e) => call(event: e));
  }
}

class _CopyWithStubImpl$Input$UniversalDividendOrderBy<TRes>
    implements CopyWith$Input$UniversalDividendOrderBy<TRes> {
  _CopyWithStubImpl$Input$UniversalDividendOrderBy(this._res);

  TRes _res;

  call({
    Enum$OrderBy? amount,
    Enum$OrderBy? blockNumber,
    Input$EventOrderBy? event,
    Enum$OrderBy? eventId,
    Enum$OrderBy? id,
    Enum$OrderBy? membersCount,
    Enum$OrderBy? monetaryMass,
    Enum$OrderBy? timestamp,
  }) =>
      _res;

  CopyWith$Input$EventOrderBy<TRes> get event =>
      CopyWith$Input$EventOrderBy.stub(_res);
}

enum Enum$AccountSelectColumn {
  id,
  linkedIdentityId,
  $unknown;

  factory Enum$AccountSelectColumn.fromJson(String value) =>
      fromJson$Enum$AccountSelectColumn(value);

  String toJson() => toJson$Enum$AccountSelectColumn(this);
}

String toJson$Enum$AccountSelectColumn(Enum$AccountSelectColumn e) {
  switch (e) {
    case Enum$AccountSelectColumn.id:
      return r'id';
    case Enum$AccountSelectColumn.linkedIdentityId:
      return r'linkedIdentityId';
    case Enum$AccountSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$AccountSelectColumn fromJson$Enum$AccountSelectColumn(String value) {
  switch (value) {
    case r'id':
      return Enum$AccountSelectColumn.id;
    case r'linkedIdentityId':
      return Enum$AccountSelectColumn.linkedIdentityId;
    default:
      return Enum$AccountSelectColumn.$unknown;
  }
}

enum Enum$BlockSelectColumn {
  callsCount,
  eventsCount,
  extrinsicsCount,
  extrinsicsicRoot,
  hash,
  height,
  id,
  implName,
  implVersion,
  parentHash,
  specName,
  specVersion,
  stateRoot,
  timestamp,
  validator,
  $unknown;

  factory Enum$BlockSelectColumn.fromJson(String value) =>
      fromJson$Enum$BlockSelectColumn(value);

  String toJson() => toJson$Enum$BlockSelectColumn(this);
}

String toJson$Enum$BlockSelectColumn(Enum$BlockSelectColumn e) {
  switch (e) {
    case Enum$BlockSelectColumn.callsCount:
      return r'callsCount';
    case Enum$BlockSelectColumn.eventsCount:
      return r'eventsCount';
    case Enum$BlockSelectColumn.extrinsicsCount:
      return r'extrinsicsCount';
    case Enum$BlockSelectColumn.extrinsicsicRoot:
      return r'extrinsicsicRoot';
    case Enum$BlockSelectColumn.hash:
      return r'hash';
    case Enum$BlockSelectColumn.height:
      return r'height';
    case Enum$BlockSelectColumn.id:
      return r'id';
    case Enum$BlockSelectColumn.implName:
      return r'implName';
    case Enum$BlockSelectColumn.implVersion:
      return r'implVersion';
    case Enum$BlockSelectColumn.parentHash:
      return r'parentHash';
    case Enum$BlockSelectColumn.specName:
      return r'specName';
    case Enum$BlockSelectColumn.specVersion:
      return r'specVersion';
    case Enum$BlockSelectColumn.stateRoot:
      return r'stateRoot';
    case Enum$BlockSelectColumn.timestamp:
      return r'timestamp';
    case Enum$BlockSelectColumn.validator:
      return r'validator';
    case Enum$BlockSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$BlockSelectColumn fromJson$Enum$BlockSelectColumn(String value) {
  switch (value) {
    case r'callsCount':
      return Enum$BlockSelectColumn.callsCount;
    case r'eventsCount':
      return Enum$BlockSelectColumn.eventsCount;
    case r'extrinsicsCount':
      return Enum$BlockSelectColumn.extrinsicsCount;
    case r'extrinsicsicRoot':
      return Enum$BlockSelectColumn.extrinsicsicRoot;
    case r'hash':
      return Enum$BlockSelectColumn.hash;
    case r'height':
      return Enum$BlockSelectColumn.height;
    case r'id':
      return Enum$BlockSelectColumn.id;
    case r'implName':
      return Enum$BlockSelectColumn.implName;
    case r'implVersion':
      return Enum$BlockSelectColumn.implVersion;
    case r'parentHash':
      return Enum$BlockSelectColumn.parentHash;
    case r'specName':
      return Enum$BlockSelectColumn.specName;
    case r'specVersion':
      return Enum$BlockSelectColumn.specVersion;
    case r'stateRoot':
      return Enum$BlockSelectColumn.stateRoot;
    case r'timestamp':
      return Enum$BlockSelectColumn.timestamp;
    case r'validator':
      return Enum$BlockSelectColumn.validator;
    default:
      return Enum$BlockSelectColumn.$unknown;
  }
}

enum Enum$CallSelectColumn {
  address,
  args,
  argsStr,
  blockId,
  error,
  extrinsicId,
  id,
  name,
  pallet,
  parentId,
  success,
  $unknown;

  factory Enum$CallSelectColumn.fromJson(String value) =>
      fromJson$Enum$CallSelectColumn(value);

  String toJson() => toJson$Enum$CallSelectColumn(this);
}

String toJson$Enum$CallSelectColumn(Enum$CallSelectColumn e) {
  switch (e) {
    case Enum$CallSelectColumn.address:
      return r'address';
    case Enum$CallSelectColumn.args:
      return r'args';
    case Enum$CallSelectColumn.argsStr:
      return r'argsStr';
    case Enum$CallSelectColumn.blockId:
      return r'blockId';
    case Enum$CallSelectColumn.error:
      return r'error';
    case Enum$CallSelectColumn.extrinsicId:
      return r'extrinsicId';
    case Enum$CallSelectColumn.id:
      return r'id';
    case Enum$CallSelectColumn.name:
      return r'name';
    case Enum$CallSelectColumn.pallet:
      return r'pallet';
    case Enum$CallSelectColumn.parentId:
      return r'parentId';
    case Enum$CallSelectColumn.success:
      return r'success';
    case Enum$CallSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$CallSelectColumn fromJson$Enum$CallSelectColumn(String value) {
  switch (value) {
    case r'address':
      return Enum$CallSelectColumn.address;
    case r'args':
      return Enum$CallSelectColumn.args;
    case r'argsStr':
      return Enum$CallSelectColumn.argsStr;
    case r'blockId':
      return Enum$CallSelectColumn.blockId;
    case r'error':
      return Enum$CallSelectColumn.error;
    case r'extrinsicId':
      return Enum$CallSelectColumn.extrinsicId;
    case r'id':
      return Enum$CallSelectColumn.id;
    case r'name':
      return Enum$CallSelectColumn.name;
    case r'pallet':
      return Enum$CallSelectColumn.pallet;
    case r'parentId':
      return Enum$CallSelectColumn.parentId;
    case r'success':
      return Enum$CallSelectColumn.success;
    default:
      return Enum$CallSelectColumn.$unknown;
  }
}

enum Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns {
  success,
  $unknown;

  factory Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
          this);
}

String toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
    Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns e) {
  switch (e) {
    case Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
          .success:
      return r'success';
    case Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
    fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns(
        String value) {
  switch (value) {
    case r'success':
      return Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
          .success;
    default:
      return Enum$CallSelectColumnCallAggregateBoolExpBool_andArgumentsColumns
          .$unknown;
  }
}

enum Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns {
  success,
  $unknown;

  factory Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
          this);
}

String toJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
    Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns e) {
  switch (e) {
    case Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
          .success:
      return r'success';
    case Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
    fromJson$Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns(
        String value) {
  switch (value) {
    case r'success':
      return Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
          .success;
    default:
      return Enum$CallSelectColumnCallAggregateBoolExpBool_orArgumentsColumns
          .$unknown;
  }
}

enum Enum$CertEventSelectColumn {
  blockNumber,
  certId,
  eventId,
  eventType,
  id,
  $unknown;

  factory Enum$CertEventSelectColumn.fromJson(String value) =>
      fromJson$Enum$CertEventSelectColumn(value);

  String toJson() => toJson$Enum$CertEventSelectColumn(this);
}

String toJson$Enum$CertEventSelectColumn(Enum$CertEventSelectColumn e) {
  switch (e) {
    case Enum$CertEventSelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$CertEventSelectColumn.certId:
      return r'certId';
    case Enum$CertEventSelectColumn.eventId:
      return r'eventId';
    case Enum$CertEventSelectColumn.eventType:
      return r'eventType';
    case Enum$CertEventSelectColumn.id:
      return r'id';
    case Enum$CertEventSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$CertEventSelectColumn fromJson$Enum$CertEventSelectColumn(String value) {
  switch (value) {
    case r'blockNumber':
      return Enum$CertEventSelectColumn.blockNumber;
    case r'certId':
      return Enum$CertEventSelectColumn.certId;
    case r'eventId':
      return Enum$CertEventSelectColumn.eventId;
    case r'eventType':
      return Enum$CertEventSelectColumn.eventType;
    case r'id':
      return Enum$CertEventSelectColumn.id;
    default:
      return Enum$CertEventSelectColumn.$unknown;
  }
}

enum Enum$CertSelectColumn {
  createdInId,
  createdOn,
  expireOn,
  id,
  isActive,
  issuerId,
  receiverId,
  updatedInId,
  updatedOn,
  $unknown;

  factory Enum$CertSelectColumn.fromJson(String value) =>
      fromJson$Enum$CertSelectColumn(value);

  String toJson() => toJson$Enum$CertSelectColumn(this);
}

String toJson$Enum$CertSelectColumn(Enum$CertSelectColumn e) {
  switch (e) {
    case Enum$CertSelectColumn.createdInId:
      return r'createdInId';
    case Enum$CertSelectColumn.createdOn:
      return r'createdOn';
    case Enum$CertSelectColumn.expireOn:
      return r'expireOn';
    case Enum$CertSelectColumn.id:
      return r'id';
    case Enum$CertSelectColumn.isActive:
      return r'isActive';
    case Enum$CertSelectColumn.issuerId:
      return r'issuerId';
    case Enum$CertSelectColumn.receiverId:
      return r'receiverId';
    case Enum$CertSelectColumn.updatedInId:
      return r'updatedInId';
    case Enum$CertSelectColumn.updatedOn:
      return r'updatedOn';
    case Enum$CertSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$CertSelectColumn fromJson$Enum$CertSelectColumn(String value) {
  switch (value) {
    case r'createdInId':
      return Enum$CertSelectColumn.createdInId;
    case r'createdOn':
      return Enum$CertSelectColumn.createdOn;
    case r'expireOn':
      return Enum$CertSelectColumn.expireOn;
    case r'id':
      return Enum$CertSelectColumn.id;
    case r'isActive':
      return Enum$CertSelectColumn.isActive;
    case r'issuerId':
      return Enum$CertSelectColumn.issuerId;
    case r'receiverId':
      return Enum$CertSelectColumn.receiverId;
    case r'updatedInId':
      return Enum$CertSelectColumn.updatedInId;
    case r'updatedOn':
      return Enum$CertSelectColumn.updatedOn;
    default:
      return Enum$CertSelectColumn.$unknown;
  }
}

enum Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns {
  isActive,
  $unknown;

  factory Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
          this);
}

String toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
    Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns e) {
  switch (e) {
    case Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
          .isActive:
      return r'isActive';
    case Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
    fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns(
        String value) {
  switch (value) {
    case r'isActive':
      return Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
          .isActive;
    default:
      return Enum$CertSelectColumnCertAggregateBoolExpBool_andArgumentsColumns
          .$unknown;
  }
}

enum Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns {
  isActive,
  $unknown;

  factory Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
          this);
}

String toJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
    Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns e) {
  switch (e) {
    case Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
          .isActive:
      return r'isActive';
    case Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
    fromJson$Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns(
        String value) {
  switch (value) {
    case r'isActive':
      return Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
          .isActive;
    default:
      return Enum$CertSelectColumnCertAggregateBoolExpBool_orArgumentsColumns
          .$unknown;
  }
}

enum Enum$ChangeOwnerKeySelectColumn {
  blockNumber,
  id,
  identityId,
  nextId,
  previousId,
  $unknown;

  factory Enum$ChangeOwnerKeySelectColumn.fromJson(String value) =>
      fromJson$Enum$ChangeOwnerKeySelectColumn(value);

  String toJson() => toJson$Enum$ChangeOwnerKeySelectColumn(this);
}

String toJson$Enum$ChangeOwnerKeySelectColumn(
    Enum$ChangeOwnerKeySelectColumn e) {
  switch (e) {
    case Enum$ChangeOwnerKeySelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$ChangeOwnerKeySelectColumn.id:
      return r'id';
    case Enum$ChangeOwnerKeySelectColumn.identityId:
      return r'identityId';
    case Enum$ChangeOwnerKeySelectColumn.nextId:
      return r'nextId';
    case Enum$ChangeOwnerKeySelectColumn.previousId:
      return r'previousId';
    case Enum$ChangeOwnerKeySelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$ChangeOwnerKeySelectColumn fromJson$Enum$ChangeOwnerKeySelectColumn(
    String value) {
  switch (value) {
    case r'blockNumber':
      return Enum$ChangeOwnerKeySelectColumn.blockNumber;
    case r'id':
      return Enum$ChangeOwnerKeySelectColumn.id;
    case r'identityId':
      return Enum$ChangeOwnerKeySelectColumn.identityId;
    case r'nextId':
      return Enum$ChangeOwnerKeySelectColumn.nextId;
    case r'previousId':
      return Enum$ChangeOwnerKeySelectColumn.previousId;
    default:
      return Enum$ChangeOwnerKeySelectColumn.$unknown;
  }
}

enum Enum$CounterLevelEnum {
  GLOBAL,
  ITEM,
  PALLET,
  $unknown;

  factory Enum$CounterLevelEnum.fromJson(String value) =>
      fromJson$Enum$CounterLevelEnum(value);

  String toJson() => toJson$Enum$CounterLevelEnum(this);
}

String toJson$Enum$CounterLevelEnum(Enum$CounterLevelEnum e) {
  switch (e) {
    case Enum$CounterLevelEnum.GLOBAL:
      return r'GLOBAL';
    case Enum$CounterLevelEnum.ITEM:
      return r'ITEM';
    case Enum$CounterLevelEnum.PALLET:
      return r'PALLET';
    case Enum$CounterLevelEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CounterLevelEnum fromJson$Enum$CounterLevelEnum(String value) {
  switch (value) {
    case r'GLOBAL':
      return Enum$CounterLevelEnum.GLOBAL;
    case r'ITEM':
      return Enum$CounterLevelEnum.ITEM;
    case r'PALLET':
      return Enum$CounterLevelEnum.PALLET;
    default:
      return Enum$CounterLevelEnum.$unknown;
  }
}

enum Enum$EventSelectColumn {
  args,
  argsStr,
  blockId,
  callId,
  extrinsicId,
  id,
  indexEnum,
  name,
  pallet,
  phase,
  $unknown;

  factory Enum$EventSelectColumn.fromJson(String value) =>
      fromJson$Enum$EventSelectColumn(value);

  String toJson() => toJson$Enum$EventSelectColumn(this);
}

String toJson$Enum$EventSelectColumn(Enum$EventSelectColumn e) {
  switch (e) {
    case Enum$EventSelectColumn.args:
      return r'args';
    case Enum$EventSelectColumn.argsStr:
      return r'argsStr';
    case Enum$EventSelectColumn.blockId:
      return r'blockId';
    case Enum$EventSelectColumn.callId:
      return r'callId';
    case Enum$EventSelectColumn.extrinsicId:
      return r'extrinsicId';
    case Enum$EventSelectColumn.id:
      return r'id';
    case Enum$EventSelectColumn.indexEnum:
      return r'index';
    case Enum$EventSelectColumn.name:
      return r'name';
    case Enum$EventSelectColumn.pallet:
      return r'pallet';
    case Enum$EventSelectColumn.phase:
      return r'phase';
    case Enum$EventSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$EventSelectColumn fromJson$Enum$EventSelectColumn(String value) {
  switch (value) {
    case r'args':
      return Enum$EventSelectColumn.args;
    case r'argsStr':
      return Enum$EventSelectColumn.argsStr;
    case r'blockId':
      return Enum$EventSelectColumn.blockId;
    case r'callId':
      return Enum$EventSelectColumn.callId;
    case r'extrinsicId':
      return Enum$EventSelectColumn.extrinsicId;
    case r'id':
      return Enum$EventSelectColumn.id;
    case r'index':
      return Enum$EventSelectColumn.indexEnum;
    case r'name':
      return Enum$EventSelectColumn.name;
    case r'pallet':
      return Enum$EventSelectColumn.pallet;
    case r'phase':
      return Enum$EventSelectColumn.phase;
    default:
      return Enum$EventSelectColumn.$unknown;
  }
}

enum Enum$EventTypeEnum {
  CREATION,
  REMOVAL,
  RENEWAL,
  $unknown;

  factory Enum$EventTypeEnum.fromJson(String value) =>
      fromJson$Enum$EventTypeEnum(value);

  String toJson() => toJson$Enum$EventTypeEnum(this);
}

String toJson$Enum$EventTypeEnum(Enum$EventTypeEnum e) {
  switch (e) {
    case Enum$EventTypeEnum.CREATION:
      return r'CREATION';
    case Enum$EventTypeEnum.REMOVAL:
      return r'REMOVAL';
    case Enum$EventTypeEnum.RENEWAL:
      return r'RENEWAL';
    case Enum$EventTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$EventTypeEnum fromJson$Enum$EventTypeEnum(String value) {
  switch (value) {
    case r'CREATION':
      return Enum$EventTypeEnum.CREATION;
    case r'REMOVAL':
      return Enum$EventTypeEnum.REMOVAL;
    case r'RENEWAL':
      return Enum$EventTypeEnum.RENEWAL;
    default:
      return Enum$EventTypeEnum.$unknown;
  }
}

enum Enum$ExtrinsicSelectColumn {
  blockId,
  callId,
  error,
  fee,
  hash,
  id,
  indexEnum,
  signature,
  success,
  tip,
  version,
  $unknown;

  factory Enum$ExtrinsicSelectColumn.fromJson(String value) =>
      fromJson$Enum$ExtrinsicSelectColumn(value);

  String toJson() => toJson$Enum$ExtrinsicSelectColumn(this);
}

String toJson$Enum$ExtrinsicSelectColumn(Enum$ExtrinsicSelectColumn e) {
  switch (e) {
    case Enum$ExtrinsicSelectColumn.blockId:
      return r'blockId';
    case Enum$ExtrinsicSelectColumn.callId:
      return r'callId';
    case Enum$ExtrinsicSelectColumn.error:
      return r'error';
    case Enum$ExtrinsicSelectColumn.fee:
      return r'fee';
    case Enum$ExtrinsicSelectColumn.hash:
      return r'hash';
    case Enum$ExtrinsicSelectColumn.id:
      return r'id';
    case Enum$ExtrinsicSelectColumn.indexEnum:
      return r'index';
    case Enum$ExtrinsicSelectColumn.signature:
      return r'signature';
    case Enum$ExtrinsicSelectColumn.success:
      return r'success';
    case Enum$ExtrinsicSelectColumn.tip:
      return r'tip';
    case Enum$ExtrinsicSelectColumn.version:
      return r'version';
    case Enum$ExtrinsicSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$ExtrinsicSelectColumn fromJson$Enum$ExtrinsicSelectColumn(String value) {
  switch (value) {
    case r'blockId':
      return Enum$ExtrinsicSelectColumn.blockId;
    case r'callId':
      return Enum$ExtrinsicSelectColumn.callId;
    case r'error':
      return Enum$ExtrinsicSelectColumn.error;
    case r'fee':
      return Enum$ExtrinsicSelectColumn.fee;
    case r'hash':
      return Enum$ExtrinsicSelectColumn.hash;
    case r'id':
      return Enum$ExtrinsicSelectColumn.id;
    case r'index':
      return Enum$ExtrinsicSelectColumn.indexEnum;
    case r'signature':
      return Enum$ExtrinsicSelectColumn.signature;
    case r'success':
      return Enum$ExtrinsicSelectColumn.success;
    case r'tip':
      return Enum$ExtrinsicSelectColumn.tip;
    case r'version':
      return Enum$ExtrinsicSelectColumn.version;
    default:
      return Enum$ExtrinsicSelectColumn.$unknown;
  }
}

enum Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns {
  success,
  $unknown;

  factory Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
          this);
}

String toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
    Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
        e) {
  switch (e) {
    case Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
          .success:
      return r'success';
    case Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
    fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns(
        String value) {
  switch (value) {
    case r'success':
      return Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
          .success;
    default:
      return Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_andArgumentsColumns
          .$unknown;
  }
}

enum Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns {
  success,
  $unknown;

  factory Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns.fromJson(
          String value) =>
      fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
          value);

  String toJson() =>
      toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
          this);
}

String
    toJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
        Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
            e) {
  switch (e) {
    case Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
          .success:
      return r'success';
    case Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
          .$unknown:
      return r'$unknown';
  }
}

Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
    fromJson$Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns(
        String value) {
  switch (value) {
    case r'success':
      return Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
          .success;
    default:
      return Enum$ExtrinsicSelectColumnExtrinsicAggregateBoolExpBool_orArgumentsColumns
          .$unknown;
  }
}

enum Enum$IdentitySelectColumn {
  accountId,
  createdInId,
  createdOn,
  expireOn,
  id,
  indexEnum,
  isMember,
  lastChangeOn,
  name,
  smithStatus,
  status,
  $unknown;

  factory Enum$IdentitySelectColumn.fromJson(String value) =>
      fromJson$Enum$IdentitySelectColumn(value);

  String toJson() => toJson$Enum$IdentitySelectColumn(this);
}

String toJson$Enum$IdentitySelectColumn(Enum$IdentitySelectColumn e) {
  switch (e) {
    case Enum$IdentitySelectColumn.accountId:
      return r'accountId';
    case Enum$IdentitySelectColumn.createdInId:
      return r'createdInId';
    case Enum$IdentitySelectColumn.createdOn:
      return r'createdOn';
    case Enum$IdentitySelectColumn.expireOn:
      return r'expireOn';
    case Enum$IdentitySelectColumn.id:
      return r'id';
    case Enum$IdentitySelectColumn.indexEnum:
      return r'index';
    case Enum$IdentitySelectColumn.isMember:
      return r'isMember';
    case Enum$IdentitySelectColumn.lastChangeOn:
      return r'lastChangeOn';
    case Enum$IdentitySelectColumn.name:
      return r'name';
    case Enum$IdentitySelectColumn.smithStatus:
      return r'smithStatus';
    case Enum$IdentitySelectColumn.status:
      return r'status';
    case Enum$IdentitySelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$IdentitySelectColumn fromJson$Enum$IdentitySelectColumn(String value) {
  switch (value) {
    case r'accountId':
      return Enum$IdentitySelectColumn.accountId;
    case r'createdInId':
      return Enum$IdentitySelectColumn.createdInId;
    case r'createdOn':
      return Enum$IdentitySelectColumn.createdOn;
    case r'expireOn':
      return Enum$IdentitySelectColumn.expireOn;
    case r'id':
      return Enum$IdentitySelectColumn.id;
    case r'index':
      return Enum$IdentitySelectColumn.indexEnum;
    case r'isMember':
      return Enum$IdentitySelectColumn.isMember;
    case r'lastChangeOn':
      return Enum$IdentitySelectColumn.lastChangeOn;
    case r'name':
      return Enum$IdentitySelectColumn.name;
    case r'smithStatus':
      return Enum$IdentitySelectColumn.smithStatus;
    case r'status':
      return Enum$IdentitySelectColumn.status;
    default:
      return Enum$IdentitySelectColumn.$unknown;
  }
}

enum Enum$IdentityStatusEnum {
  MEMBER,
  NOTMEMBER,
  REMOVED,
  REVOKED,
  UNCONFIRMED,
  UNVALIDATED,
  $unknown;

  factory Enum$IdentityStatusEnum.fromJson(String value) =>
      fromJson$Enum$IdentityStatusEnum(value);

  String toJson() => toJson$Enum$IdentityStatusEnum(this);
}

String toJson$Enum$IdentityStatusEnum(Enum$IdentityStatusEnum e) {
  switch (e) {
    case Enum$IdentityStatusEnum.MEMBER:
      return r'MEMBER';
    case Enum$IdentityStatusEnum.NOTMEMBER:
      return r'NOTMEMBER';
    case Enum$IdentityStatusEnum.REMOVED:
      return r'REMOVED';
    case Enum$IdentityStatusEnum.REVOKED:
      return r'REVOKED';
    case Enum$IdentityStatusEnum.UNCONFIRMED:
      return r'UNCONFIRMED';
    case Enum$IdentityStatusEnum.UNVALIDATED:
      return r'UNVALIDATED';
    case Enum$IdentityStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$IdentityStatusEnum fromJson$Enum$IdentityStatusEnum(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$IdentityStatusEnum.MEMBER;
    case r'NOTMEMBER':
      return Enum$IdentityStatusEnum.NOTMEMBER;
    case r'REMOVED':
      return Enum$IdentityStatusEnum.REMOVED;
    case r'REVOKED':
      return Enum$IdentityStatusEnum.REVOKED;
    case r'UNCONFIRMED':
      return Enum$IdentityStatusEnum.UNCONFIRMED;
    case r'UNVALIDATED':
      return Enum$IdentityStatusEnum.UNVALIDATED;
    default:
      return Enum$IdentityStatusEnum.$unknown;
  }
}

enum Enum$ItemsCounterSelectColumn {
  id,
  level,
  total,
  type,
  $unknown;

  factory Enum$ItemsCounterSelectColumn.fromJson(String value) =>
      fromJson$Enum$ItemsCounterSelectColumn(value);

  String toJson() => toJson$Enum$ItemsCounterSelectColumn(this);
}

String toJson$Enum$ItemsCounterSelectColumn(Enum$ItemsCounterSelectColumn e) {
  switch (e) {
    case Enum$ItemsCounterSelectColumn.id:
      return r'id';
    case Enum$ItemsCounterSelectColumn.level:
      return r'level';
    case Enum$ItemsCounterSelectColumn.total:
      return r'total';
    case Enum$ItemsCounterSelectColumn.type:
      return r'type';
    case Enum$ItemsCounterSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$ItemsCounterSelectColumn fromJson$Enum$ItemsCounterSelectColumn(
    String value) {
  switch (value) {
    case r'id':
      return Enum$ItemsCounterSelectColumn.id;
    case r'level':
      return Enum$ItemsCounterSelectColumn.level;
    case r'total':
      return Enum$ItemsCounterSelectColumn.total;
    case r'type':
      return Enum$ItemsCounterSelectColumn.type;
    default:
      return Enum$ItemsCounterSelectColumn.$unknown;
  }
}

enum Enum$ItemTypeEnum {
  CALLS,
  EVENTS,
  EXTRINSICS,
  $unknown;

  factory Enum$ItemTypeEnum.fromJson(String value) =>
      fromJson$Enum$ItemTypeEnum(value);

  String toJson() => toJson$Enum$ItemTypeEnum(this);
}

String toJson$Enum$ItemTypeEnum(Enum$ItemTypeEnum e) {
  switch (e) {
    case Enum$ItemTypeEnum.CALLS:
      return r'CALLS';
    case Enum$ItemTypeEnum.EVENTS:
      return r'EVENTS';
    case Enum$ItemTypeEnum.EXTRINSICS:
      return r'EXTRINSICS';
    case Enum$ItemTypeEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ItemTypeEnum fromJson$Enum$ItemTypeEnum(String value) {
  switch (value) {
    case r'CALLS':
      return Enum$ItemTypeEnum.CALLS;
    case r'EVENTS':
      return Enum$ItemTypeEnum.EVENTS;
    case r'EXTRINSICS':
      return Enum$ItemTypeEnum.EXTRINSICS;
    default:
      return Enum$ItemTypeEnum.$unknown;
  }
}

enum Enum$MembershipEventSelectColumn {
  blockNumber,
  eventId,
  eventType,
  id,
  identityId,
  $unknown;

  factory Enum$MembershipEventSelectColumn.fromJson(String value) =>
      fromJson$Enum$MembershipEventSelectColumn(value);

  String toJson() => toJson$Enum$MembershipEventSelectColumn(this);
}

String toJson$Enum$MembershipEventSelectColumn(
    Enum$MembershipEventSelectColumn e) {
  switch (e) {
    case Enum$MembershipEventSelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$MembershipEventSelectColumn.eventId:
      return r'eventId';
    case Enum$MembershipEventSelectColumn.eventType:
      return r'eventType';
    case Enum$MembershipEventSelectColumn.id:
      return r'id';
    case Enum$MembershipEventSelectColumn.identityId:
      return r'identityId';
    case Enum$MembershipEventSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$MembershipEventSelectColumn fromJson$Enum$MembershipEventSelectColumn(
    String value) {
  switch (value) {
    case r'blockNumber':
      return Enum$MembershipEventSelectColumn.blockNumber;
    case r'eventId':
      return Enum$MembershipEventSelectColumn.eventId;
    case r'eventType':
      return Enum$MembershipEventSelectColumn.eventType;
    case r'id':
      return Enum$MembershipEventSelectColumn.id;
    case r'identityId':
      return Enum$MembershipEventSelectColumn.identityId;
    default:
      return Enum$MembershipEventSelectColumn.$unknown;
  }
}

enum Enum$OrderBy {
  ASC,
  ASC_NULLS_FIRST,
  ASC_NULLS_LAST,
  DESC,
  DESC_NULLS_FIRST,
  DESC_NULLS_LAST,
  $unknown;

  factory Enum$OrderBy.fromJson(String value) => fromJson$Enum$OrderBy(value);

  String toJson() => toJson$Enum$OrderBy(this);
}

String toJson$Enum$OrderBy(Enum$OrderBy e) {
  switch (e) {
    case Enum$OrderBy.ASC:
      return r'ASC';
    case Enum$OrderBy.ASC_NULLS_FIRST:
      return r'ASC_NULLS_FIRST';
    case Enum$OrderBy.ASC_NULLS_LAST:
      return r'ASC_NULLS_LAST';
    case Enum$OrderBy.DESC:
      return r'DESC';
    case Enum$OrderBy.DESC_NULLS_FIRST:
      return r'DESC_NULLS_FIRST';
    case Enum$OrderBy.DESC_NULLS_LAST:
      return r'DESC_NULLS_LAST';
    case Enum$OrderBy.$unknown:
      return r'$unknown';
  }
}

Enum$OrderBy fromJson$Enum$OrderBy(String value) {
  switch (value) {
    case r'ASC':
      return Enum$OrderBy.ASC;
    case r'ASC_NULLS_FIRST':
      return Enum$OrderBy.ASC_NULLS_FIRST;
    case r'ASC_NULLS_LAST':
      return Enum$OrderBy.ASC_NULLS_LAST;
    case r'DESC':
      return Enum$OrderBy.DESC;
    case r'DESC_NULLS_FIRST':
      return Enum$OrderBy.DESC_NULLS_FIRST;
    case r'DESC_NULLS_LAST':
      return Enum$OrderBy.DESC_NULLS_LAST;
    default:
      return Enum$OrderBy.$unknown;
  }
}

enum Enum$SmithCertSelectColumn {
  createdOn,
  id,
  issuerId,
  receiverId,
  $unknown;

  factory Enum$SmithCertSelectColumn.fromJson(String value) =>
      fromJson$Enum$SmithCertSelectColumn(value);

  String toJson() => toJson$Enum$SmithCertSelectColumn(this);
}

String toJson$Enum$SmithCertSelectColumn(Enum$SmithCertSelectColumn e) {
  switch (e) {
    case Enum$SmithCertSelectColumn.createdOn:
      return r'createdOn';
    case Enum$SmithCertSelectColumn.id:
      return r'id';
    case Enum$SmithCertSelectColumn.issuerId:
      return r'issuerId';
    case Enum$SmithCertSelectColumn.receiverId:
      return r'receiverId';
    case Enum$SmithCertSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$SmithCertSelectColumn fromJson$Enum$SmithCertSelectColumn(String value) {
  switch (value) {
    case r'createdOn':
      return Enum$SmithCertSelectColumn.createdOn;
    case r'id':
      return Enum$SmithCertSelectColumn.id;
    case r'issuerId':
      return Enum$SmithCertSelectColumn.issuerId;
    case r'receiverId':
      return Enum$SmithCertSelectColumn.receiverId;
    default:
      return Enum$SmithCertSelectColumn.$unknown;
  }
}

enum Enum$SmithStatusEnum {
  EXCLUDED,
  INVITED,
  PENDING,
  SMITH,
  $unknown;

  factory Enum$SmithStatusEnum.fromJson(String value) =>
      fromJson$Enum$SmithStatusEnum(value);

  String toJson() => toJson$Enum$SmithStatusEnum(this);
}

String toJson$Enum$SmithStatusEnum(Enum$SmithStatusEnum e) {
  switch (e) {
    case Enum$SmithStatusEnum.EXCLUDED:
      return r'EXCLUDED';
    case Enum$SmithStatusEnum.INVITED:
      return r'INVITED';
    case Enum$SmithStatusEnum.PENDING:
      return r'PENDING';
    case Enum$SmithStatusEnum.SMITH:
      return r'SMITH';
    case Enum$SmithStatusEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SmithStatusEnum fromJson$Enum$SmithStatusEnum(String value) {
  switch (value) {
    case r'EXCLUDED':
      return Enum$SmithStatusEnum.EXCLUDED;
    case r'INVITED':
      return Enum$SmithStatusEnum.INVITED;
    case r'PENDING':
      return Enum$SmithStatusEnum.PENDING;
    case r'SMITH':
      return Enum$SmithStatusEnum.SMITH;
    default:
      return Enum$SmithStatusEnum.$unknown;
  }
}

enum Enum$TransferSelectColumn {
  amount,
  blockNumber,
  comment,
  fromId,
  id,
  timestamp,
  toId,
  $unknown;

  factory Enum$TransferSelectColumn.fromJson(String value) =>
      fromJson$Enum$TransferSelectColumn(value);

  String toJson() => toJson$Enum$TransferSelectColumn(this);
}

String toJson$Enum$TransferSelectColumn(Enum$TransferSelectColumn e) {
  switch (e) {
    case Enum$TransferSelectColumn.amount:
      return r'amount';
    case Enum$TransferSelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$TransferSelectColumn.comment:
      return r'comment';
    case Enum$TransferSelectColumn.fromId:
      return r'fromId';
    case Enum$TransferSelectColumn.id:
      return r'id';
    case Enum$TransferSelectColumn.timestamp:
      return r'timestamp';
    case Enum$TransferSelectColumn.toId:
      return r'toId';
    case Enum$TransferSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$TransferSelectColumn fromJson$Enum$TransferSelectColumn(String value) {
  switch (value) {
    case r'amount':
      return Enum$TransferSelectColumn.amount;
    case r'blockNumber':
      return Enum$TransferSelectColumn.blockNumber;
    case r'comment':
      return Enum$TransferSelectColumn.comment;
    case r'fromId':
      return Enum$TransferSelectColumn.fromId;
    case r'id':
      return Enum$TransferSelectColumn.id;
    case r'timestamp':
      return Enum$TransferSelectColumn.timestamp;
    case r'toId':
      return Enum$TransferSelectColumn.toId;
    default:
      return Enum$TransferSelectColumn.$unknown;
  }
}

enum Enum$UdHistorySelectColumn {
  amount,
  blockNumber,
  id,
  identityId,
  timestamp,
  $unknown;

  factory Enum$UdHistorySelectColumn.fromJson(String value) =>
      fromJson$Enum$UdHistorySelectColumn(value);

  String toJson() => toJson$Enum$UdHistorySelectColumn(this);
}

String toJson$Enum$UdHistorySelectColumn(Enum$UdHistorySelectColumn e) {
  switch (e) {
    case Enum$UdHistorySelectColumn.amount:
      return r'amount';
    case Enum$UdHistorySelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$UdHistorySelectColumn.id:
      return r'id';
    case Enum$UdHistorySelectColumn.identityId:
      return r'identityId';
    case Enum$UdHistorySelectColumn.timestamp:
      return r'timestamp';
    case Enum$UdHistorySelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$UdHistorySelectColumn fromJson$Enum$UdHistorySelectColumn(String value) {
  switch (value) {
    case r'amount':
      return Enum$UdHistorySelectColumn.amount;
    case r'blockNumber':
      return Enum$UdHistorySelectColumn.blockNumber;
    case r'id':
      return Enum$UdHistorySelectColumn.id;
    case r'identityId':
      return Enum$UdHistorySelectColumn.identityId;
    case r'timestamp':
      return Enum$UdHistorySelectColumn.timestamp;
    default:
      return Enum$UdHistorySelectColumn.$unknown;
  }
}

enum Enum$UdReevalSelectColumn {
  blockNumber,
  eventId,
  id,
  membersCount,
  monetaryMass,
  newUdAmount,
  timestamp,
  $unknown;

  factory Enum$UdReevalSelectColumn.fromJson(String value) =>
      fromJson$Enum$UdReevalSelectColumn(value);

  String toJson() => toJson$Enum$UdReevalSelectColumn(this);
}

String toJson$Enum$UdReevalSelectColumn(Enum$UdReevalSelectColumn e) {
  switch (e) {
    case Enum$UdReevalSelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$UdReevalSelectColumn.eventId:
      return r'eventId';
    case Enum$UdReevalSelectColumn.id:
      return r'id';
    case Enum$UdReevalSelectColumn.membersCount:
      return r'membersCount';
    case Enum$UdReevalSelectColumn.monetaryMass:
      return r'monetaryMass';
    case Enum$UdReevalSelectColumn.newUdAmount:
      return r'newUdAmount';
    case Enum$UdReevalSelectColumn.timestamp:
      return r'timestamp';
    case Enum$UdReevalSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$UdReevalSelectColumn fromJson$Enum$UdReevalSelectColumn(String value) {
  switch (value) {
    case r'blockNumber':
      return Enum$UdReevalSelectColumn.blockNumber;
    case r'eventId':
      return Enum$UdReevalSelectColumn.eventId;
    case r'id':
      return Enum$UdReevalSelectColumn.id;
    case r'membersCount':
      return Enum$UdReevalSelectColumn.membersCount;
    case r'monetaryMass':
      return Enum$UdReevalSelectColumn.monetaryMass;
    case r'newUdAmount':
      return Enum$UdReevalSelectColumn.newUdAmount;
    case r'timestamp':
      return Enum$UdReevalSelectColumn.timestamp;
    default:
      return Enum$UdReevalSelectColumn.$unknown;
  }
}

enum Enum$UniversalDividendSelectColumn {
  amount,
  blockNumber,
  eventId,
  id,
  membersCount,
  monetaryMass,
  timestamp,
  $unknown;

  factory Enum$UniversalDividendSelectColumn.fromJson(String value) =>
      fromJson$Enum$UniversalDividendSelectColumn(value);

  String toJson() => toJson$Enum$UniversalDividendSelectColumn(this);
}

String toJson$Enum$UniversalDividendSelectColumn(
    Enum$UniversalDividendSelectColumn e) {
  switch (e) {
    case Enum$UniversalDividendSelectColumn.amount:
      return r'amount';
    case Enum$UniversalDividendSelectColumn.blockNumber:
      return r'blockNumber';
    case Enum$UniversalDividendSelectColumn.eventId:
      return r'eventId';
    case Enum$UniversalDividendSelectColumn.id:
      return r'id';
    case Enum$UniversalDividendSelectColumn.membersCount:
      return r'membersCount';
    case Enum$UniversalDividendSelectColumn.monetaryMass:
      return r'monetaryMass';
    case Enum$UniversalDividendSelectColumn.timestamp:
      return r'timestamp';
    case Enum$UniversalDividendSelectColumn.$unknown:
      return r'$unknown';
  }
}

Enum$UniversalDividendSelectColumn fromJson$Enum$UniversalDividendSelectColumn(
    String value) {
  switch (value) {
    case r'amount':
      return Enum$UniversalDividendSelectColumn.amount;
    case r'blockNumber':
      return Enum$UniversalDividendSelectColumn.blockNumber;
    case r'eventId':
      return Enum$UniversalDividendSelectColumn.eventId;
    case r'id':
      return Enum$UniversalDividendSelectColumn.id;
    case r'membersCount':
      return Enum$UniversalDividendSelectColumn.membersCount;
    case r'monetaryMass':
      return Enum$UniversalDividendSelectColumn.monetaryMass;
    case r'timestamp':
      return Enum$UniversalDividendSelectColumn.timestamp;
    default:
      return Enum$UniversalDividendSelectColumn.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown;

  factory Enum$__TypeKind.fromJson(String value) =>
      fromJson$Enum$__TypeKind(value);

  String toJson() => toJson$Enum$__TypeKind(this);
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown;

  factory Enum$__DirectiveLocation.fromJson(String value) =>
      fromJson$Enum$__DirectiveLocation(value);

  String toJson() => toJson$Enum$__DirectiveLocation(this);
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{
  'Node': {
    'Account',
    'Block',
    'Call',
    'Cert',
    'CertEvent',
    'ChangeOwnerKey',
    'Event',
    'Extrinsic',
    'Identity',
    'ItemsCounter',
    'MembershipEvent',
    'SmithCert',
    'Transfer',
    'UdHistory',
    'UdReeval',
    'UniversalDividend',
  }
};
